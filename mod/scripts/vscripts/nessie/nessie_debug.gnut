untyped

const bool DEBUG_ONLY_COMMANDS = true // otherwise we'll enable all debugging things, maybe messy

global function NessieDebug_Init

#if !DEBUG_ONLY_COMMANDS
//global function DebugParticle

global function SpawnHoloPulseAtPosition
global function SpawnWeaponEntity_CountLifeTime
global function PlayAnimGestureFromScript
global function CreateViewEntityForPlayer
global function StartTitanShieldHealthRegen

global function TTF1_WeaponUsage
global function CreateHumanGib
global function CreatePeteMri
global function CreateWeaponDrop

// testing!
//global function BecomeFakeBarker

global function NukeIncomingEffectForPlayer
#endif

const array<string> NESSIE_DEBUGGERS = // we use BATTERY_SPAWNERS more often...
[
	"1007270968017"
]

const asset DEBUGGING_PARTICLE = $"P_plasma_exp_LG" // to control

const asset SCREENFX_WARPJUMP                      = $"P_warpjump_FP"
const asset SCREENFX_WARPJUMPDLIGHT                = $"warpjump_CH_dlight"
const asset FX_KILLSHOT_BLOODSPRAY                 = $"P_deathfx_human"
const asset FX_BLOODSPRAY_DECAL_SML                = $"P_deathfx_human_decal_SML"
const asset FX_BLOODSPRAY_DECAL_MED                = $"P_deathfx_human_decal_MED"
const asset FX_BLOODSPRAY_DECAL_LRG                = $"P_deathfx_human_decal_LRG"

struct
{
	int dropshipSpawnIndex = 0
	table< string, int > playerAttackCountTable
} file

void function NessieDebug_Init()
{
	//AddClientCommandCallback( "doomedtitan", CC_SpawnDoomedTitan )
	//AddClientCommandCallback( "doomedpilottitan", CC_SpawnDoomedPilotTitan )

	//AddClientCommandCallback( "ragdoll", BeARagdoll )
	//AddClientCommandCallback( "fakedeath", FakeYourDeath )

	//AddClientCommandCallback( "spawngib", CC_SpawnHumanGib ) 
	//AddClientCommandCallback( "spawnmri", CC_SpawnPilotMri )

	//AddClientCommandCallback( "mirage_decoy", CC_SpawnMirageDecoy )
	//AddClientCommandCallback( "spawnweapon", CC_SpawnWeapon )

	//AddClientCommandCallback( "freeaircontrol", CC_FreeAirControl )
	//AddClientCommandCallback( "nextDropshipSpawn", CC_GoNextDropshipSpawn )

	//AddClientCommandCallback( "rocketturret", CC_CreateRocketTurret )
	//AddClientCommandCallback( "remoterocket", CC_CreateRocketRemoteTurret )
	//AddClientCommandCallback( "remoteplasma", CC_CreatePlasmaRemoteTurret )
	//AddClientCommandCallback( "remotesentry", CC_CreateSentryRemoteTurret )

	//AddClientCommandCallback( "pinkMistFxOnWorld", CC_PinkMistEffectOnWorld )
	//AddClientCommandCallback( "pinkMistFxOnSelf", CC_PinkMistEffectOnPlayer )

	//AddClientCommandCallback( "bliskFullBodyGroup", CC_BliskFullBodyGroup )
	//PrecacheModel( $"models/humans/heroes/mlt_hero_jill.mdl" )
	//AddClientCommandCallback( "mltHeroJill", CC_MltJillModel )

	//PrecacheModel( $"models/robots/aerial_unmanned_worker/aerial_unmanned_worker.mdl" )
	//AddClientCommandCallback( "workerdrone", CC_SpawnDroneWorker )

	//AddClientCommandCallback( "dissolve_core_effect", DissolveCoreEffectOnPlayer )
	//AddClientCommandCallback( "dissolve_char_effect", DissolveCharEffectOnPlayer )
	//AddClientCommandCallback( "dissolve_pinkmist_effect", DissolvePinkmistEffectOnPlayer )

	//AddClientCommandCallback( "tptrack", CC_ThirdPersonTrackView )

	//AddClientCommandCallback( "marvin", CC_RandomHeadMarvin )
	//AddClientCommandCallback( "nessieragdoll", CC_SpawnNessieRagdoll )

	//AddClientCommandCallback( "becomemri", CC_BecomePeteMRI )

	//AddClientCommandCallback( "usablePropPhysics", CC_CreateUsablePropPhysics )

	//AddClientCommandCallback( "fp_animation", CC_DoFirstPersonSequence )

	//AddClientCommandCallback( "personal_titan_shield", CC_SpawnPersonalTitanShield )

	//AddClientCommandCallback( "npc_destroyed_callback", CC_AddDestroyedCallbackForAllNPCs )
	//AddClientCommandCallback( "gunship_dogfight", CC_StartNPCGunshipDogfight )

	#if !DEBUG_ONLY_COMMANDS
		// new test things
		// these has been turn to unused
		//MeleeSyncedHuman_EnableRandomExecutions( true ) 
		//MeleeSyncedHuman_AlwaysDoAiExecutions( true )
		//MeleeSyncedTitan_EnableRandomExecutions( true )
		//MeleeSyncedTitan_AlwaysDoAiExecutions( true )
		//MeleeSyncedNPC_NPCUseNormalSyncedMelee( true )

		PrecacheParticleSystem( $"env_thaw_interior_tank_pollen" )
		PrecacheParticleSystem( $"P_ar_holopulse_CP" )
		PrecacheParticleSystem( $"overhead_icon_ai_friendly" )
		PrecacheParticleSystem( $"TDP_wave" )
		PrecacheParticleSystem( $"P_holo_screespace" )

		// blood
		PrecacheParticleSystem( $"death_pinkmist_LG" )
		PrecacheParticleSystem( $"death_pinkmist_LG_nochunk" ) // ideal for knock players down

		PrecacheParticleSystem( $"P_ar_impact_pilot" )
		PrecacheParticleSystem( $"P_ar_impact_pilot_headshot" )
		PrecacheParticleSystem( $"P_ar_impact_pilot_kill" )
		PrecacheParticleSystem( $"xo_spark_bolt" )

		PrecacheParticleSystem( $"xo_damage_exp_1" )
		PrecacheParticleSystem( $"xo_damage_exp_2" ) // ideal for knock players down
		PrecacheParticleSystem( $"xo_exp_death" )

		PrecacheParticleSystem( $"impact_flesh" )
		PrecacheParticleSystem( $"P_impact_metal_spectre" )

		// blood fog?
		PrecacheParticleSystem( $"P_impact_flesh_attacker" )
		PrecacheParticleSystem( $"P_impact_flesh_victim" )

		// lstar elec
		PrecacheParticleSystem( $"P_impact_lstar_victim" )
		
		// hitting decoy
		PrecacheParticleSystem( $"P_holohit_impact" )

		// doubletake flash
		PrecacheParticleSystem( $"P_impact_flesh_victim_elec" )

		// emp airburst
		PrecacheParticleSystem( $"P_impact_exp_emp_med_air" )

		// plasma impact
		PrecacheParticleSystem( $"P_plasma_exp_LG" )
		//

		PrecacheParticleSystem( SCREENFX_WARPJUMP )
		PrecacheParticleSystem( SCREENFX_WARPJUMPDLIGHT )
		PrecacheParticleSystem( FX_KILLSHOT_BLOODSPRAY )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_SML )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_MED )
		PrecacheParticleSystem( FX_BLOODSPRAY_DECAL_LRG )

		// nuke
		RegisterSignal( "NukeIncomingEffect" )

		//Riff_ForceTitanAvailability( eTitanAvailability.Never )
		//Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
		//AddCallback_OnPlayerRespawned( OnPlayerRespawned )
		//AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerGetsNewPilotLoadout )

		AddCallback_OnClientConnected( OnClientConnected )
		//HoldingUp_Props_Init()

		ScoreBoardModifier( PGS_ASSAULT_SCORE )
	#endif // !DEBUG_ONLY_COMMANDS
}


///////////////////////////
///// CLIENT COMMANDS /////
///////////////////////////

bool function CC_SpawnDoomedTitan( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	vector pos = GetPlayerCrosshairOrigin( player )
	vector angs = player.EyeAngles()
	entity titan = CreateOgre( TEAM_BOTH, pos, angs )
	DispatchSpawn( titan )

	titan.TakeDamage( titan.GetMaxHealth() + 1, null, null, 0 ) 
	//DoomTitan( titan )
	print( "[NESSIE] " + player.GetPlayerName() + " spawned a doomed titan!" )
	return true
}

bool function CC_SpawnDoomedPilotTitan( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector angs = player.EyeAngles()
	entity titan = CreateOgre( TEAM_BOTH, pos, angs )
	SetSpawnOption_AISettings( titan, "npc_titan_ogre_minigun" )
	DispatchSpawn( titan )

	titan.TakeDamage( titan.GetMaxHealth() + 1, null, null, 0 ) 
	//DoomTitan( titan )
	print( "[NESSIE] " + player.GetPlayerName() + " spawned a doomed npc pilot titan!" )

	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return true

	// mark as having a pilot valid
	titanSoul.soul.seatedNpcPilot.isValid				= true
	titanSoul.soul.seatedNpcPilot.team 					= TEAM_BOTH

	titanSoul.soul.seatedNpcPilot.modelAsset 			= $"models/humans/pilots/pilot_medium_geist_m.mdl"
	titanSoul.soul.seatedNpcPilot.title 				= "PILOT"

	titanSoul.soul.seatedNpcPilot.isInvulnerable		= false

	titanSoul.soul.seatedNpcPilot.health				= 250

	return true
}

bool function BeARagdoll( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	ClearNessy( player )
	player.SetInvulnerable()
	HolsterAndDisableWeapons( player )
	player.BecomeRagdoll( Vector(0,0,0), false )
	print( "[NESSIE] " + player.GetPlayerName() + " has become ragdoll!" )
	return true
}

bool function FakeYourDeath( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	ClearNessy( player )
	player.SetContinueAnimatingAfterRagdoll( true )
	player.BecomeRagdoll( Vector(0,0,0), false )
	print( "[NESSIE] " + player.GetPlayerName() + " has fake their death!" )
	return true
}

/* 
	index
	studio "gib_lump_LOD0.smd"
	studio "gib_small_02_LOD0.smd"
	studio "gib_brain_LOD0.smd"
	studio "gib_muscle_LOD0.smd"
	studio "gib_small_01_LOD0.smd"
*/

bool function CC_SpawnHumanGib( entity player, array<string> args )
{
	//CreateHumanGib( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	CreateHumanGib( GetPlayerCrosshairOrigin( player ), player.EyeAngles(), 1.5, 2 ) // bigger brain
	return true
}

bool function CC_SpawnPilotMri( entity player, array<string> args )
{
	entity mri = CreatePeteMri( GetPlayerCrosshairOrigin( player ), player.EyeAngles() )
	SetTeam( mri, player.GetTeam() )
	return true
}

bool function CC_SpawnMirageDecoy( entity player, array<string> args )
{
	CreateMirageDecoyForPlayer( player )
	return true
}

bool function CC_SpawnWeapon( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player )

	CreateWeaponDrop( origin, < 0, 0, 0 >, "mp_weapon_smart_pistol" )
	return true
}

// test nuke thing
void function NukeIncomingEffectForPlayer( entity player, float timeBeforeNuke = 2.5 )
{
	player.EndSignal( "OnDestroy" )
	player.Signal( "NukeIncomingEffect" )
	player.EndSignal( "NukeIncomingEffect" )
	float bloomScale = 1.0
	float sunScale = -1.0

	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_alarm" )
	wait 1.2
	
	float endTime = Time() + timeBeforeNuke + 0.6
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_charge" )
	
	thread DelayedDoNukeSound( player, timeBeforeNuke )
	while ( Time() < endTime )
	{
		Remote_CallFunction_Replay( player, "ServerCallback_ScreenShake", 5, 10, 0.5 )
		Remote_CallFunction_NonReplay( player, "ServerCallback_SetMapSettings", bloomScale, false, 1.0, 1.0, 1.0, 0, 0, sunScale, 1.0 )
		bloomScale += 0.2
		sunScale -= 0.1
		WaitFrame()
	}
}

void function DelayedDoNukeSound( entity player, float timeBeforeNuke )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "NukeIncomingEffect" )
	wait timeBeforeNuke
	ScreenFade( player, 255, 255, 255, 255, 0.5, 10, FFADE_OUT | FFADE_PURGE )
	wait 0.9
	Remote_CallFunction_NonReplay( player, "ServerCallback_ResetMapSettings" )
	EmitSoundOnEntityOnlyToPlayer( player, player, "titan_nuclear_death_explode" )
	wait 10
}

bool function CC_CreateRocketTurret( entity player, array<string> args )
{
	int team = player.GetTeam()
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >

	CreateRocketTurret( team, origin, angles )
	return true
}

// turrets
entity function CreateRocketTurret( int team, vector origin, vector angles )
{
	entity turret = CreateNPC( "npc_turret_sentry", team, origin, angles )
	turret.StartDeployed()
	SetSpawnOption_AISettings( turret, "npc_turret_sentry_plasma" )
	SetSpawnOption_Weapon( turret, "mp_weapon_yh803" )
	DispatchSpawn( turret )
	turret.SetTitle( "#WPN_BLASTER_TURRET" )
	turret.SetModel( ROCKET_TURRET_MODEL )
	//turret.TakeActiveWeapon()
	//turret.GiveWeapon( "mp_turretweapon_blaster" )
	//turret.SetActiveWeaponByName( "mp_turretweapon_blaster" )

	return turret
}

bool function CC_CreateRocketRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, ROCKET_TURRET_MODEL, "mp_turretweapon_blaster" )
	return true
}

bool function CC_CreatePlasmaRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, PLASMA_TURRET_MODEL, "mp_turretweapon_plasma" )
	return true
}

bool function CC_CreateSentryRemoteTurret( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player ) - < 0, 0, 20 >
	vector angles = < 0, player.EyeAngles().y, 0 >
	
	vector panelAngles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 > 
	vector panelOrigin = origin + AnglesToForward( panelAngles ) * 100 - < 0, 0, 10 > // 100 units closer to player

	CreateRemoteTurret( origin, angles, panelOrigin, panelAngles, HITSCAN_TURRET_MODEL, "mp_turretweapon_sentry" )
	return true
}

/* // turret settings
	"droppod_fireteam_turret"
	"PROTO_at_turret"		// have special pov
	"redeye_turret"
	"redeye_turret_ai"
	"sat_strike_turret"		// cannot change direction
	"turret_imc_lrg"
*/

/* // turret models
	SENTRY_TURRET_MODEL and PLASMA_TURRET_MODEL(same)
	ROCKET_TURRET_MODEL
	HITSCAN_TURRET_MODEL
*/

entity function CreateRemoteTurret( vector origin, vector angles, vector panelOrigin, vector panelAngles, asset turretModel, string turretWeapon )
{
	RemoteTurretSettings info

	info.turretOrigin = origin
	info.turretAngles = angles
	info.panelOrigin = panelOrigin
	info.panelAngles = panelAngles

	info.turretSettingsName		= "PROTO_at_turret"
	info.weaponName				= turretWeapon
	info.turretModel			= turretModel
	info.panelModel				= CONTROL_PANEL_MODEL

	info.viewClampEnabled		= true
	info.viewClampRangeYaw		= 120
	info.viewClampRangePitch	= 120
	info.viewStartPitch			= 0

	entity turret = CreateRemoteTurretAndControlPanel( info )
	return turret
}

bool function CC_FreeAirControl( entity player, array<string> args )
{
	thread GiveFreeAirControlLifeLong( player )
	return true
}

void function GiveFreeAirControlLifeLong( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	array<string> classMods = player.GetPlayerSettingsMods()
	classMods.append( "disable_doublejump" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), classMods )

	while ( true )
	{
		player.SetGroundFrictionScale( 0.0 )
		player.kv.gravity = 0.0001

		vector angles = player.EyeAngles()
		angles.z = 0
		angles.x = 0
		angles.y = ClampAngle( angles.y - 90 )
		vector moveVel = GetVectorFromInput( player ) * 40 //AnglesToForward( angles ) * 40
		if ( player.IsInputCommandHeld( IN_JUMP ) )
		{
			moveVel.z = 40
			if ( player.IsOnGround() )
				moveVel.z = 230 // at least 230 vertical force required to lift a standing player
		}
		if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			moveVel.z = -40
		player.SetVelocity( player.GetVelocity() + moveVel )
		WaitFrame()
	}
}

vector function GetVectorFromInput( entity player )
{
	vector angles = player.EyeAngles()
	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	vector directionForward = GetDirectionFromInput( angles, xAxis, yAxis )

	return directionForward
}

vector function GetDirectionFromInput( vector playerAngles, float xAxis, float yAxis )
{
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}

bool function CC_GoNextDropshipSpawn( entity player, array<string> args )
{
	array<entity> validDropshipSpawns
	array<entity> dropshipSpawns = GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" )
	foreach ( entity dropshipSpawn in dropshipSpawns )
	{
		if ( dropshipSpawn.HasKey( "gamemode_" + GetSpawnpointGamemodeOverride() ) )
		{
			if ( dropshipSpawn.kv[ "gamemode_" + GetSpawnpointGamemodeOverride() ] == "0" )
				continue
		}

		validDropshipSpawns.append( dropshipSpawn )
	}

	int totalSpawns = validDropshipSpawns.len()
	entity currentDropshipSpawn = validDropshipSpawns[ file.dropshipSpawnIndex ]
	player.SetOrigin( currentDropshipSpawn.GetOrigin() )
	player.SetAngles( currentDropshipSpawn.GetAngles() )
	print( "Current mode has " + string( totalSpawns ) + " dropship spawns in total" )
	print( "This dropship spawn is: " + currentDropshipSpawn.GetTargetName() )
	print( "This dropship spawn's team: " + string( currentDropshipSpawn.GetTeam() ) )
	print( "dropshipSpawnIndex: " + string( file.dropshipSpawnIndex ) )

	file.dropshipSpawnIndex += 1
	if ( file.dropshipSpawnIndex == validDropshipSpawns.len() )
		file.dropshipSpawnIndex = 0

	return true
}

bool function CC_PinkMistEffectOnWorld( entity player, array<string> args )
{
	int particleIndex = GetParticleSystemIndex( $"death_pinkmist_LG_nochunk" )
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
	vector origin = player.GetAttachmentOrigin( attachmentIndex )
	vector angles = player.GetAttachmentAngles( attachmentIndex )
	//entity fx = PlayFX( MECHNAICAL_PINKMIST_FX, origin, angles)
	entity fx = StartParticleEffectInWorld_ReturnEntity( particleIndex, origin, angles )
	EffectSetControlPointVector( fx, 1, < 0, 0, 0 > ) // prevent blood fx fly everywhere
	SetForceDrawWhileParented( fx, true )
	return true
	
}

bool function CC_PinkMistEffectOnPlayer( entity player, array<string> args )
{
	int particleIndex = GetParticleSystemIndex( $"death_pinkmist_LG_nochunk" )
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
	//vector origin = victim.GetAttachmentOrigin( attachmentIndex )
	//vector angles = victim.GetAttachmentAngles( attachmentIndex )
	//entity fx = PlayFX( MECHNAICAL_PINKMIST_FX, origin, angles)
	entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	EffectSetControlPointVector( fx, 1, < 0, 0, 0 > ) // prevent blood fx fly everywhere
	SetForceDrawWhileParented( fx, true )
	return true
}

bool function CC_BliskFullBodyGroup( entity player, array<string> args )
{
	player.SetModel( $"models/humans/heroes/imc_hero_blisk.mdl" )
	player.SetBodygroup( player.FindBodyGroup( "mri" ), 1 )
	player.SetBodygroup( player.FindBodyGroup( "helmet" ), 1 )
	player.SetBodygroup( player.FindBodyGroup( "knife" ), 0 )

	return true
}

bool function CC_MltJillModel( entity player, array<string> args )
{
	player.SetModel( $"models/humans/heroes/mlt_hero_jill.mdl" )

	return true
}

bool function CC_SpawnDroneWorker( entity player, array<string> args )
{
	entity drone = CreateNPC( "npc_drone", player.GetTeam(), player.GetOrigin(), < 0, player.GetAngles().y, 0 > )
	SetSpawnOption_AISettings( drone, "npc_drone_worker" )
	drone.kv.rendercolor = "190 0 0"
	DispatchSpawn( drone )

	return true
}

bool function DissolveCoreEffectOnPlayer( entity player, array<string> args )
{
	player.DissolveNonLethal( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 500 ), 500 )
	thread DealyedStopDissolve( player )

	return true
}

bool function DissolveCharEffectOnPlayer( entity player, array<string> args )
{
	player.DissolveNonLethal( ENTITY_DISSOLVE_CHAR, Vector( 0, 0, 500 ), 500 )
	thread DealyedStopDissolve( player )

	return true
}

bool function DissolvePinkmistEffectOnPlayer( entity player, array<string> args )
{
	player.DissolveNonLethal( ENTITY_DISSOLVE_PINKMIST, Vector( 0, 0, 500 ), 500 ) // weird sound!
	thread DealyedStopDissolve( player )

	return true
}

void function DealyedStopDissolve( entity player )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame()
	player.DissolveStop()
}

bool function CC_ThirdPersonTrackView( entity player, array<string> args )
{
	PlayerSkydiveThirdPersonEnable( player )
	return true
}

void function PlayerSkydiveThirdPersonEnable( entity player )
{
	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person
	//player.SetTrackEntity( GetNPCArray()[0] )
	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -89 )
	player.SetTrackEntityMaxPitch( 89 )
	player.SetTrackEntityOffset( < -150.0, 0, 30.0 > )
	//player.SetTrackEntityOffsetDistance( -50.0 )
	//player.SetTrackEntityOffsetHeight( 30.0 )
}

bool function CC_RandomHeadMarvin( entity player, array<string> args )
{
	int team = player.GetTeam()
	vector origin = GetPlayerCrosshairOrigin( player )
	vector angles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	entity marvin = CreateMarvin( team, origin, angles )
	DispatchSpawn( marvin )
	marvin.SetBodygroup( marvin.FindBodyGroup( "head" ), RandomInt( 3 ) )
	thread DelayedRagdollMarvin( marvin )
	return true
}

void function DelayedRagdollMarvin( entity marvin )
{
	marvin.EndSignal( "OnDestroy" )

	wait 5
	marvin.BecomeRagdoll( < 0, 0, 100000 >, false )
}

bool function CC_SpawnNessieRagdoll( entity player, array<string> args )
{
	vector origin = GetPlayerCrosshairOrigin( player )
	vector angles = < 0, ClampAngle( player.EyeAngles().y - 180 ), 0 >
	entity nessie = CreatePropDynamic( $"models/domestic/nessy_doll.mdl" )
	entity test = CreatePropDynamic( $"models/industrial/grappling_hook_end.mdl" )

	nessie.SetOrigin( origin )
	nessie.SetAngles( angles )
	//nessie.BecomeRagdoll( < 0, 0, 100000 >, false )
	test.SetOrigin( origin )
	test.SetAngles( angles )

	return true
}

bool function CC_BecomePeteMRI( entity player, array<string> args )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	player.SetBodygroup( player.FindBodyGroup( "mri" ), 1 )
	player.SetBodygroup( player.FindBodyGroup( "head" ), 1 )
	player.SetBodygroup( player.FindBodyGroup( "body" ), 1 )
	player.SetBodygroup( player.FindBodyGroup( "legs" ), 0 )

	return true
}

bool function CC_CreateUsablePropPhysics( entity player, array<string> args )
{
	entity weaponProp = CreateEntity( "prop_physics" )
	weaponProp.SetValueForModelKey( $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl" )

	weaponProp.kv.spawnflags = 261 // non solid for now
	weaponProp.kv.fadedist = -1
	weaponProp.kv.renderamt = 0
	weaponProp.kv.rendercolor = "255 255 255"
	weaponProp.kv.physdamagescale = "0.1"
	weaponProp.kv.massScale = "1"
	//weaponProp.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
	weaponProp.kv.inertiaScale = 1.0

	DispatchSpawn( weaponProp )

	weaponProp.SetModel( $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl" )
	weaponProp.SetUsable()
    //weaponProp.SetUsableByGroup( "titan" )
    weaponProp.SetUsePrompts( "按住 %use% 以撿起", "按下 %use% 以撿起" )
	// prop physics can show use prompts even when they're not solid!!!

	weaponProp.SetOrigin( player.GetOrigin() )
	AddCallback_OnUseEntity( weaponProp, OnUseWeaponProp )
	return true
}

function OnUseWeaponProp( weaponProp, player )
{
	expect entity( player )
	player.Die( player, player, { damageSourceId = damagedef_suicide } )
}

bool function CC_DoFirstPersonSequence( entity player, array<string> args )
{
	entity fpProxy = player.GetPredictedFirstPersonProxy()
	if ( args.len() == 0 )
	{
		if ( fpProxy.Anim_IsActive() )
			fpProxy.Anim_Stop()
		return true
	}

	thread WeaponHolsteringSequenceThink( player, args[0] )

	return true
}

void function WeaponHolsteringSequenceThink( entity player, string fpAnim )
{
	player.EndSignal( "OnDestroy" )

	entity fpProxy = player.GetPredictedFirstPersonProxy()
	FirstPersonSequenceStruct sequence
	sequence.firstPersonAnim = fpAnim
	if ( fpProxy.Anim_HasSequence( sequence.firstPersonAnim ) )
	{
		HolsterAndDisableWeapons( player )
		thread FirstPersonSequence( sequence, player )
		WaitSignal( player, "OnAnimationInterrupted", "OnAnimationDone", "OnDeath" )
		DeployAndEnableWeapons( player )
	}
}

bool function CC_SpawnPersonalTitanShield( entity player, array<string> args )
{
	TitanPersonalShield( player )
	//TitanPersonalShield( player, 1500, 15, 0.1 )
	//thread ActivatePersonalShield_Recreate( player, 15 )
	return true
}

/*
entity function TitanPersonalShield( entity owner, int vortexHealth = 1500, float duration = -1 )
{
	//------------------------------
	// Shield vars
	//------------------------------
	vector origin = owner.GetOrigin()
	vector angles = owner.GetAngles() + Vector( 0, 0, 180 )

	float shieldWallRadius = SHIELD_WALL_RADIUS // 90
	asset shieldFx = SHIELD_WALL_FX
	float wallFOV = SHIELD_WALL_FOV
	float shieldWallHeight = SHIELD_WALL_RADIUS * 2

	//------------------------------
	// Vortex to block the actual bullets
	//------------------------------
	entity vortexSphere = CreateEntity( "vortex_sphere" )

	vortexSphere.kv.spawnflags = SF_ABSORB_BULLETS | SF_BLOCK_OWNER_WEAPON | SF_BLOCK_NPC_WEAPON_LOF | SF_ABSORB_CYLINDER
	vortexSphere.kv.enabled = 0
	vortexSphere.kv.radius = shieldWallRadius
	vortexSphere.kv.height = shieldWallHeight
	vortexSphere.kv.bullet_fov = wallFOV
	vortexSphere.kv.physics_pull_strength = 25
	vortexSphere.kv.physics_side_dampening = 6
	vortexSphere.kv.physics_fov = 360
	vortexSphere.kv.physics_max_mass = 2
	vortexSphere.kv.physics_max_size = 6

	vortexSphere.SetAngles( angles ) // viewvec?
	vortexSphere.SetOrigin( origin + Vector( 0, 0, shieldWallRadius - 64 ) )

	vortexSphere.SetMaxHealth( vortexHealth )
	vortexSphere.SetHealth( vortexHealth )
	SetTeam( vortexSphere, owner.GetTeam() )

	DispatchSpawn( vortexSphere )
	if ( duration > 0 )
		thread ShieldDestroyAfterTime( vortexSphere, owner, duration )

	EntFireByHandle( vortexSphere, "Enable", "", 0, null, null )

	vortexSphere.SetTakeDamageType( DAMAGE_YES )
	vortexSphere.ClearInvulnerable() // make particle wall invulnerable to weapon damage. It will still drain over time

	//------------------------------------------
	// Shield wall fx for visuals/health drain
	//------------------------------------------
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	entity mover = CreateScriptMover()
	mover.SetOrigin( owner.GetOrigin() )
	vector moverAngles = owner.GetPlayerOrNPCViewVector()
	moverAngles = VectorToAngles( moverAngles )
	mover.SetAngles( AnglesCompose( moverAngles, <0,0,180> ) )

	int fxid = GetParticleSystemIndex( shieldFx )
	entity shieldWallFX = StartParticleEffectOnEntity_ReturnEntity( mover, fxid, FX_PATTACH_ABSORIGIN_FOLLOW, 0 )
	shieldWallFX.DisableHibernation()
	EffectSetControlPointEntity( shieldWallFX, 0, mover )

	//thread DrawArrowOnTag( mover )
	vortexSphere.e.shieldWallFX = shieldWallFX
	vector color = GetShieldTriLerpColor( 0.0 )

	// update fx origin
	shieldWallFX.SetOrigin( Vector( 0, 0, -shieldWallHeight ) )

	cpoint.SetOrigin( color )
	EffectSetControlPointEntity( shieldWallFX, 1, cpoint )
	SetVortexSphereShieldWallCPoint( vortexSphere, cpoint )

	//-----------------------
	// Attach shield to owner
	//------------------------
	vortexSphere.SetParent( mover )

	vortexSphere.EndSignal( "OnDestroy" )
	Assert( IsAlive( owner ) )
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "ArcStunned" )
	mover.EndSignal( "OnDestroy" )
	#if MP
	shieldWallFX.EndSignal( "OnDestroy" )
	#endif

	OnThreadEnd(
	function() : ( owner, mover, vortexSphere )
		{
			if ( IsValid( owner ) )
			{
				owner.kv.defenseActive = false
			}

			StopShieldWallFX( vortexSphere )

			if ( IsValid( vortexSphere ) )
				vortexSphere.Destroy()

			if ( IsValid( mover ) )
			{
				//PlayFX( SHIELD_BREAK_FX, mover.GetOrigin(), mover.GetAngles() )
				mover.Destroy()
			}
		}
	)

	owner.kv.defenseActive = true

	for ( ;; )
	{
		Assert( IsAlive( owner ) )
		UpdateShieldPosition( mover, owner )

		#if MP
		if ( IsCloaked( owner ) )
			EntFireByHandle( shieldWallFX, "Stop", "", 0, null, null )
		else
			EntFireByHandle( shieldWallFX, "Start", "", 0, null, null )
		#endif
	}
}
*/

void function TitanPersonalShield( entity owner, int vortexHealth = 1500, float duration = 15, float shieldMoveSpeedScale = 1.0 )
{
	thread TitanPersonalShield_Threaded( owner, vortexHealth, duration, shieldMoveSpeedScale )
}

void function TitanPersonalShield_Threaded( entity owner, int vortexHealth, float duration, float shieldMoveSpeedScale )
{
	if ( duration <= 0 )
		return
	//------------------------------
	// Shield vars
	//------------------------------
	vector origin = owner.GetOrigin()
	vector angles = VectorToAngles( owner.GetPlayerOrNPCViewVector() )
	angles.x = 0
	angles.z = 0

	float shieldWallRadius = SHIELD_WALL_RADIUS // 90
	asset shieldFx = SHIELD_WALL_FX
	float wallFOV = SHIELD_WALL_FOV
	float shieldWallHeight = SHIELD_WALL_RADIUS * 2

	//------------------------------
	// Vortex to block the actual bullets
	//------------------------------
	entity vortexSphere = CreateShieldWithSettings( origin + < 0, 0, -64 >, angles, SHIELD_WALL_RADIUS, SHIELD_WALL_RADIUS * 2, SHIELD_WALL_FOV, duration, vortexHealth, SHIELD_WALL_FX )
	thread DrainHealthOverTime( vortexSphere, vortexSphere.e.shieldWallFX, duration )

	//vortexSphere.SetAngles( angles ) // viewvec?
	//vortexSphere.SetOrigin( origin + Vector( 0, 0, shieldWallRadius - 64 ) )

	// update fx origin
	//vortexSphere.e.shieldWallFX.SetOrigin( Vector( 0, 0, shieldWallHeight ) )

	//-----------------------
	// Attach shield to owner
	//------------------------
	entity mover = CreateScriptMover()
	mover.SetOrigin( origin )
	mover.SetAngles( angles )
	
	vortexSphere.SetParent( mover )

	vortexSphere.EndSignal( "OnDestroy" )
	Assert( IsAlive( owner ) )
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "ArcStunned" )
	mover.EndSignal( "OnDestroy" )
	#if MP
	vortexSphere.e.shieldWallFX.EndSignal( "OnDestroy" )
	#endif

	OnThreadEnd(
	function() : ( owner, mover, vortexSphere )
		{
			if ( IsValid( owner ) )
			{
				owner.kv.defenseActive = false
			}

			StopShieldWallFX( vortexSphere )

			if ( IsValid( vortexSphere ) )
				vortexSphere.Destroy()

			if ( IsValid( mover ) )
			{
				//PlayFX( SHIELD_BREAK_FX, mover.GetOrigin(), mover.GetAngles() )
				mover.Destroy()
			}
		}
	)

	owner.kv.defenseActive = true

	for ( ;; )
	{
		Assert( IsAlive( owner ) )
		UpdateShieldPosition( mover, owner, shieldMoveSpeedScale )

		#if MP
		if ( IsCloaked( owner ) )
			EntFireByHandle( vortexSphere.e.shieldWallFX, "Stop", "", 0, null, null )
		else
			EntFireByHandle( vortexSphere.e.shieldWallFX, "Start", "", 0, null, null )
		#endif
	}
}

void function ShieldDestroyAfterTime( entity vortexSphere, entity owner, float delay )
{
	wait delay
	if( !IsValid(owner) )
		return
	if( !IsValid(vortexSphere) )
		return
	vortexSphere.SetHealth( 0 )
}

void function UpdateShieldPosition( entity mover, entity owner, float shieldMoveSpeedScale = 1.0 )
{
	float moveTime = 0.1 / shieldMoveSpeedScale
	mover.NonPhysicsMoveTo( owner.GetOrigin(), moveTime, 0.0, 0.0 )

	WaitFrame()
}

bool function CC_AddDestroyedCallbackForAllNPCs( entity player, array<string> args )
{
	foreach ( entity npc in GetNPCArray() )
		AddEntityDestroyedCallback( npc, OnNPCDestroyed )
	return true
}

function OnNPCDestroyed( npc )
{
	expect entity( npc )
	print( "RUNNING OnNPCDestroyed() : " + string( npc ) )

	// failsafe case: npc has been destroyed but they haven't been cleared from spawnedNPCs
	// NOTE: if we're in map loading screen( before server entity creation ), we shouldn't do anything about Network variables
	print( "Current gamestate: " + string( GetGameState() ) )
	print( "npc class: " + npc.GetClassName() )
}

bool function CC_StartNPCGunshipDogfight( entity player, array<string> args )
{
	thread NPCGunshipSpawnThink( TEAM_IMC )
	thread NPCGunshipSpawnThink( TEAM_MILITIA )
	return true
}

void function NPCGunshipSpawnThink( int team )
{
	while ( true )
	{
		WaitFrame()

		int gunshipCount = GetNPCArrayEx( "npc_gunship", team, -1, <0,0,0>, -1 ).len()

		int gunshipsToSpawn = 6 - gunshipCount
		if ( gunshipsToSpawn > 0 )
		{
			for ( int i = 0; i < gunshipsToSpawn; i++ )
			{
				if ( i > 0 )
					wait 2.0 // delay before next spawn
				
				array<entity> points = GetDropshipSpawnPoints( team )
				entity node = points[ RandomInt( points.len() ) ]
				thread ExtraSpawner_SpawnGunShip( node.GetOrigin(), node.GetAngles(), team )
			}

			wait 8.0 // wait after each spawn wave
		}
	}
}

array<entity> function GetDropshipSpawnPoints( int team )
{
	array<entity> dropPodNodes = GetEntArrayByClass_Expensive( "info_spawnpoint_droppod_start" )
	
	array<entity> teamPodNodes
	// Sort per team
	foreach ( node in dropPodNodes )
	{
		if ( node.GetTeam() == team )
			teamPodNodes.append( node )
	}

	return GetValidIntroDropShipSpawn( teamPodNodes )
}

///////////////////////////////
///// CLIENT COMMANDS END /////
///////////////////////////////



/////////////////
///// DEBUG /////
/////////////////

// not work. oneHanded animation is done in .mdl not just code
void function TTF1_WeaponUsage( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	
	while( true )
	{
		WaitFrame()
		if( player.IsWallHanging() )
			continue
		if( player.IsWallRunning() )
			player.SetOneHandedWeaponUsageOff()
	}
}

/* 
	index
	studio "gib_lump_LOD0.smd"
	studio "gib_small_02_LOD0.smd"
	studio "gib_brain_LOD0.smd"
	studio "gib_muscle_LOD0.smd"
	studio "gib_small_01_LOD0.smd"
*/
entity function CreateHumanGib( vector origin, vector angles, float scale = 1.0, int styleIndex = -1, float dissolveDelay = -1.0 )
{
	entity prop_physics = CreateEntity( "prop_physics" )
	prop_physics.SetValueForModelKey( $"models/gibs/human_gibs.mdl" )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" ) // required to make finding bodygroup work
	prop_physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
	prop_physics.kv.fadedist = 2000
	prop_physics.kv.renderamt = 255
	prop_physics.kv.rendercolor = "255 255 255"
	prop_physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS

	// funny things
	int bodyGroupIndex = prop_physics.FindBodyGroup( "gibs" )
	int maxBodyGroup = prop_physics.GetBodyGroupModelCount( bodyGroupIndex )
	int bodygroupValue
	if ( styleIndex == -1 ) // not setting...
		bodygroupValue = RandomInt( maxBodyGroup ) // get a random one
	else
		bodygroupValue = styleIndex
	prop_physics.SetBodygroup( bodyGroupIndex, bodygroupValue )

	prop_physics.kv.modelscale = scale

	prop_physics.SetOrigin( origin )
	prop_physics.SetAngles( angles )
	DispatchSpawn( prop_physics )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" )
	if ( dissolveDelay > 0 )
		thread DelayedPinkmistGib( prop_physics, dissolveDelay )

	return prop_physics
}

void function DelayedPinkmistGib( entity gib, float dissolveDelay = 1.0 )
{
	gib.EndSignal( "OnDestroy" )

	wait dissolveDelay
	gib.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

void function SpawnHoloPulseAtPosition( vector origin, float radius, float lifeTime, float pulseSpeed )
{
	entity fxHandle = PlayFX( $"P_ar_holopulse_CP", origin, <0,0,0> )
	vector controlPoint = <lifeTime, pulseSpeed, 0.0> // controlPoint1: lifetime, controlPoint2: speed
	EffectSetControlPointVector( fxHandle, 1, controlPoint )
}

entity function CreatePeteMri( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "mri" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	//thread RGB_Highlight( prop )

	return prop
}

entity function CreateWeaponDrop( vector origin, vector angles, string weaponName, array<string> mods = [] )
{
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )
	weapon.SetMods( mods )

	weapon.SetUsable()
	weapon.SetUsableByGroup( "pilot" )
	weapon.kv.solid = SOLID_VPHYSICS
	//weapon.SetUsePrompts( "按住 %use% 以獲取武器", "按下 %use% 獲取武器" )

	return weapon
}

// TESTING! decoy in ttf2 is hardcoded and almost unchangable, guess apex make decoys move depend on their velocity( like, you can punch decoy and make them walk again )
void function CreateMirageDecoyForPlayer( entity player )
{
	entity decoy = player.CreatePlayerDecoy( 1.0 )
	//decoy.SetCloakDuration( 0, 0, 0 )
	decoy.SetMaxHealth( 50 )
	decoy.SetHealth( 50 )
	decoy.EnableAttackableByAI( 50, 0, AI_AP_FLAG_NONE )
	SetObjectCanBeMeleed( decoy, true )
	decoy.SetTimeout( 9999 )
	SetupDecoy_Common( player, decoy )
	DispatchSpawn( decoy )

	thread MirageDecoyThink( player, decoy )
}

void function MirageDecoyThink( entity player, entity decoy )
{
	player.EndSignal( "OnDestroy" )
	decoy.EndSignal( "OnDestroy" )

	entity decoyMover = CreateExpensiveScriptMover( player.GetOrigin(), player.GetAngles() )
	//decoy.SetParent( decoyMover, "REF" )

	//const float blendTime = 0.2
	//mover.MoveTo( end, 0.1, blendTime, 0 )
	//mover.RotateTo( angles, 0.2 )

	vector lastFramePos
	vector lastFrameAng

	while ( true )
	{
		//print( decoy.GetParent() )
		//print( decoyMover.GetOrigin() )
		//decoy.SetVelocity( < 0, 0, 0 > )
		decoy.SetOrigin( decoyMover.GetOrigin() )
		//decoy.SequenceTransitionFromEntity( player )
		//decoy.SetPoseParametersSameAs( player )
		//decoy.SetVelocity( player.GetVelocity() )
		WaitFrame()
	}
}



/////////////////////
///// CALLBACKS /////
/////////////////////

void function OnPlayerRespawned( entity player )
{
	thread PlayerAttackCounter( player )
}

void function PlayerAttackCounter( entity player )
{
	string uid = player.GetUID()
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ( uid )
		{
			print( file.playerAttackCountTable[ uid ] )
		}
	)

	while( true )
	{
		player.WaitSignal( "OnPrimaryAttack" )
		file.playerAttackCountTable[ uid ] += 1
	}
}

void function OnPlayerGetsNewPilotLoadout( entity player, PilotLoadoutDef p )
{
	foreach( entity weapon in player.GetMainWeapons() )
		player.TakeWeaponNow( weapon.GetWeaponClassName() )
	player.TakeWeaponNow( player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName() )
	player.TakeWeaponNow( player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName() )
	player.GiveWeapon( "mp_weapon_softball", ["northstar_softball", "grenadier_low_damage"] ) //["northstar_softball", "extended_ammo", "pas_fast_reload", "reload_repeat"]
	player.GiveWeapon( "mp_weapon_semipistol", ["gibber_pistol", "silencer", "pas_fast_reload", "extended_ammo"] )
	player.GiveWeapon( "mp_weapon_rocket_launcher", ["guided_missile", "at_unlimited_ammo"] )
	player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_SPECIAL )
	player.GiveOffhandWeapon( "mp_weapon_grenade_electric_smoke", OFFHAND_ORDNANCE, ["creeping_bombardment"] )
}

entity function GetPlayerAntiTitanWeapon( entity player )
{
	entity tempweapon
	foreach( entity weapon in player.GetMainWeapons() )
	{
		if( weapon.GetWeaponClassName() == "mp_weapon_defender" ||
			weapon.GetWeaponClassName() == "mp_weapon_mgl" ||
			weapon.GetWeaponClassName() == "mp_weapon_rocket_launcher" ||
			weapon.GetWeaponClassName() == "mp_weapon_arc_launcher"
		)
			tempweapon = weapon
	}
	return tempweapon
}

void function OnClientConnected( entity player )
{
	//AddPlayerHeldButtonEventCallback( player, IN_USE, CallbackFuncCornerUs, 0.3 )
	//AddPlayerHeldButtonEventCallback( player, IN_USE_AND_RELOAD, CallbackFuncCornerUs, 0.7 )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, ShowEntityStats )
	//AddButtonPressedPlayerInputCallback( player, IN_DUCK, ShowEntityStats )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, TEMP_PlayAnimGestureFromScript )
	//AddButtonPressedPlayerInputCallback( player, IN_USE, DebugParticle )
	file.playerAttackCountTable[ player.GetUID() ] <- 0
}

void function CallbackFuncCornerUs( entity player )
{
	EmitSoundOnEntity( player, "diag_sp_intro_WD104_24_01_mcor_grunt1" )
}

void function ShowEntityStats( entity player )
{
	TraceResults traceResult = TraceLine( player.EyePosition(), player.EyePosition() + player.GetViewVector() * 1000, player, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
	if( !IsValid( traceResult.hitEnt ) )
	{
		Chat_ServerPrivateMessage( player, "hitEnd Invalid", false )
		return
	}
	Chat_ServerPrivateMessage( player, "hitEnt is " + traceResult.hitEnt.GetClassName(), false )
	asset modelName = traceResult.hitEnt.GetModelName()
	string tempString = string( modelName )
    string modelString = tempString.slice( 2, tempString.len() - 1 )
	if( modelName != $"" )
		Chat_ServerPrivateMessage( player, "hitEnt's modelname is " + modelString, false )
}

entity function CreateEnvBeam( entity owner, entity startEnt, entity endEnt )
{
	entity env_laser = CreateEntity( "env_laser" )
	env_laser.kv.LaserTarget = endEnt.GetTargetName()
	env_laser.kv.rendercolor = "150 100 15"
	env_laser.kv.rendercolorFriendly = "15 100 150"
	env_laser.kv.renderamt = 255
	env_laser.kv.width = 2
	env_laser.SetValueForTextureKey( $"sprites/laserbeam.spr" )
	env_laser.kv.TextureScroll = 35
	env_laser.kv.damage = "0"
	env_laser.kv.dissolvetype = -1//-1 to 2 - none, energy, heavy elec, light elec
	env_laser.kv.spawnflags = 1// 32 end sparks
	env_laser.SetOrigin( startEnt.GetOrigin() )
	env_laser.SetAngles( startEnt.GetAngles() )
	env_laser.SetParent( startEnt )
	env_laser.s.parents <- [startEnt, endEnt]

	SetTeam( env_laser, owner.GetTeam() )

	DispatchSpawn( env_laser )

	return env_laser
}

void function SpawnWeaponEntity_CountLifeTime( entity player, string weaponName )
{
	vector origin = GetPlayerCrosshairOrigin( player ) + < 0,0,10 >
	vector angles = Vector( 0, 0, 0 )
	entity weapon = CreateWeaponEntityByNameWithPhysics( weaponName, origin, angles )
	float startTime = Time()
	weapon.WaitSignal( "OnDestroy" )
	float toalTime = Time() - startTime
	print( "This weapon lasted: " + string( toalTime ) )
}

void function DebugParticle( entity player )
{
    vector origin = GetPlayerCrosshairOrigin( player )

    array<entity> fx = []
	array<entity> cp = []

    entity cpRadius = CreateEntity( "info_placement_helper" )
	SetTargetName( cpRadius, UniqueString( "cloakBeacon_cpRadius" ) )
	cpRadius.SetOrigin( Vector(500,0,0) )
	DispatchSpawn( cpRadius )
	cp.append( cpRadius )
	
	// friendly fx
	entity cpColorF = CreateEntity( "info_placement_helper" )
	SetTargetName( cpColorF, UniqueString( "cloakBeacon_cpColorF" ) )
	cpColorF.SetOrigin( ENEMY_COLOR_FX )
	DispatchSpawn( cpColorF )
	cp.append( cpColorF )

    /*
	entity fxIdF1 = PlayFXWithControlPoint( DEPLOYABLE_CLOAKFIELD_FX_ALL, tower.GetOrigin() + Vector(0,0,3), cpColorF )
	SetTeam( fxIdF1, tower.GetTeam() )
	fxIdF1.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	fx.append( fxIdF1 )
	entity fxIdF2 = PlayFXWithControlPoint( DEPLOYABLE_CLOAKFIELD_FX_ALL2, tower.GetOrigin() + Vector(0,0,3), cpColorF )
	SetTeam( fxIdF2, tower.GetTeam() )
	fxIdF2.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	fx.append( fxIdF2 )
    */

	int particleIndex = GetParticleSystemIndex( DEBUGGING_PARTICLE )
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
	StartParticleEffectOnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	entity fxIdF3 = CreateEntity( "info_particle_system" )
	fxIdF3.kv.start_active = 1
	fxIdF3.SetValueForEffectNameKey( DEBUGGING_PARTICLE )
	SetTeam( fxIdF3, player.GetTeam() )
	fxIdF3.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	SetTargetName( fxIdF3, UniqueString() )
	//fxIdF3.kv.cpoint1 = cpColorF.GetTargetName()
	//fxIdF3.kv.cpoint5 = cpRadius.GetTargetName()
	fxIdF3.SetOrigin( origin + Vector(0,0,10) )
	fx.append( fxIdF3 )

    DispatchSpawn( fxIdF3 )
}

void function PlayAnimGestureFromScript( entity ent, string activity, float fadein, float fadeout, float blendTime )
{
	ent.Anim_PlayGesture( activity, fadein, fadeout, blendTime )
}

void function TEMP_PlayAnimGestureFromScript( entity ent )
{
	print( "Try to Anim_PlayGesture()" )
	ent.SetPredictionEnabled( false )
	ent.Anim_PlayGesture( "ACT_MP_MELEE_KNIFE_FIRST", 2.0, 0.0, -1.0 )
}

void function CreateViewEntityForPlayer( entity player )
{
	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-soli
	
	vector eyeAngle = player.EyeAngles()
	vector evePos = player.EyePosition()
	vector offset = AnglesToForward( < 0, eyeAngle.y, 0 > ) * -150 + < 0,0,50 >
	vector angles = < 0, eyeAngle.y, 0 >
	viewControl.SetParent( player, "ORIGIN" )
	//viewControl.SetOrigin( evePos + offset )
	viewControl.SetOrigin( < -150, 0, 100 > )
	//viewControl.SetAngles( angles )
	DispatchSpawn( viewControl )

	player.SetViewEntity( viewControl, true )
	entity fpProxy = player.GetFirstPersonProxy()
	if ( IsValid( fpProxy )  )
		fpProxy.HideFirstPersonProxy()

	OnThreadEnd(
		function() : ( player, viewControl )
		{
			if( IsValid( player ) )
			{
				entity fpProxy = player.GetFirstPersonProxy()
				if( IsValid( fpProxy ) )
	            	fpProxy.ShowFirstPersonProxy()
				player.ClearViewEntity()
				RemoveCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD )
			}
			if( IsValid( viewControl ) )
				viewControl.Destroy()
		}
	)

	//wait 1
	//player.Die() // die here
	player.WaitSignal( "OnRespawned" )
}

void function StartTitanShieldHealthRegen( entity titan )
{
    entity soul = null // 初值赋为空，如果传入的泰坦是玩家且通过下方的检查没能获得soul实体，不执行回盾
    if ( titan.IsPlayer() ) // 如果传入的是玩家
    {
        if ( !titan.IsTitan() ) // 但这个玩家并不是泰坦
        {
            titan = titan.GetPetTitan() // 尝试获取该玩家的自动泰坦
            if ( IsValid( titan ) ) // 如果自动泰坦可用
                soul = titan.GetTitanSoul() // 获取该自动泰坦的soul实体

        }
        else // 玩家已经是泰坦
            soul = titan.GetTitanSoul()
    }
    else if ( titan.IsNPC() && titan.IsTitan() ) // 若为npc泰坦
        soul = titan.GetTitanSoul()

    if ( IsValid( soul ) ) // 防崩溃，仅在soul不为null的时候尝试再次启用回盾
        thread TitanShieldRegenThink( soul )
}

// can't get this thing work!!
void function BecomeFakeBarker( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "AltPilotModelReplace" )
	
	entity barkerProp = CreatePropDynamic( $"models/humans/heroes/mlt_hero_barker.mdl" )
	barkerProp.SetParent( player, "ref" )
	
	//entity decoy = CreateElitePilot( player.GetTeam(), player.GetOrigin(), player.GetAngles() )
	//decoy.SetModel( player.GetModelName() )
	//DispatchSpawn( decoy )
	//decoy.SetModel( player.GetModelName() )

	//decoy.SetTitle( player.GetPlayerName() )
	//decoy.SetScriptName( player.GetPlayerName() + "_decoy" )
	
	while( true )
	{
		//player.StartRecordingAnimation( player.GetOrigin(), player.GetAngles() )
		player.StartRecordingAnimation( < 0,0,0 >, < 0,0,0 > )
		
		wait 1
		
		var rec = player.StopRecordingAnimation()

		barkerProp.PlayRecordedAnimation( rec, <0,0,0>, <0,0,0>, DEFAULT_SCRIPTED_ANIMATION_BLEND_TIME, player )
	}
}

void function ScoreBoardModifier( int scoreCheckType, float displayScale = 0.1 )
{
	thread ScoreBoardModifier_Threaded( scoreCheckType, displayScale )
}

void function ScoreBoardModifier_Threaded( int scoreCheckType, float displayScale )
{
	table<entity, float> playerLastScore
	table<entity, float> playerSavedScore
	while ( true )
	{
		foreach ( entity player in GetPlayerArray() )
		{
			if ( !( player in playerLastScore ) )
				playerLastScore[ player ] <- 0.0
			if ( !( player in playerSavedScore ) )
				playerSavedScore[ player ] <- 0.0

			float currentScore = float( player.GetPlayerGameStat( scoreCheckType ) )
			float lastScore = playerLastScore[ player ]

			if ( currentScore != lastScore )
			{
				float scoreDiff = currentScore - lastScore
				playerSavedScore[ player ] += scoreDiff

				// update score board
				float scoreToDisplay = playerSavedScore[ player ] * displayScale
				float scoreBoardDiff = scoreToDisplay - currentScore

				player.SetPlayerGameStat( scoreCheckType, scoreToDisplay )

				// debug
				print( "-----------------SCORE UPDATED!-----------------" )
				print( "playerSavedScore[ player ]: " + string( playerSavedScore[ player ] ) )
				print( "lastScore: " + string( lastScore ) )
				print( "currentScore: " +string( currentScore ) )
				print( "scoreToDisplay: " + string( scoreToDisplay ) )
				print( "scoreBoardDiff: " + string( scoreBoardDiff ) )
				print( "------------------------------------------------" )
			}

			playerLastScore[ player ] = float( player.GetPlayerGameStat( scoreCheckType ) )
		}

		WaitFrame()
	}
}