untyped

global function MeleeSyncedTitanShared_Init

// modified here, we add more execution settings
#if SERVER
global function MeleeSyncedTitan_AddExecutionRefCallback
global function MeleeSyncedTitan_ExecutionRefHasCallback
global function MeleeSyncedTitan_RunCallbacksForRef // shared with _melee_synced_titan.gnut

global function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback
global function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback
global function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef // shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout // called by default loadout replace callbacks

global function MeleeSyncedTitan_SetExecutionRefRequiredWeapons
global function MeleeSyncedTitan_TitanHasRequiredWeaponsForRef

// register some settings here
global function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker
global function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim // note that if a titan's victim valid execution array is empty, it means they can be executed by all executions

global function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef

// shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_GetBestExecutionRefForTitanVsTitan
global function MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan

// mostly for ability or core weapon mods. remove them when loadout replacing
// currently used for titan_replace.gnut
global function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace

struct ExecutionSavedLoadout
{
	// can't just store a primary weapon entity, as TakeWeapon_NoDelete() will leave a weapon model in titan's hand
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo

	entity replacedPrimaryEnt

	table<int, entity> savedOffhandWeaponEnts
}

// npc specific loadout saving
// TakeOffhandWeapon_NoDelete() can't be used on npcs
// they'll still consider these weapon in their inventory
// causes crash of having multiple weapons at same usage
struct ExecutionSavedLoadout_NPC
{
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo
	entity replacedPrimaryEnt = null

	string special = "" // defensive
	array<string> specialMods = []

	string antiRodeo = "" // utility
	array<string> antiRodeoMods = []

	string ordnance = "" // ordnance
	array<string> ordnanceMods = []

	string melee = "" // melee
	array<string> meleeMods = []

	string equipment = "" // core
	array<string> equipmentMods = []
}

// modified settings struct
struct
{
	table< string, array<void functionref( entity, entity )> > titanExecutionRefCallbacks
	table< string, void functionref( entity ) > titanExecutionRefLoadoutReplaceCallback
	table< string, array<string> > titanExecutionRefRequiredWeapons

	table<entity, ExecutionSavedLoadout> titanExecutionSavedLoadout
	table<entity, ExecutionSavedLoadout_NPC> titanExecutionSavedLoadout_NPC

	array<string> modsToRemoveOnLoadoutReplace

	table< string, array<string> > chassisValidExecutionRefs_Attacker
	table< string, array<string> > chassisValidExecutionRefs_Victim
	table< string, array<string> > titanCharacterSpecificExecutionRefs
} file
#endif

function MeleeSyncedTitanShared_Init()
{
	SyncedMeleeChooser chooser = CreateSyncedMeleeChooser( "titan", "titan" )

	chooser.displayMeleePrompt = false

	#if SERVER
		MeleeSyncedTitan_Init()

		// modified here, we add more execution settings
		RegisterSignal( "ReplaceExecutionAttackerLoadout" )
		MeleeSyncedTitan_InitSpecificExecutionRefSettings()
		MeleeSyncedTitan_InitDefaultRefCallbacks()
	#endif

	SyncedMelee action
	action.direction = Vector( 1, 0, 0 )
	action.distance = TITAN_EXECUTION_RANGE
	action.isAttackerRef = false

	AddSyncedMelee( chooser, action )
}

// modified here, we add more execution settings
#if SERVER
void function MeleeSyncedTitan_InitSpecificExecutionRefSettings()
{
	// atlas chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_ion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_ion_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_tone" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_tone_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_vanguard" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_vanguard_kit" )
	// random 
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_0" ) // ion
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_4" ) // tone
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_6" ) // monarch

	// stryder chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_ronin" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_ronin_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_northstar" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_northstar_prime" )
	// random 
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_random_2" ) // northstar
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_random_3" ) // ronin
	
	// ogre chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_scorch" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_scorch_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_legion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_legion_prime" )
	// random
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_random_1" ) // scorch
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_random_5" ) // legion

	// BT executions
	//MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt" ) // shouldn't be handled here. "execution_bt" is already a random execution handled by TitanVsTitan_3p()
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_flip" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_pilotrip" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_kickshoot" )
	// valid victim executions
	// for buddy chassis, they shouldn't be executed by tf2 melee at all
	// just add an empty ref, will lead to classic executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "" )
	// anyways, they do have animations for being tf2 execution vicitim
	// but these animations are used for SP auto titans so all animations don't have AE_MELEE_KILLED, leading to bad duration
	// I've inited stuffs in Init3pExecutions(), could enable following executions if you want
	/*
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_ion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_tone" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_ronin" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_legion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_scorch" )
	*/

	// ion character executions
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion_prime" )

	// tone character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone_prime" )

	// monarch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard_kit" )

	// ronin character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin_prime" )

	// northstar character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar_prime" )

	// scorch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch_prime" )

	// legion character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion_prime" )

	// BT character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_flip" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_pilotrip" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_kickshoot" )
}

// default execution callbacks
void function MeleeSyncedTitan_InitDefaultRefCallbacks()
{
	/* // note:
		execution_northstar_prime, 
		execution_scorch, 
		execution_scorch_prime, 
		execution_vanguard, 
		execution_vanguard_kit, 
		execution_bt_pilotrip, 
		execution_bt_flip, 

		these executions don't require weapons
	*/

	// ION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion", Execution_Ion )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_ion", 							// execution ref
		// required weapons array
		[
			"mp_titanweapon_particle_accelerator", 
			"mp_titanweapon_laser_lite",
		] 
	)
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion_prime", Execution_Ion_Prime )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_ion_prime", 				// execution ref
		// required weapons array
		[
			"mp_titanweapon_laser_lite", 
			"mp_titancore_laser_cannon",	// we replace it with mp_titancore_siege_mode if a npc triggering loadout replace
		] 
	)

	// TONE
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone", Execution_Tone )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_tone", 					// execution ref
		// required weapons array
		[
			"mp_titanweapon_sticky_40mm", 
		] 
	)
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone_prime", Execution_Tone_Prime )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_tone_prime", 			// execution ref
		// required weapons array
		[
			"mp_titanweapon_sticky_40mm", 
		] 
	)

	// RONIN
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin", Execution_Ronin )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_ronin", 				// execution ref
		// required weapons array
		[
			"melee_titan_sword", 
		] 
	)
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin_prime", Execution_Ronin_Prime )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_ronin_prime", 		// execution ref
		// required weapons array
		[
			"melee_titan_sword", 
		] 
	)
	// core abilty weapon mod
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "super_charged" )
	
	// NORTHSTAR
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_northstar", Execution_Northstar )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_northstar", 			// execution ref
		// required weapons array
		[
			"mp_titanweapon_sniper", 
		] 
	)

	// LEGION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion", Execution_Legion )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_legion", 					// execution ref
		// required weapons array
		[
			"mp_titanweapon_predator_cannon",
			"mp_titanability_gun_shield",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titanability_ammo_swap",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titanability_power_shot",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titancore_siege_mode",			// won't use during execution, but is required for overwriting other smart ammo weapons
		] 
	)
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion_prime", Execution_Legion_Prime )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_legion_prime", 				// execution ref
		// required weapons array
		[
			"mp_titanweapon_predator_cannon",
			"mp_titanability_gun_shield",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titanability_ammo_swap",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titanability_power_shot",		// won't use during execution, but is required for overwriting other smart ammo weapons
			"mp_titancore_siege_mode",			// won't use during execution, but is required for overwriting other smart ammo weapons
		] 
	)
	// core abilty weapon mod
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "Smart_Core" )

	// SCORCH
	//MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_scorch", Execution_Scorch ) // removed because the heat shield effect is just particle, not weapon
	
	// BT
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_bt_kickshoot", Execution_BT_KickShoot )
	MeleeSyncedTitan_SetExecutionRefRequiredWeapons( 
		"execution_bt_kickshoot", 			// execution ref
		// required weapons array
		[
			"mp_titanweapon_xo16_shorty",	// any valid active weapon is enough, this isn't necessary
		] 
	)

	
	// modded titans
	// ARCHON
	#if EXTRA_SPAWNER_HAS_ARCHON
		// kit weapon mod
		MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "burn_mod_fd_terminator_active" )
		MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "burn_mod_shock_shield" )
		MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "burn_mod_charge_ball" )
	#endif

	// BRUTE4
	#if EXTRA_SPAWNER_HAS_BRUTE4
		// abilty weapon mod
		MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "cluster_payload" )
	#endif
}

void function Execution_Ion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_particle_accelerator", [],
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		"", []		// "mp_titancore_laser_cannon", won't use during execution
	)
}

void function Execution_Ion_Prime( entity attacker )
{
	string coreWeapon = "mp_titancore_laser_cannon"
	if ( attacker.IsNPC() ) // saved for npc execution condition: never fire a lasercannon
		coreWeapon = "mp_titancore_siege_mode" // change to placeholder core weapon if a npc ever used this execution

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_particle_accelerator", won't use during execution
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		coreWeapon, []
	)
}

void function Execution_Tone( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// "mp_titanweapon_tracker_rockets", won't use during execution
		"", [],		// "melee_titan_punch_tobe", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

void function Execution_Tone_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// "mp_titanweapon_tracker_rockets", execution actually plays particle effect but not firing weapon
		"", [],		// "melee_titan_punch_tone", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

void function Execution_Ronin( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", won't use during execution
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

void function Execution_Ronin_Prime( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", execution actually plays particle effect but not firing weapon
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

void function Execution_Northstar( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sniper", [],
		"", [],		// "mp_titanability_tether_trap", won't use during execution
		"", [],		// "mp_titanability_hover", won't use during execution
		"", [],		// "mp_titanweapon_dumbfire_rockets", won't use during execution
		"", [],		// "melee_titan_punch_northstar", won't use during execution
		"", []		// "mp_titancore_flight_core", won't use during execution
	)
}

void function Execution_Legion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

void function Execution_Legion_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

// removed because the heat shield effect is just particle, not weapon
/*
void function Execution_Scorch( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_meteor", won't use during execution
		"mp_titanweapon_heat_shield", [], // not sure if this weapon gets used
		"", [],		// "mp_titanability_slow_trap", won't use during execution
		"", [],		// "mp_titanweapon_flame_wall", won't use during execution
		"", [],		// "melee_titan_punch_scorch", won't use during execution
		"", []		// "mp_titancore_flame_wave", won't use during execution
	)
}
*/

void function Execution_BT_KickShoot( entity attacker )
{
	string xo16 = "mp_titanweapon_xo16_shorty"
	entity xo16Weapon
	array<entity> weapons = attacker.GetMainWeapons()
	if ( weapons.len() > 0 )
	{
		// fakebt version, it has multiple main weapons so do more checks
		// this version allowing bt to use any active weapon, requires refilling ammo
		attacker.ClearOffhand() // so they will switch to last main weapon
		entity activeWeapon = attacker.GetActiveWeapon()
		if ( IsValid( activeWeapon ) && !activeWeapon.IsWeaponOffhand() ) // try to use active main weapon
		{
			// have to try-catch this since not all main weapons can use weapon clip
			try { activeWeapon.SetWeaponPrimaryClipCount( activeWeapon.GetWeaponPrimaryClipCountMax() ) }
			catch( ex ){}
		}
		else // can't find active weapon, try to find xo16
		{
			foreach ( entity weapon in weapons )
			{
				if ( weapon.GetWeaponClassName() == xo16 )
				{
					xo16Weapon = weapon
					break
				}
			}
			if ( IsValid( xo16Weapon ) )
			{
				attacker.SetActiveWeaponByName( xo16 )
				xo16Weapon.SetWeaponPrimaryClipCount( xo16Weapon.GetWeaponPrimaryClipCountMax() ) // don't want to make bt reload while executing
			}

			if ( !IsValid( xo16Weapon ) ) // can't find xo16
				MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( attacker, xo16 )
		}
	}
}

// utility
// best execution: if attacker execution invalid, pick any execution that is valid for current chassis
// shared with _melee_synced_titan.gnut, function DefaultCallback_OnGetTitan3pExecutionRef()
string function MeleeSyncedTitan_GetBestExecutionRefForTitanVsTitan( entity attacker, entity target, string forcedRef = "" )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return "" // return empty means we needs to go into classic execution( which all titans have valid animation for that )

	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return ""

	// search for best execution ref
	string executionRef = attackerSoul.soul.titanLoadout.titanExecution // default value
	if ( forcedRef != "" )
		executionRef = forcedRef
	
	//print( "executionRef before checking best one: " + executionRef )
	// chassis check
	array<string> validExecutions = GetValidExecutionsForAttackerVsTarget( attacker, target )
	if ( validExecutions.contains( executionRef ) )
	{
		//print( "Titan already have valid execution: " + executionRef )
		return executionRef // we've found our execution to use!
	}

	// bad chassis execution happening... we pick a random one from our character!
	//print( "bad chassis execution happening" )
	string attackerCharacter = GetTitanCharacterName( attacker )
	array<string> characterExecutions = GetCharacterSpecificExecutions( attackerCharacter )
	string targetChassis = GetSoulTitanSubClass( targetSoul )
	array<string> victimValidExecutions = GetVictimChassisValidExecutions( targetChassis )
	if ( characterExecutions.len() > 0 )
	{
		string lastRefFound = ""
		// normal ref, prefer finding player's equipping one
		foreach ( string otherRef in characterExecutions )
		{
			//print( "finding from ref: " + otherRef )

			// needs to be in victim's valid execution list
			if ( !victimValidExecutions.contains( otherRef ) )
				continue

			// we should at least find one from following case, otherwise we failsafe
			if ( TitanExecutionRefIsPrime( otherRef ) )
			{
				// if finding ref is prime, our ref needs also be prime
				if ( TitanExecutionRefIsPrime( executionRef ) )
				{
					//print( "both our ref and finding ref is PRIME! returning a valid prime execution" )
					return otherRef
				}
			}
			else if ( MeleeSyncedTitan_RefHasLinkedExecutions( otherRef ) ) // shared function from _melee_synced_titan.gnut
			{
				// if finding ref is random, our ref needs also be random
				if ( MeleeSyncedTitan_RefHasLinkedExecutions( executionRef ) )
				{
					//print( "both our ref and finding ref is RANDOM! returning a valid random execution" )
					array<string> linkedRefs = MeleeSyncedTitan_GetLinkedExecutionsFromRef( otherRef )  // shared function from _melee_synced_titan.gnut
					return linkedRefs[ RandomInt( linkedRefs.len() ) ]
				}
			}
			else
				lastRefFound = otherRef // if we still can't find one, use this ref as a failsafe
		}
		// we can't find anything from iterrate... use last found one
		if ( lastRefFound != "" )
			return lastRefFound
	}

	// code hits here!!! this means we can't get any valid execution, just use random one
	return MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan( attacker, target )
}

bool function TitanExecutionRefIsPrime( string ref )
{
	// _kit suffix is hardcoded for monarch, currently removed
	bool isPrimeRef = ( ref.find( "_prime" ) != null ) //|| ( ref.find( "_kit" ) != null ) 
	// debug
	//print( "TitanExecutionRefIsPrime( " + ref + " ) : " + string( isPrimeRef ) )
	return isPrimeRef
}

// random execution ref: pick anything that is valid for current chassis
// shared with _melee_synced_titan.gnut, function DefaultCallback_OnGetTitan3pExecutionRef()
string function MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan( entity attacker, entity target )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return "" // return empty means we needs to go into classic execution( which all titans have valid animation for that )

	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return ""

	array<string> validExecutions = GetValidExecutionsForAttackerVsTarget( attacker, target )
	if ( validExecutions.len() == 0 ) // can't find any valid execution!
		return "" // let's just use classic execution... at least it never crushes

	string randomExecution = validExecutions[ RandomInt( validExecutions.len() ) ]
	// insure we're not returning a random execution ref( their data should be empty, needs to get from linked execution )
	if ( MeleeSyncedTitan_RefHasLinkedExecutions( randomExecution ) ) // shared function from _melee_synced_titan.gnut
	{
		array<string> linkedRefs = MeleeSyncedTitan_GetLinkedExecutionsFromRef( randomExecution )  // shared function from _melee_synced_titan.gnut
		randomExecution = linkedRefs[ RandomInt( linkedRefs.len() ) ]
	}

	return randomExecution
}

array<string> function GetValidExecutionsForAttackerVsTarget( entity attacker, entity target )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return []
	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return []

	string attackerChassis = GetSoulTitanSubClass( attackerSoul )
	string targetChassis = GetSoulTitanSubClass( targetSoul )
	array<string> validExecutions
	array<string> attackerValidExecutions = GetAttackerChassisValidExecutions( attackerChassis )
	array<string> victimValidExecutions = GetVictimChassisValidExecutions( targetChassis )
	// find from all valid executions
	foreach ( string ref in attackerValidExecutions )
	{
		if ( victimValidExecutions.contains( ref ) )
		{
			// debug
			//print( "Found valid execution: " + ref )
			validExecutions.append( ref )
		}
	}

	return validExecutions
} 

array<string> function GetAttackerChassisValidExecutions( string chassis )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Attacker ) )
		return []
	return file.chassisValidExecutionRefs_Attacker[ chassis ]
}

// note that if a titan's victim valid execution array is empty
// it means they can be executed by all executions
array<string> function GetVictimChassisValidExecutions( string chassis )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Victim ) )
		return MeleeSyncedTitan_GetAllValidExecutionRefs() // shared from _melee_synced_titan.gnut
	return file.chassisValidExecutionRefs_Victim[ chassis ]
}

array<string> function GetCharacterSpecificExecutions( string characterName )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		return []
	return file.titanCharacterSpecificExecutionRefs[ characterName ]
}

// called by default loadout replace callbacks
void function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	thread ReplaceExecutionAttackerLoadout_Threaded( guy, primary, primaryMods, special, specialMods, antiRodeo, antiRodeoMods, ordnance, ordnanceMods, melee, meleeMods, equipment, equipmentMods )
}

void function ReplaceExecutionAttackerLoadout_Threaded( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	guy.Signal( "ReplaceExecutionAttackerLoadout" )
	guy.EndSignal( "ReplaceExecutionAttackerLoadout" )

	// player loadout saving
	if ( guy.IsPlayer() )
	{
		ExecutionSavedLoadout savedLoadout
		file.titanExecutionSavedLoadout[ guy ] <- savedLoadout

		bool primarySaved = false
		table<int, bool> offhandsSaved
		// init offhand weapons data
		for ( int i = 0; i < OFFHAND_COUNT; i++ )
		{
			savedLoadout.savedOffhandWeaponEnts[ i ] <- null
			offhandsSaved[ i ] <- false
		}

		// first we take all weapons
		// primary weapon
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		// save skin&camo for later we apply to temp weapon
		int skinIndex = -1
		int camoIndex = -1
		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_SPECIAL ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_SPECIAL )
			offhandsSaved[ OFFHAND_SPECIAL ] = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ANTIRODEO ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ANTIRODEO )
			offhandsSaved[ OFFHAND_ANTIRODEO ] = true // mark as special saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ORDNANCE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ORDNANCE )
			offhandsSaved[ OFFHAND_ORDNANCE ] = true // mark as special saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_MELEE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_MELEE )
			offhandsSaved[ OFFHAND_MELEE ] = true // mark as special saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_EQUIPMENT ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_EQUIPMENT )
			offhandsSaved[ OFFHAND_EQUIPMENT ] = true // mark as special saved
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		if ( primary != "" && primarySaved ) // insure we saved primary
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			newWeapon.SetSkin( savedLoadout.primarySkin )
			newWeapon.SetCamo( savedLoadout.primaryCamo )

			guy.SetActiveWeaponByName( primary )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && offhandsSaved[ OFFHAND_SPECIAL ] ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && offhandsSaved[ OFFHAND_ANTIRODEO ] ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && offhandsSaved[ OFFHAND_ORDNANCE ] ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && offhandsSaved[ OFFHAND_MELEE ] ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && offhandsSaved[ OFFHAND_EQUIPMENT ] ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )
	}

	// npc loadout saving
	if ( guy.IsNPC() )
	{
		ExecutionSavedLoadout_NPC savedLoadout
		file.titanExecutionSavedLoadout_NPC[ guy ] <- savedLoadout

		// primary weapon
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		bool primarySaved = false
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		string specialNameToSave
		array<string> specialModsToSave
		bool specialSaved = false
		if ( IsValid( specialToSave ) )
		{
			specialNameToSave = specialToSave.GetWeaponClassName()
			specialModsToSave = specialToSave.GetMods()
		}

		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.special = specialNameToSave
			savedLoadout.specialMods = specialModsToSave

			guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
			specialSaved = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		string antiRodeoNameToSave
		array<string> antiRodeoModsToSave
		bool antiRodeoSaved = false
		if ( IsValid( antiRodeoToSave ) )
		{
			antiRodeoNameToSave = antiRodeoToSave.GetWeaponClassName()
			antiRodeoModsToSave = antiRodeoToSave.GetMods()
		}

		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.antiRodeo = antiRodeoNameToSave
			savedLoadout.antiRodeoMods = antiRodeoModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
			antiRodeoSaved = true // mark as antiRodeo saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		string ordnanceNameToSave
		array<string> ordnanceModsToSave
		bool ordnanceSaved = false
		if ( IsValid( ordnanceToSave ) )
		{
			ordnanceNameToSave = ordnanceToSave.GetWeaponClassName()
			ordnanceModsToSave = ordnanceToSave.GetMods()
		}

		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.ordnance = ordnanceNameToSave
			savedLoadout.ordnanceMods = ordnanceModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
			ordnanceSaved = true // mark as ordnance saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		string meleeNameToSave
		array<string> meleeModsToSave
		bool meleeSaved = false
		if ( IsValid( meleeToSave ) )
		{
			meleeNameToSave = meleeToSave.GetWeaponClassName()
			meleeModsToSave = meleeToSave.GetMods()
		}

		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.melee = meleeNameToSave
			savedLoadout.meleeMods = meleeModsToSave

			guy.TakeOffhandWeapon( OFFHAND_MELEE )
			meleeSaved = true // mark as melee saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		string equipmentNameToSave
		array<string> equipmentModsToSave
		bool equipmentSaved = false
		if ( IsValid( equipmentToSave ) )
		{
			equipmentNameToSave = equipmentToSave.GetWeaponClassName()
			equipmentModsToSave = equipmentToSave.GetMods()
		}

		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.equipment = equipmentNameToSave
			savedLoadout.equipmentMods = equipmentModsToSave

			guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			equipmentSaved = true // mark as equipment saved
		}

		if ( equipment != "" )
		{
			entity weapon = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
			if ( IsValid( weapon ) )
			{
				savedLoadout.equipment = weapon.GetWeaponClassName()
				savedLoadout.equipmentMods = weapon.GetMods()

				guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			}
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		if ( primary != "" && primarySaved ) // insure we saved primary
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			newWeapon.SetSkin( savedLoadout.primarySkin )
			newWeapon.SetCamo( savedLoadout.primaryCamo )
			guy.SetActiveWeaponByName( primary )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && specialSaved ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && antiRodeoSaved ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && ordnanceSaved ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && meleeSaved ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && equipmentSaved ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )

		// debug prints
		/*
		print( "primarySaved: " + string( primarySaved ) )
		print( "specialSaved: " + string( specialSaved ) )
		print( "antiRodeoSaved: " + string( antiRodeoSaved ) )
		print( "ordnanceSaved: " + string( ordnanceSaved ) )
		print( "meleeSaved: " + string( meleeSaved ) )
		print( "equipmentSaved: " + string( equipmentSaved ) )
		*/
	}

	OnThreadEnd
	(
		function(): ( guy )
		{
			if ( IsValid( guy ) )
			{
				// player loadout restoring
				if ( guy.IsPlayer() )
				{
					ExecutionSavedLoadout savedLoadout = file.titanExecutionSavedLoadout[ guy ]
					// restore weapons
					// primary 
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						RemoveInvalidModsForWeapon( newWeapon ) // remove mods that shouldn't be retained through execution
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
					}
					// offhand weapons
					for ( int i = 0; i < OFFHAND_COUNT; i++ )
					{
						entity previousOffhand = savedLoadout.savedOffhandWeaponEnts[ i ]
						if ( IsValid( previousOffhand ) )
						{
							guy.TakeOffhandWeapon( i )
							guy.GiveExistingOffhandWeapon( previousOffhand, i )
							RemoveInvalidModsForWeapon( previousOffhand ) // remove mods that shouldn't be retained through execution
						}
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout[ guy ]
				}

				// npc loadout restoring
				if ( guy.IsNPC() )
				{
					ExecutionSavedLoadout_NPC savedLoadout = file.titanExecutionSavedLoadout_NPC[ guy ]
					// restore weapons
					// primary 
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
					}
					// defensive
					if ( savedLoadout.special != "" ) // do saved defensive
					{
						guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
						guy.GiveOffhandWeapon( savedLoadout.special, OFFHAND_SPECIAL, savedLoadout.specialMods )
					}
					// utility
					if ( savedLoadout.antiRodeo != "" ) // do saved utility
					{
						guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
						guy.GiveOffhandWeapon( savedLoadout.antiRodeo, OFFHAND_ANTIRODEO, savedLoadout.antiRodeoMods )
					}
					// ordnance
					if ( savedLoadout.ordnance != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
						guy.GiveOffhandWeapon( savedLoadout.ordnance, OFFHAND_ORDNANCE, savedLoadout.ordnanceMods )
					}
					// melee
					if ( savedLoadout.melee != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_MELEE )
						guy.GiveOffhandWeapon( savedLoadout.melee, OFFHAND_MELEE, savedLoadout.meleeMods )
					}
					// core
					if ( savedLoadout.equipment != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
						guy.GiveOffhandWeapon( savedLoadout.equipment, OFFHAND_EQUIPMENT, savedLoadout.equipmentMods )
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout_NPC[ guy ]
				}
			}
		}
	)

	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	// signals from FirstPersonSequence()
	//guy.EndSignal( "NewFirstPersonSequence" ) // this gets called later in execution FirstPersonSequence(), which will stop current thread!
	guy.EndSignal( "ScriptAnimStop" )
	guy.WaitSignal( "SyncedMeleeComplete" ) // attacker's signal
}

// utility!
void function MeleeSyncedTitan_AddExecutionRefCallback( string ref, void functionref( entity, entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefCallbacks ) )
		file.titanExecutionRefCallbacks[ ref ] <- [] // init
	if ( !file.titanExecutionRefCallbacks[ ref ].contains( callbackFunc ) )
		file.titanExecutionRefCallbacks[ ref ].append( callbackFunc )
}

bool function MeleeSyncedTitan_ExecutionRefHasCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefCallbacks )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunCallbacksForRef( string ref, entity attacker, entity target )
{
	if ( !MeleeSyncedTitan_ExecutionRefHasCallback( ref ) )
		return
	//PrintFunc()
	foreach ( void functionref( entity, entity ) callbackFunc in file.titanExecutionRefCallbacks[ ref ] )
		callbackFunc( attacker, target )
}

void function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( string ref, void functionref( entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] <- callbackFunc
	else
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] = callbackFunc
}

void function MeleeSyncedTitan_SetExecutionRefRequiredWeapons( string ref, array<string> requiredWeapons )
{
	if ( !( ref in file.titanExecutionRefRequiredWeapons ) )
		file.titanExecutionRefRequiredWeapons[ ref ] <- requiredWeapons
	else
		file.titanExecutionRefRequiredWeapons[ ref ] = requiredWeapons
}

// utility
bool function MeleeSyncedTitan_TitanHasRequiredWeaponsForRef( entity titan, string ref )
{
	if ( !( ref in file.titanExecutionRefRequiredWeapons ) ) // this ref doesn't require weapons
		return true

	array<string> requiredWeapons = file.titanExecutionRefRequiredWeapons[ ref ]
	foreach ( weapon in requiredWeapons )
	{
		if ( !PlayerHasWeapon( titan, weapon ) ) // function name is weird. it can be used by npcs
			return false // return false if we ever hit a weapon that titan don't have
	}

	// all checks passed
	//print( "titan: " + string( titan ) + " has all required weapons for execution: " + ref )
	return true
}

bool function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefLoadoutReplaceCallback )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef( string ref, entity attacker )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		return
	//PrintFunc()
	file.titanExecutionRefLoadoutReplaceCallback[ ref ]( attacker )
}

void function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( string mod )
{
	if ( !file.modsToRemoveOnLoadoutReplace.contains( mod ) )
		file.modsToRemoveOnLoadoutReplace.append( mod )
}

void function RemoveInvalidModsForWeapon( entity weapon )
{
	array<string> mods = weapon.GetMods()
    array<string> replaceArray
    foreach( string mod in mods )
    {
        if ( file.modsToRemoveOnLoadoutReplace.contains( mod ) ) // skip illegal mod
            continue

        replaceArray.append( mod )
    }

	weapon.SetMods( replaceArray )
}

void function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( string chassis, string executionRef )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Attacker ) )
		file.chassisValidExecutionRefs_Attacker[ chassis ] <- []
	if ( !file.chassisValidExecutionRefs_Attacker[ chassis ].contains( executionRef ) )
		file.chassisValidExecutionRefs_Attacker[ chassis ].append( executionRef )
}

// note that if a titan's victim valid execution array is empty
// it means they can be executed by all executions
void function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( string chassis, string executionRef )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Victim ) )
		file.chassisValidExecutionRefs_Victim[ chassis ] <- []
	if ( !file.chassisValidExecutionRefs_Victim[ chassis ].contains( executionRef ) )
		file.chassisValidExecutionRefs_Victim[ chassis ].append( executionRef )
}

void function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( string characterName, string executionRef )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ] <- []
	if ( !file.titanCharacterSpecificExecutionRefs[ characterName ].contains( executionRef ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ].append( executionRef )
}
#endif