untyped

global function MeleeSyncedTitan_Init

global function MeleeThread_TitanVsTitan // globalize it!

const TITANARMMODEL = $"models/weapons/arms/atlaspov.mdl"
const TEAM_JUMPJET_DBL = $"P_team_jump_jet_DBL"

// modified
global function MeleeSyncedTitan_ExecutionNotInvulnerable
// modified to have more execution options
global function MeleeSyncedTitan_SetSoulDoClassicExecution
global function MeleeSyncedTitan_DisableVanguardKitExecution

global function MeleeSyncedTitan_SetSoulUseExecutionCallback
global function MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution

global function MeleeSyncedTitan_SetSoulCanBeExecuted // modified for checks in AttemptScriptedExecution()
global function MeleeSyncedTitan_SoulCanBeExecuted
//

enum eTitanExecutionType
{
	fistThroughCockpit
	dummy //not used yet
}

struct TitanExcutionData
{
	string attackerAnimation3p
	string attackerAnimation3p_vsAutoTitan
	table<string,string> attackerAnimation3pPilot
	table<string,string> targetAnimation3p
	table<string,string> targetAnimation3pPilot
	string sound_1p
	string sound_3p
	array<string> thirdPersonCameraAttachments
	array<string> linkedExecutions
}

struct
{
	table<string, TitanExcutionData> executionData_3p

	// modified
	bool titanExecutionNotInvulnerable = false
	// modified to have more execution options
	table<entity, bool> soulDoClassicExecution
	bool disableVanguardKit = false
	table<entity, bool> soulUseExecutionCallback
	table<entity, bool> soulShouldReplaceLoadout

	table<entity, bool> soulCanBeExecuted
} file

int RAGDOLL_IMPACT_TABLE_IDX = -1

function MeleeSyncedTitan_Init()
{
	RAGDOLL_IMPACT_TABLE_IDX = PrecacheImpactEffectTable( "ragdoll_human" )
	AddSyncedMeleeServerThink( GetSyncedMeleeChooser( "titan", "titan" ), MeleeThread_TitanVsTitan )

	if ( GetBugReproNum() == 129802 )
	{
		AddDeathCallback( "npc_titan", OnNPCTitanDeath )
	}

	PrecacheWeapon( "mp_titanweapon_salvo_rockets" )
	PrecacheParticleSystem( TEAM_JUMPJET_DBL )

	Init3pExecutions()
}

void function Init3pExecutions()
{
	var dataTable = GetDataTable( $"datatable/titan_executions.rpak" )
	int numRows = GetDatatableRowCount( dataTable )
	for ( int row=0; row<numRows; row++ )
	{
		TitanExcutionData data = Create_3p_ExecutionData( dataTable, row )
		string ref = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "ref" ) )
		file.executionData_3p[ref] <- data
	}
}

TitanExcutionData function Create_3p_ExecutionData( var dataTable, int row )
{
	string attackerAnimation3p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim" ) )
	string attackerAnimation3p_vsAutoTitan = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnimVsAutoTitan" ) )
	string targetAnimation3p_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_lt" ) )
	string targetAnimation3p_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_md" ) )
	string targetAnimation3p_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_hv" ) )
	string targetAnimation3pPilot_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_lt" ) )
	string targetAnimation3pPilot_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_md" ) )
	string targetAnimation3pPilot_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_hv" ) )

	string attackerAnimation3pPilot_lt = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_lt" ) != -1 )
		attackerAnimation3pPilot_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_lt" ) )

	string attackerAnimation3pPilot_md = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_mt" ) != -1 )
		attackerAnimation3pPilot_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_mt" ) )

	string attackerAnimation3pPilot_hv = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_ht" ) != -1 )
		attackerAnimation3pPilot_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_ht" ) )

	string sound_1p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "sound_1p" ) )
	string sound_3p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "sound_3p" ) )
	string camAttach = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "camAttach" ) )

	array<string> camAttachments = split( camAttach, " " )

	array<string> linkedExecutionArray = SplitAndStripStringArray( GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "linkedExecutions" ) ) )

	TitanExcutionData data
	data.attackerAnimation3p = attackerAnimation3p
	data.attackerAnimation3p_vsAutoTitan = attackerAnimation3p_vsAutoTitan
	data.targetAnimation3p[ "stryder" ] <- targetAnimation3p_lt
	data.targetAnimation3p[ "atlas" ] <- targetAnimation3p_md
	data.targetAnimation3p[ "ogre" ] <- targetAnimation3p_hv
	data.targetAnimation3pPilot[ "stryder" ] <- targetAnimation3pPilot_lt
	data.targetAnimation3pPilot[ "atlas" ] <- targetAnimation3pPilot_md
	data.targetAnimation3pPilot[ "ogre" ] <- targetAnimation3pPilot_hv
	data.attackerAnimation3pPilot[ "stryder" ] <- attackerAnimation3pPilot_lt
	data.attackerAnimation3pPilot[ "atlas" ] <- attackerAnimation3pPilot_md
	data.attackerAnimation3pPilot[ "ogre" ] <- attackerAnimation3pPilot_hv
	data.sound_1p = sound_1p
	data.sound_3p = sound_3p
	data.thirdPersonCameraAttachments = camAttachments
	data.linkedExecutions = linkedExecutionArray
	return data
}

array<string> function SplitAndStripStringArray( string combinedString )
{
	array<string> stringArray = split( combinedString, "," )

	foreach ( i, value in stringArray )
	{
		stringArray[ i ] = strip( value )
	}

	return stringArray
}


struct MeleeThread_TitanVsTitanDataStruct
{
	bool setAttackerInvulnerable = false
	bool setAttackerDemigod = false
	// save for npc executions. don't want them to have weird rotation after animation
	vector attackerStartingAngles
}

bool function MeleeThread_TitanVsTitan( SyncedMelee action, entity attacker, entity target )
{
	// function off for reload scripts
	return MeleeThread_TitanVsTitan_Internal( action, attacker, target )
}

bool function MeleeThread_TitanVsTitan_Internal( SyncedMelee action, entity attacker, entity target )
{
	Assert( target.IsTitan(), target + " is not Titan target" )
	Assert( attacker.IsPlayer() && attacker.IsTitan(), attacker + " is not Titan attacker" )

	#if SERVER
		printt( "Player", attacker, "attempting to melee", target, "TitanVsTitanMelee" )
	#endif

	if ( attacker.ContextAction_IsActive() || target.ContextAction_IsActive() )
	{
		printt("Either attacker or target already in ContextAction! Exiting Titan Vs Titan melee attempt")
		return false
	}

	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false

	void functionref( SyncedMelee action, entity attacker, entity target ) func
	func = GetTitanSyncedMeleeFunc( attacker, target )
	if ( func == null )
		return false

	attacker.GetTitanSoul().Signal( "OnSyncedMelee" ) 	//Need the signal on the soul to clean-up tether traps during synced executions.

	// JFS: signals can kill things mid frame: R2DLC-311 SCRIPT ERROR: PHONE_HOME: [SERVER] Entity is null
	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false

	target.GetTitanSoul().Signal( "OnSyncedMelee" )

	// JFS: signals can kill things mid frame: R2DLC-311 SCRIPT ERROR: PHONE_HOME: [SERVER] Entity is null
	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false
	//attacker.Signal( "OnSyncedMelee" )
	//target.Signal( "OnSyncedMelee" )

	MeleeThread_TitanVsTitanDataStruct dataStruct

	OnThreadEnd(
		function() : ( attacker, target, dataStruct )
		{
			if ( IsValid( attacker ) )
			{
				if ( dataStruct.setAttackerInvulnerable )
				{
					attacker.ClearInvulnerable()
					// attacker should be ignored while executing a target, cause they get invulnerablility
					// breaks vanilla behavior but whatever
					attacker.SetNoTarget( false )
				}

				if ( dataStruct.setAttackerDemigod )
					DisableDemigod( attacker )

				if( attacker.IsPlayer() ) // saved for npc executions
					attacker.PlayerMelee_SetState( PLAYER_MELEE_STATE_NONE )
				else // npc execution ends
				{
					vector angles = attacker.GetAngles()
					// reset their x, z angles
					angles.x = dataStruct.attackerStartingAngles.x
					angles.z = dataStruct.attackerStartingAngles.z
					attacker.SetAngles( angles )
				}
			}
		}
	)

	string titanSubClass = GetSoulTitanSubClass( attacker.GetTitanSoul() )

	entity burnCardTarget
	entity bossPlayer = target.GetBossPlayer()
	if ( target.IsNPC() )
	{
		if ( IsValid( bossPlayer ) )
			burnCardTarget = bossPlayer
	}
	else
	{
		burnCardTarget = target
	}

	if( attacker.IsPlayer() ) // save for npc executions
		attacker.PlayerMelee_ExecutionStartAttacker( 0 )
	target.PlayerMelee_ExecutionStartTarget( attacker )

	if( attacker.IsPlayer() ) // save for npc executions
		attacker.Lunge_ClearTarget()

	ForceTitanSustainedDischargeEnd( target )

	//#if TITAN_EXECUTION_ATTACKER_IS_INVULNERABLE // use my own check!
	if( !file.titanExecutionNotInvulnerable )
	{
		dataStruct.setAttackerInvulnerable = true
		attacker.SetInvulnerable()
		// attacker should be ignored while executing a target, cause they get invulnerablility
		// breaks vanilla behavior but whatever
		attacker.SetNoTarget( true )
	}
	else //#else
	{
		if( attacker.IsPlayer() )
		{
			dataStruct.setAttackerDemigod = true
			EnableDemigod( attacker )
		}
	}
	//#endif

	// modified: if function reaches here it must means titan being executed, we delay 1 frame and drop their weapon
#if MP
	ExecutedTitanDropWeapon( target )
#endif
	//

	// save for npc executions. don't want them to have weird rotation after animation
	dataStruct.attackerStartingAngles = attacker.GetAngles()
	//

	waitthread func( action, attacker, target )

	if ( !IsValid( attacker ) )
		return true

	attacker.Signal( "SyncedMeleeComplete" )
	#if MP
	if( IsValid( attacker ) )
	{
		if ( attacker.IsPlayer() )
		{
			if( IsValid( target ) ) // defensive fix
				AddPlayerScore( attacker, "Execution", target )
			else
				AddPlayerScore( attacker, "Execution" )
		}
	}
	#endif
	return true
}

void functionref( SyncedMelee action, entity attacker, entity target ) function GetTitanSyncedMeleeFunc( entity attacker, entity target )
{
	entity soul = attacker.GetTitanSoul()
	// modified here... could get some tf1 execution
	bool useClassicExecution = GetCurrentPlaylistVarInt( "classic_execution_enabled", 0 ) == 1
	if ( GetSoulDoClassicExecution( soul ) )
		useClassicExecution = true

	string attackerType = GetSoulTitanSubClass( soul )

	//entity soul = attacker.GetTitanSoul() // moved up
	#if SP
	TitanLoadoutDef loadout = GetTitanLoadoutForCurrentMap()
	#else
	TitanLoadoutDef loadout = soul.soul.titanLoadout // GetActiveTitanLoadout( attacker )
	#endif
	string executionRef = loadout.titanExecution
	// modified to nerf monarch
	if ( !file.disableVanguardKit )
	{
		if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) && attackerType == "atlas" ) // idk why respawn have to hardcode this
			executionRef = "execution_vanguard_kit"
	}

	//if ( executionRef in file.executionData_3p )
	if ( executionRef in file.executionData_3p && !useClassicExecution ) // classic execution check!
		return TitanVsTitan_3p

	// below must be tf1 execution, remove cinematic
	ForceRemoveExecutionCinematic( attacker )
	ForceRemoveExecutionCinematic( target )

	if ( target.IsNPC() )
	{
		entity bossPlayer = target.GetBossPlayer()
		// adding check: TitanHasNpcPilot()
		//if ( IsValid( bossPlayer ) || !IsVDUTitan( target ) )
		#if NPC_TITAN_PILOT_PROTOTYPE
			if ( !IsValid( bossPlayer ) && !TitanHasNpcPilot( target ) )
		#else // vanilla behavior
			if ( IsValid( bossPlayer ) || !IsVDUTitan( target ) )
		#endif
				return MeleeThread_AtlasVsTitanShort
	}

	//string attackerType = GetSoulTitanSubClass( soul ) // moved up

	switch ( attackerType )
	{
		case "stryder":
			return MeleeThread_StyderVsTitan

		case "ogre":
			return MeleeThread_OgreVsTitan

		case "atlas":
		case "buddy":
			return MeleeThread_AtlasVsTitan
	}

	return null
}

void function ForceRemoveExecutionCinematic( entity ent )
{
	if( ent.IsPlayer() )
	{
		RemoveCinematicFlag( ent, CE_FLAG_EXECUTION )
		RemoveCinematicFlag( ent, CE_FLAG_TITAN_3P_CAM )
	}
}

void function MeleeThread_AtlasVsTitanShort( SyncedMelee action, entity attacker, entity target )
{
	if ( !IsAlive( attacker ) )
		return

	if ( !IsAlive( target ) )
		return

	string attackerAnimation1p = "atpov_melee_sync_frontkill_autotitan"
	string attackerAnimation3p = "at_melee_sync_frontkill_autotitan"
	string targetAnimation3p = "at_melee_sync_frontdeath_autotitan"

	target.Signal( "TitanStopsThinking" ) // in future, need to make titan scripted anims co-exist better and not require gotcha stuff like this -Mackey

	local e = {}
	e.attackerViewBody <- null

	e.attackerStartOrg <- attacker.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = attackerAnimation3p
	// attackerSequence.thirdPersonAnimIdle = "at_melee_sync_frontkill_end_idle"

	attackerSequence.firstPersonAnim = attackerAnimation1p
	targetSequence.thirdPersonAnim = targetAnimation3p
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()    //HACK: Have to SetInvulnerable first before attacker holsters weapon, because if the attacker is vortexing, holster will release bullets caught and kill off the victim if low enough health
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	// modified
	if ( attacker.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	//HACK! This function was originally for NPCs only, but now that it is being used for players, we need to holster their weapon
	// modified
	//if ( target.IsPlayer() )
	//	HolsterAndDisableWeapons( target )
	if ( target.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.Anim_StopGesture( 0 )
	}
	else
		DisableWeapons( target, [] )

	// should always holster main weapon! moved up
	//if ( ShouldHolsterWeaponForSyncedMelee( attacker ) )
	//	HolsterAndDisableWeapons( attacker )

	local attackerViewBody

	// needs shortened verions
	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Titan_1p_Sync_Melee_vs_AutoTitan", "Titan_3p_Sync_Melee_vs_AutoTitan", attacker, attacker )

	local soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )

	AddAnimEvent( target, "rider_rodeo_over", ForceTitanRodeoToEnd  )

	target.SetInvulnerable() //Setting target of execution as invulnerable to prevent them dying mid-way
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	OnThreadEnd(
		function() : ( ref, attacker, target, e  )
		{
			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
					attacker.ClearParent()

				if ( IsValid( target ) )
					target.ClearParent()

				AssertNoPlayerChildren( ref )
				ref.Destroy()
			}

			if ( IsValid( attacker ) )
			{
				// saved for ai executions
				attacker.ClearParent()
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					// modified
					//DeployAndEnableWeapons( attacker )
					DeployViewModelAndEnableWeapons( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
				}
				else
				{
					// modified
					//EnableWeapons( attacker, [] )
					Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				//attacker.ClearInvulnerable()

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//DeployAndEnableWeapons( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					if ( !PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() ) )
                    {
						printt( "PutEntityInSafeSpot failed, putting him back at the start origin" )
						attacker.SetOrigin( expect vector( e.attackerStartOrg ) )
                    }

				}
			}

			if ( IsValid( target ) )
			{
				if ( !target.IsNPC() )
				{
					target.PlayerMelee_ExecutionEndTarget()
					ClearPlayerAnimViewEntity( target )
					// modified
					//DeployAndEnableWeapons( target )
					DeployViewModelAndEnableWeapons( target )
				}
				else
					EnableWeapons( target, [] )

				if ( IsAlive( target ) )
				{
					local attack = attacker
					if ( !IsValid( attack ) )
						attack = null

					target.Die( attack, attack, { scriptType = 0, damageSourceId = eDamageSourceId.titan_execution } )
				}

				target.e.syncedMeleeAttacker = null

				if ( HasAnimEvent( target, "rider_rodeo_over" ) )
					DeleteAnimEvent( target, "rider_rodeo_over" )
			}
		}
	)

	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	thread FirstPersonSequence( targetSequence, target, ref )
	waitthread FirstPersonSequence( attackerSequence, attacker, ref )

	//wait ( 50.0 / 30.0 ) // 37 frames in
}


void function MeleeThread_StyderVsTitan( SyncedMelee action, entity attacker, entity target )
{
	table e
	e.gib <- true
	e.attackerAnimation1p <- "strypov_melee_sync_frontkill"
	e.attackerAnimation3p <- "stry_melee_sync_frontkill"
	e.targetAnimation3p <- "stry_melee_sync_frontdeath"
	e.targetPilotAnimationForAttacker <- "pt_stry_melee_sync_front_pilotkill_1st"
	e.targetPilotAnimationForObserver <- "pt_stry_melee_sync_front_pilotkill_3rd"
	e.targetPilotAnimationForObserver1st <- "ptpov_stry_tvtmelee_targetdeath"
	e.TitanSpecific1pSyncMeleeSound <- "Stryder_1p_Sync_Melee"
	e.TitanSpecific3pSyncMeleeSound <- "Stryder_3p_Sync_Melee"

	MeleeThread_TitanRipsPilot( e, action, attacker, target )
}

void function MeleeThread_AtlasVsTitan( SyncedMelee action, entity attacker, entity target )
{
	table e
	e.gib <- false
	e.attackerAnimation1p <- "atpov_melee_sync_frontkill"
	e.attackerAnimation3p <- "at_melee_sync_frontkill"
	e.targetAnimation3p <- "at_melee_sync_frontdeath"
	e.targetPilotAnimationForAttacker <- "pt_melee_sync_front_pilotkill_1st"
	e.targetPilotAnimationForObserver <- "pt_melee_sync_front_pilotkill_3rd"
	e.targetPilotAnimationForObserver1st <- "ptpov_tvtmelee_targetdeath"
	e.TitanSpecific1pSyncMeleeSound <- "Atlas_1p_Sync_Melee"
	e.TitanSpecific3pSyncMeleeSound <- "Atlas_3p_Sync_Melee"

	MeleeThread_TitanRipsPilot( e, action, attacker, target )
}

function MeleeThread_TitanRipsPilot( table e, SyncedMelee action, entity attacker, entity target )
{
	e.attackerViewBody <- null
	e.attacker <- attacker
	e.attackerStartOrg <- attacker.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = expect string ( e.attackerAnimation3p )
	// attackerSequence.thirdPersonAnimIdle = "at_melee_sync_frontkill_end_idle"

	attackerSequence.firstPersonAnim = expect string( e.attackerAnimation1p )
	targetSequence.thirdPersonAnim = expect string ( e.targetAnimation3p )
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()    //HACK: Have to SetInvulnerable first before attacker holsters weapon, because if the attacker is vortexing, holster will release bullets caught and kill off the victim if low enough health
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	// modified, always holster!!!
	//if ( ShouldHolsterWeaponForSyncedMelee( attacker ) )
	//{
	//	if ( attacker.IsPlayer() )
	//		HolsterAndDisableWeapons( attacker )
	//	else
	//		DisableWeapons( attacker, [] )
	//}
	if ( attacker.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	// modified
	//if ( !target.IsNPC() )
	//	HolsterAndDisableWeapons( target )
	if ( target.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.Anim_StopGesture( 0 )
	}
	else
		DisableWeapons( target, [] )

	EmitDifferentSoundsOnEntityForPlayerAndWorld( expect string ( e.TitanSpecific1pSyncMeleeSound ), expect string ( e.TitanSpecific3pSyncMeleeSound ), attacker, attacker )

	entity attackerViewBody
	bool targetIsPlayer = target.IsPlayer()

	if ( targetIsPlayer )
	{
	    attackerViewBody = Wallrun_CreateCopyOfPilotModel( target ) //attackerViewBody is the model of the pilot getting ripped out of the cockpit
	}
	else
	{
	    attackerViewBody = CreateNpcTitanPilotModel( target )
	}

	attackerViewBody.SetOrigin( ref.GetOrigin() )
	e.attackerViewBody = attackerViewBody
	attackerViewBody.SetOwner( attacker )
	attackerViewBody.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
	attackerViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
	attackerViewBody.SetContinueAnimatingAfterRagdoll( true )

	FirstPersonSequenceStruct attackerBodySequence
	attackerBodySequence.attachment = "ref"
	attackerBodySequence.teleport = true
	attackerBodySequence.thirdPersonAnim = expect string ( e.targetPilotAnimationForAttacker )

	FirstPersonSequenceStruct targetBodySequence
	targetBodySequence.attachment = "ref"
	targetBodySequence.blendTime = 0.25
	targetBodySequence.thirdPersonAnim = expect string ( e.targetPilotAnimationForObserver )
	targetBodySequence.firstPersonAnim = expect string ( e.targetPilotAnimationForObserver1st )


	entity targetSoul = target.GetTitanSoul()
	targetSoul.SetInvalidHealthBarEnt( true )

	entity targetTitan
	if ( targetIsPlayer )
	{
		e.oldPlayerSettings <- target.s.storedPlayerSettings
		//target.s.storedPlayerSettings = "pilot_titan_cockpit" // Makes player have titan cockpit temporarily. Turned off to avoid having extra checks all over in script
		targetTitan = CreateAutoTitanForPlayer_ForTitanBecomesPilot( target ) //TargetTitan is the NPC Titan that is created temporarily during execution
		DispatchSpawn( targetTitan )

		TitanBecomesPilot( target, targetTitan )
		DisableTitanRodeo( targetTitan )
		targetTitan.SetOwner( target )
		targetTitan.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) //owner cant see
		targetTitan.PlayerMelee_ExecutionStartTarget( attacker )
    	e.target <- target

		// modified for titanpick!
		// don't drop weapon on this titan. CreateAutoTitanForPlayer_ForTitanBecomesPilot() won't spawn a soul, so we get soul after player transfer their titanSoul(through TitanBecomesPilot) to this targetTitan
		entity soul = targetTitan.GetTitanSoul()
		if ( IsValid( soul ) )
			TitanPick_SoulSetEnableWeaponDrop( soul, false )
	}
	else
	{
		targetTitan = target

		// modified for titanpick!
		// don't drop weapon on this titan
		// fix: the target is still a titan, not transfering, guess no need to manually disable weapon drop
		//entity soul = targetTitan.GetTitanSoul()
		//if ( IsValid( soul ) )
		//	TitanPick_SoulSetEnableWeaponDrop( soul, false )

		// target is now a random dude
		//target = CreateSoldier( target.GetTeam(), Vector(0,0,0), Vector(0,0,0) )
		target = CreateNPC( "npc_pilot_elite", targetTitan.GetTeam(), targetTitan.GetOrigin(), < 0,0,0 > )
		DispatchSpawn( target )
		// modified: make them use pilot's model, and mark as silentDeath
		TakeAllWeapons( target )
		target.SetModel( GetNpcTitanPilotModel( targetTitan ) )
		target.s.silentDeath <- true
    	e.target <- target

		// vanilla missing
		target.SetInvulnerable()
		target.SetNoTarget( true )
	}


	AddAnimEvent( targetTitan, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	AddAnimEvent( targetTitan, "melee_killed_ragdoll", MeleeKilledRagdoll, attacker )

	targetTitan.SetInvulnerable() //Setting target of execution as invulnerable to prevent them dying mid-way
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	targetTitan.SetNoTarget( true )

	target.SetOwner( attacker )
	target.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) //owner cant see
	e.targetTitan <- targetTitan

	if ( GetBugReproNum() == 129802 )
		thread OnNPCTitanSignalDeath( targetTitan )

	OnThreadEnd(
		function() : ( ref, attacker, target, targetTitan, e  )
		{
			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
				{
					attacker.ClearParent()
				}
				else
				{
					TryClearParent( attacker )
				}

				if ( IsValid( target ) )
				{
					target.ClearParent()
				}
				else
				{
					TryClearParent( target )
				}

				AssertNoPlayerChildren( ref )
				ref.Kill_Deprecated_UseDestroyInstead()
			}

			if ( IsValid( attacker ) )
			{
				attacker.ClearParent()
				// saved for npc executions
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker ) 
					// modified
					//DeployAndEnableWeapons( attacker )
					DeployViewModelAndEnableWeapons( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
				}
				else
				{
					EnableWeapons( attacker, [] )
					Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				// change for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker ) 
				//DeployAndEnableWeapons( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() )
				}
			}

			if ( IsValid( target ) )
			{
				if ( !target.IsNPC() )
				{
					target.PlayerMelee_ExecutionEndTarget()
					ClearPlayerAnimViewEntity( target )
					// modified
					//DeployAndEnableWeapons( target )
					DeployViewModelAndEnableWeapons( target )
				}

				if ( HasAnimEvent( target, "pink_mist" ) )
					DeleteAnimEvent( target, "pink_mist" )

				if ( IsAlive( expect entity( e.target ) ) )
					MeleePinkMist( e )

				target.e.syncedMeleeAttacker = null
			}

			if ( IsValid( e.attackerViewBody ) )
				e.attackerViewBody.Kill_Deprecated_UseDestroyInstead()

			if ( GetBugReproNum() != 129802 && IsAlive( targetTitan ) )
			{
				if ( IsValid( attacker ) )
					targetTitan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
				else
					targetTitan.Die()

				if ( GetBugReproNum() == 129815 )
				{
					targetTitan.SetContinueAnimatingAfterRagdoll( true )
					targetTitan.BecomeRagdoll( Vector(0,0,0), false )
				}
			}
		}
	)

	target.EndSignal( "OnRespawnPlayer" ) // northstar scripts didn't use this often... this is signaled in CPlayer::RespawnPlayer()
	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	waitthread TitanSyncedMeleeAnimationsPlay( attackerBodySequence, attackerViewBody, ref, targetBodySequence, target, attackerSequence, attacker, targetSequence, targetTitan, e )
}

entity function CreateNpcTitanPilotModel( entity titan )
{
	asset modelName = GetNpcTitanPilotModel( titan )
	entity pilotModel = CreatePropDynamic( modelName, titan.GetAttachmentAngles( titan.LookupAttachment( "hijack" ) ) ) // spawn right under titan, won't have the model "flash" into titans.
	SetTeam( pilotModel, titan.GetTeam() ) // so prop will have team lights
	//SetDefaultMPEnemyHighlight( pilotModel ) // don't know should use
	return pilotModel
}

asset function GetNpcTitanPilotModel( entity titan )
{
	asset modelName = TEAM_IMC_GRUNT_MODEL

	#if HAS_BOSS_AI
		if ( IsBossTitan( titan ) )
		{
			modelName = GetBossTitanCharacterModel( titan )
		}
	#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
		if( TitanHasNpcPilot( titan ) )
		{
			entity titanSoul = titan.GetTitanSoul()
			modelName = titanSoul.soul.seatedNpcPilot.modelAsset
		}
	#endif

	return modelName
}

function TitanSyncedMeleeAnimationsPlay( FirstPersonSequenceStruct attackerBodySequence, entity attackerViewBody, entity ref, FirstPersonSequenceStruct targetBodySequence, entity target, FirstPersonSequenceStruct attackerSequence, entity attacker, FirstPersonSequenceStruct targetSequence, entity targetTitan, table e )
{
	e.thrown <- false
	OnThreadEnd (
		function () : ( targetTitan, target, attacker, e )
		{
			// insure visibility
			if ( IsValid( targetTitan ) )
				targetTitan.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE

			if ( !IsAlive( attacker ) )
			{
				attacker.Anim_Stop()

				if ( !e.thrown && IsAlive( target ) )
				{
					target.Anim_Stop()
					target.SetOwner( null )
					target.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
					if ( target.IsPlayer() )
					{
						ClearPlayerAnimViewEntity( target )
						target.GetFirstPersonProxy().Anim_Stop()
						target.SetPlayerSettings( e.oldPlayerSettings )
					}

				}
			}
		}
	)

	attacker.EndSignal( "OnDeath" )
	target.EndSignal( "OnDestroy" )
	target.EndSignal( "OnRespawnPlayer" ) // northstar scripts didn't use this often... this is signaled in CPlayer::RespawnPlayer()

	if ( !attacker.IsPlayer() ) // save for npc titans
	{
		// don't do first person anims if we're not a player
		attackerBodySequence.firstPersonAnim = ""
		attackerBodySequence.firstPersonAnimIdle = ""
	}

	thread FirstPersonSequence( attackerBodySequence, attackerViewBody, ref )
	if ( !target.IsPlayer() )
	{
		// don't do first person anims if we're not a player
		targetBodySequence.firstPersonAnim = ""
		targetBodySequence.firstPersonAnimIdle = ""
	}

	thread FirstPersonSequence( targetBodySequence, target, ref )
	thread FirstPersonSequence( attackerSequence, attacker, ref )
	thread FirstPersonSequence( targetSequence, targetTitan, ref )
	targetTitan.Anim_AdvanceCycleEveryFrame( true )
	local duration = attacker.GetSequenceDuration( attackerSequence.thirdPersonAnim )

	if ( e.targetAnimation3p == "at_melee_sync_frontdeath" )
	{
		thread MeleeThrowIntoWallSplat( attacker, target, e )
	}
	else
	{
		AddAnimEvent( target, "pink_mist", MeleePinkMistAnimEvent, e )
	}

	float timer
	string titanType = GetSoulTitanSubClass( attacker.GetTitanSoul() )
	switch ( titanType )
	{
		case "stryder":
			timer = 0.9
			break
		case "atlas":
		case "buddy":
			timer = 0.45
			break
		default:
			Assert( 0, "Unknown titan type " + titanType )
	}

	wait timer

	// first the victim cant see his titan, as a pilot, and then he can
	targetTitan.SetNextThinkNow()
	targetTitan.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	targetTitan.SetNextThinkNow()
	wait duration - timer
}

void function MeleePinkMistAnimEvent( entity target ) //parameter isn't used, but function signature is like this because it's being called from an anim event
{
	table e = expect table( GetOptionalAnimEventVar( target, "pink_mist" ) )

	MeleePinkMist( e )
}

void function MeleePinkMist( table e )
{
	entity target = expect entity( e.target )

	if ( !IsAlive( target ) )
		return

	e.attackerViewBody.Dissolve( ENTITY_DISSOLVE_PINKMIST, Vector( 0, 0, 0 ), 0 )
	if ( IsValid( e.attacker ) )
	{
		target.Die( e.attacker, e.attacker, { damageSourceId = eDamageSourceId.titan_execution, scriptType = DF_GIB } )
	}
	else
	{
		target.Die( e.target, target, { damageSourceId = eDamageSourceId.titan_execution, scriptType = DF_GIB } )
	}

	if ( target.IsPlayer() )
		ClearPlayerAnimViewEntity( target )

	target.ClearInvulnerable()
	// target should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( false )
}

function MeleeThrowIntoWallSplat( entity attacker, entity target, e )
{
	OnThreadEnd(
		function () : ( target, e )
		{
			if ( IsValid( target ) )
			{
				target.ClearParent()
				target.Anim_Stop()
				target.ClearInvulnerable()
				// target should be ignored while being executed
				// breaks vanilla behavior but whatever
				target.SetNoTarget( false )
			}
		}
	)

	target.EndSignal( "OnDeath" )

	e.startOrigin <- target.GetOrigin()
	wait 2.8
	e.thrown = true


	// attacker got killed? saved!
	if ( !IsAlive( attacker ) )
		return

	local angles = attacker.GetAngles()
	angles = AnglesCompose( angles, Vector( -15, 0, 0 ) )
	local forward = AnglesToForward( angles )

	local endPos
	for ( ;; )
	{
		if ( !target.Anim_IsActive() )
			break

		local org = target.GetOrigin()
		if ( IsAlive( attacker ) )
		{
			TraceResults titanPilotTrace = TraceLine( attacker.EyePosition(), org, attacker )

			if ( titanPilotTrace.fraction < 1.0 )
			{
				endPos = titanPilotTrace.endPos
				break
			}
		}


		TraceResults result = TraceLine( org, org + forward * 200 )
		if ( result.fraction < 1.0 )
		{
			wait result.fraction * 0.06
			break
		}

		WaitFrame()
	}

	if ( endPos )
	{
		target.SetOrigin( endPos )
	}

	Assert( IsAlive( target ) )

	target.ClearInvulnerable()
	// target should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( false )

	target.BecomeRagdoll( Vector(0,0,0), false )

	WaitFrame() // ragdoll take hold!
	EmitSoundOnEntity( target, "Titan_Victim_Wall_Splat" )

	if ( e.gib )
	{
		local force = Vector(0,0,0)
		if ( IsAlive( attacker ) )
		{
			local vec = target.GetOrigin() - attacker.GetOrigin()
			vec.Norm()
			force = vec
		}
		target.Die( attacker, attacker, { scriptType = DF_GIB | DF_KILLSHOT, force = force, damageSourceId = eDamageSourceId.titan_execution } )
	}
	else
	{
		target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
	}
}


function MeleeAnimThrow( attacker, target, throwDuration )
{
	attacker.EndSignal( "OnDeath" )
	target.EndSignal( "OnDeath" )
	wait throwDuration - 0.2

	local angles = attacker.GetAngles()
	local forward = AnglesToForward( angles )
	target.ClearParent()
	target.SetVelocity( forward * 500 )


	target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
}

///////////////////////////////////////
// OGRE MELEES
///////////////////////////////////////
void function MeleeThread_OgreVsTitan( SyncedMelee action, entity attacker, entity target )
{
	string attackerAnimation1p = "ogpov_melee_armrip_attacker"
	string attackerAnimation3p = "og_melee_armrip_attacker"
	string targetAnimation1p = "ogpov_melee_armrip_victim"
	string targetAnimation3p = "og_melee_armrip_victim"

	table e = {}
	e.attackerStartOrg <- attacker.GetOrigin()
	e.lostArm <- false
	e.targetStartOrg <- target.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = attackerAnimation3p
	attackerSequence.firstPersonAnim = attackerAnimation1p

	if ( target.IsPlayer() )
		targetSequence.firstPersonAnim = targetAnimation1p

	targetSequence.thirdPersonAnim = targetAnimation3p
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	// modified
	//DisableWeapons( attacker, [] )
	if ( attacker.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	// modified
	//DisableWeapons( target, [] ) 
	//	attacker.SetInvulnerable() // set from main thread
	target.SetInvulnerable()
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	if ( target.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.Anim_StopGesture( 0 )
	}
	else
		DisableWeapons( target, [] )

	entity soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )

	OnThreadEnd(
		function() : ( ref, attacker, target, e  )
		{
			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
					attacker.ClearParent()

				if ( IsValid( target ) )
					target.ClearParent()

				AssertNoPlayerChildren( ref )
				ref.Kill_Deprecated_UseDestroyInstead()
			}

			if ( IsValid( attacker ) )
			{
				// save for npc executions
				attacker.ClearParent()
				//EnableWeapons( attacker, [] )
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
					// modified
					DeployViewModelAndEnableWeapons( attacker ) // so ogre titans can have their weapon back
				}
				else // npc
				{
					Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
					EnableWeapons( attacker, [] )
				}

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//EnableWeapons( attacker, [] )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() )
					attacker.SetActiveWeaponBySlot( 0 ) // so ogre titans can have their weapon back, doesn't seem necessary
				}
			}

			if ( IsValid( target ) )
			{
				if( HasAnimEvent( target, "lost_arm" ) )
					DeleteAnimEvent( target, "lost_arm" )

				target.e.syncedMeleeAttacker = null

				target.ClearParent()
				target.ClearInvulnerable()
				// target should be ignored while being executed
				// breaks vanilla behavior but whatever
				target.SetNoTarget( false )

				if ( target.IsPlayer() )
				{
					ClearPlayerAnimViewEntity( target )
					// modified
					//DeployAndEnableWeapons( target )
					DeployViewModelAndEnableWeapons( target )
				}
				else
					EnableWeapons( target, [] )

				if ( !target.IsNPC() )
					target.PlayerMelee_ExecutionEndTarget()

				if ( e.lostArm && IsAlive( target ) )
				{
					target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
					return
				}
				else if ( target.IsPlayer() )
				{
					PutEntityInSafeSpot( target, null, null, expect vector( e.targetStartOrg ), target.GetOrigin() )
				}

				// fix for death animation
				// in older version player will show a spectator model on ground
				// with fixed base_gametype_mp this should no longer be a issue
				//if ( !IsAlive( target ) ) // target killed!
				//	target.BecomeRagdoll( < 0, 0, 0 >, false )
			}
		}
	)

	attacker.EndSignal( "OnDeath" )
	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Ogre_1p_Sync_Melee", "Ogre_3p_Sync_Melee", attacker, attacker )

	AddAnimEvent( target, "lost_arm", TitanLostArm, e )


	thread FirstPersonSequence( targetSequence, target, ref )
	waitthread FirstPersonSequence( attackerSequence, attacker, ref )
}

//Very similar to the above function for now, eventually won't have the 1st person component at all.
void function TitanVsTitan_3p( SyncedMelee action, entity attacker, entity target )
{
	if ( !IsAlive( attacker ) )
		return

	if ( !IsAlive( target ) )
		return

	entity attackerSoul = attacker.GetTitanSoul()
#if SP
	TitanLoadoutDef loadout = GetTitanLoadoutForCurrentMap()
	string executionRef = loadout.titanExecution
	TitanExcutionData data = file.executionData_3p[ executionRef ]
#else
	TitanLoadoutDef loadout = attackerSoul.soul.titanLoadout // GetActiveTitanLoadout( attacker )
	string executionRef = loadout.titanExecution
	TitanExcutionData data = file.executionData_3p[ executionRef ]
	if ( data.linkedExecutions.len() > 0 )
	{
		array<string> clonedLinkedExecutions = clone data.linkedExecutions
		for ( int i = clonedLinkedExecutions.len() - 1; i >= 0; i-- )
		{
			if ( GetItemRequiresPrime( clonedLinkedExecutions[ i ] ) == true && !HasPrimeToMatchExecutionType( attacker, GetItemType( clonedLinkedExecutions[ i ] ) ) )
				clonedLinkedExecutions.remove( i )
		}
		executionRef = clonedLinkedExecutions.getrandom()
		data = file.executionData_3p[ executionRef ]
	}
#endif

	bool shouldApplyBatteryAfterRodeo = false
	string attackerType = GetSoulTitanSubClass( attackerSoul )
	// modified to nerf monarch
	if ( !file.disableVanguardKit )
	{
		if ( SoulHasPassive( attackerSoul, ePassives.PAS_VANGUARD_COREMETER ) )
		{
			if ( attackerType == "atlas" ) // anti crash
			{
				executionRef = "execution_vanguard_kit"
				data = file.executionData_3p[ executionRef ]
			}
			shouldApplyBatteryAfterRodeo = true // even if we're not atlas model, apply batteries if we have the passive
		}
	}

	// extra check for npc monarch executions -- spawn with no passive and ref "execution_random_6", uses random execution!
	#if NPC_TITAN_PILOT_PROTOTYPE
		if ( !SoulHasPassive( attackerSoul, ePassives.PAS_VANGUARD_COREMETER ) )
		{
			if ( TitanHasNpcPilot( attacker ) && executionRef == "execution_random_6" ) // also check if pilot valid
			{
				if ( CoinFlip() ) 
				{
					if ( attackerType == "atlas" ) // anti crash
					{
						executionRef = "execution_vanguard_kit"
						data = file.executionData_3p[ executionRef ]
					}
					shouldApplyBatteryAfterRodeo = true
				}
			}
		}
	#endif

	// apply battery check for monarch that spawn with "execution_vanguard_kit"
	if ( !shouldApplyBatteryAfterRodeo && executionRef == "execution_vanguard_kit" )
		shouldApplyBatteryAfterRodeo = true

	// add a condition for bt can use random executions
	if ( executionRef == "execution_bt" ) // if we're using unnamed bt execution
	{
		// select a random one
		array<string> btExecutions = ["execution_bt_flip"] // always enabled
		bool titanHasPilot = target.IsPlayer()
		#if HAS_BOSS_AI
			titanHasPilot = titanHasPilot || ( IsBossTitan( target ) )
		#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
			titanHasPilot = titanHasPilot || TitanHasNpcPilot( target )
		#endif
		if ( titanHasPilot ) // try to use pilotrip only if target has a seated pilot model
			btExecutions.append( "execution_bt_pilotrip" )
		if ( attacker.GetMainWeapons().len() > 0 ) // try to use kickshoot only if attacker has at least one main weapon
			btExecutions.append( "execution_bt_kickshoot" )
		executionRef = btExecutions[ RandomInt( btExecutions.len() ) ]
		data = file.executionData_3p[ executionRef ] // update execution data
	}

	//print( "executionRef is: " + executionRef )
	// modified: callbacks in sh_melee_synced_titan.gnut
	if ( GetSoulUseExecutionCallback( attacker.GetTitanSoul() ) )
		MeleeSyncedTitan_RunCallbacksForRef( executionRef, attacker, target )
	// modified: loadout replace think in sh_melee_synced_titan.gnut
	// force attacker to use certain execution's weapon, to avoid visual issues
	if ( GetSoulReplaceLoadoutOnExecution( attacker.GetTitanSoul() ) )
		MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef( executionRef, attacker )

	string victimType = GetSoulTitanSubClass( target.GetTitanSoul() )

	table e = {}
	e.attackerStartOrg <- attacker.GetOrigin()
	e.lostArm <- false
	e.targetStartOrg <- target.GetOrigin()

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"
	attackerSequence.thirdPersonCameraAttachments = clone data.thirdPersonCameraAttachments
	attackerSequence.thirdPersonCameraVisibilityChecks = true
	attackerSequence.viewConeFunction = ViewConeZero
	attackerSequence.noViewLerp = true

	FirstPersonSequenceStruct targetSequence = clone attackerSequence
	attackerSequence.thirdPersonAnim = data.attackerAnimation3p
	
	attackerSequence.firstPersonAnim = ""

	if ( target.IsPlayer() )
		targetSequence.firstPersonAnim = ""

	targetSequence.thirdPersonAnim = data.targetAnimation3p[ victimType ]
	
	targetSequence.thirdPersonCameraEntity = target

	target.e.syncedMeleeAttacker = attacker

	// mp version handled in sh_melee_synced_titan.gnut, Execution_BT_KickShoot()
	// HACK FOR SP!!!
	e.replacedPrimary <- false
	string xo16 = "mp_titanweapon_xo16_shorty"
	array<entity> weapons = attacker.GetMainWeapons()
	if ( IsSingleplayer() && attacker.IsPlayer() && data.attackerAnimation3p == "bt_synced_titan_execute_kickshoot_A" )
	{
		if ( weapons[0].GetWeaponClassName() != xo16 )
		{
			e.replacedPrimary = true
			e.oldPrimary <- weapons[0].GetWeaponClassName()
			attacker.SetActiveWeaponBySlot( 0 )
			attacker.ReplaceActiveWeapon( xo16 ) //this assumes the active weapon is the weapon in slot 0 so we need to set active weapon to the one in slot 0
		}
	}
	// END HACK FOR SP!!!

	if ( !target.IsNPC() )
		HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
	else
		DisableWeapons( target, [] )

	if ( attacker.IsPlayer() )
	{
		HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		attacker.Anim_StopGesture( DEFAULT_SCRIPTED_ANIMATION_BLEND_TIME )
	}
	if ( target.IsPlayer() ) // vanilla missing! target should also stop gesture animation!
		target.Anim_StopGesture( DEFAULT_SCRIPTED_ANIMATION_BLEND_TIME )

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	entity targetViewBody
	FirstPersonSequenceStruct targetBodySequence
	entity attackerViewBody
	FirstPersonSequenceStruct attackerBodySequence

	bool titanHasPilot = target.IsPlayer()
	#if HAS_BOSS_AI
		titanHasPilot = titanHasPilot || ( IsBossTitan( target ) )
	#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
		titanHasPilot = titanHasPilot || TitanHasNpcPilot( target )
	#endif

	if ( attacker.IsPlayer() )
	{
		Remote_CallFunction_Replay( attacker, "SCB_StopTitanCockpitSounds" )
	}

	if ( target.IsPlayer() )
	{
		Remote_CallFunction_Replay( target, "SCB_StopTitanCockpitSounds" )
	}

	if ( data.targetAnimation3pPilot[ victimType ] != "" && titanHasPilot )
	{
		if ( target.IsNPC() )
			targetViewBody = CreateNpcTitanPilotModel( target )
		else
			targetViewBody = Wallrun_CreateCopyOfPilotModel( target )

		targetViewBody.SetOrigin( target.GetOrigin() )
		targetViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
		targetViewBody.SetContinueAnimatingAfterRagdoll( true )

		targetBodySequence.attachment = "ref"
		targetBodySequence.teleport = true
		targetBodySequence.thirdPersonAnim = data.targetAnimation3pPilot[ victimType ]

		AddAnimEvent( targetViewBody, "pink_mist", MeleePinkMistFakeBody )
	}

	// modified for npc executions!
	//if ( data.attackerAnimation3pPilot[ victimType ] != "" && attacker.IsPlayer() )
	if ( data.attackerAnimation3pPilot[ victimType ] != "" && ( attacker.IsPlayer() || TitanHasNpcPilot( attacker ) ) )
	{
		if ( attacker.IsNPC() ) // saved for npc executions
			attackerViewBody = CreateNpcTitanPilotModel( attacker )
		else
			attackerViewBody = Wallrun_CreateCopyOfPilotModel( attacker )

		attackerViewBody.SetOrigin( attacker.GetOrigin() )
		attackerViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
		attackerViewBody.SetContinueAnimatingAfterRagdoll( true )

		attackerBodySequence.attachment = "ref"
		attackerBodySequence.teleport = true
		attackerBodySequence.thirdPersonAnim = data.attackerAnimation3pPilot[ victimType ]
	}

	if ( !IsValid( targetViewBody ) )
	{
		if( attackerSequence.thirdPersonAnim == data.attackerAnimation3p )
			attackerSequence.thirdPersonAnim = data.attackerAnimation3p_vsAutoTitan
	}

	entity soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )

	bool isAttackerRef = false
	if ( GetConVarBool( "melee_titan_execution_attacker_can_be_ref" ) )
	{
		isAttackerRef = IsAttackerRef( null, target )
	}

	OnThreadEnd(
		function() : ( attacker, target, e, attackerViewBody, targetViewBody, shouldApplyBatteryAfterRodeo, isAttackerRef )
		{
			if ( IsValid( attacker ) )
			{
				if( HasAnimEvent( attacker, "synced_melee_enable_planting" ) )
					DeleteAnimEvent( attacker, "synced_melee_enable_planting" )
				if( HasAnimEvent( attacker, "rocket_pod_fire_left" ) )
					DeleteAnimEvent( attacker, "rocket_pod_fire_left" )
				if( HasAnimEvent( attacker, "rocket_pod_fire_right" ) )
					DeleteAnimEvent( attacker, "rocket_pod_fire_right" )

				// save for npc executions
				attacker.ClearParent()
				ForceTitanSustainedDischargeEnd( attacker )
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
					DeployViewModelAndEnableWeapons( attacker )
				}
				else
				{
					EnableWeapons( attacker, [] )
					//Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()
				//ForceTitanSustainedDischargeEnd( attacker )
				//DeployViewModelAndEnableWeapons( attacker ) //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
				
				if ( IsAlive( attacker ) )
				{
					if ( !isAttackerRef && IsValid( target ) )
					{
						PutEntityInSafeSpot( attacker, target, null, target.GetOrigin(), attacker.GetOrigin() )
					}
					else
					{
						PutEntityInSafeSpot( attacker, target, null, attacker.GetOrigin(), attacker.GetOrigin() )
					}

					if ( attacker.IsTitan() )
					{
						// changed for npc executions
						if( attacker.IsPlayer() )
							Remote_CallFunction_Replay( attacker, "SCB_PlayTitanCockpitSounds" )
						#if TITAN_EXECUTION_GIVES_BATTERY
							Rodeo_GiveExecutingTitanABattery( attacker )
						#else
							if ( shouldApplyBatteryAfterRodeo )
								Rodeo_GiveExecutingTitanABattery( attacker )
						#endif
					}

					if ( IsSingleplayer() )
					{
						if ( e.replacedPrimary )
						{
							attacker.ReplaceActiveWeapon( e.oldPrimary )
						}
					}
					else
                    {
						attacker.Anim_Stop() // if you are fighting an NPC, then they can get destroyed early the moment they explode.  But sometimes, your animation isn't done playing yet so you can't move
                    }
				}

			}

			if ( IsValid( target ) )
			{
				if ( HasAnimEvent( target, "melee_killed_ragdoll" ) )
					DeleteAnimEvent( target, "melee_killed_ragdoll" )
				if ( HasAnimEvent( target, "execution_battery_show" ) )
					DeleteAnimEvent( target, "execution_battery_show" )
				if ( HasAnimEvent( target, "execution_battery_hide" ) )
					DeleteAnimEvent( target, "execution_battery_hide" )


				if ( HasAnimEvent( target, "rider_rodeo_over" ) )
					DeleteAnimEvent( target, "rider_rodeo_over" )

				target.e.syncedMeleeAttacker = null

				target.ClearParent()
				target.ClearInvulnerable()
				// target should be ignored while being executed
				// breaks vanilla behavior but whatever
				target.SetNoTarget( false )

				if ( target.IsPlayer() )
				{
					ClearPlayerAnimViewEntity( target )
					DeployViewModelAndEnableWeapons( target ) //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
				}

				if ( !target.IsNPC() && target.ContextAction_IsMeleeExecution() )
					target.PlayerMelee_ExecutionEndTarget()

				if ( IsAlive( target ) ) //Should have no need to PlayTitanCockpitSounds for target because the target is going to die
				{
					target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
				}
				else if ( target.IsPlayer() )
				{
					if ( isAttackerRef && IsValid( attacker ) )
					{
						PutEntityInSafeSpot( target, attacker, null, attacker.GetOrigin(), target.GetOrigin() )
					}
					else
					{
						PutEntityInSafeSpot( target, attacker, null, target.GetOrigin(), target.GetOrigin() )
					}
				}
			}

			if ( IsValid( attackerViewBody ) )
			{
				//DeleteAnimEvent( attackerViewBody, "rodeo_battery_rip" )
				if( HasAnimEvent( attackerViewBody, "execution_battery_pilot" ) )
					DeleteAnimEvent( attackerViewBody, "execution_battery_pilot" )
				if( HasAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" ) )
					DeleteAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" )
				attackerViewBody.Hide()
				attackerViewBody.Destroy()
			}

			if ( IsValid( targetViewBody ) )
			{
				targetViewBody.Hide()
				targetViewBody.Destroy()
			}
		}
	)

	attacker.EndSignal( "OnDeath" )
	entity bossPlayer = target.GetBossPlayer()
	if ( IsValid( bossPlayer ) ) //Executing an auto-Titan, when the pilot disconnects it destroys the auto-titan creating weird circumstances.
		bossPlayer.EndSignal( "OnDestroy" )
	target.EndSignal( "OnDestroy" )
	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	if ( isAttackerRef )
	{
		thread ClearParentOnDeathOrDestroy( target, attacker )
	}
	else
	{
		thread ClearParentOnDeathOrDestroy( attacker, target )
	}

	EmitDifferentSoundsOnEntityForPlayerAndWorld( data.sound_1p, data.sound_3p, attacker, attacker )

	AddAnimEvent( target, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	AddAnimEvent( target, "melee_killed_ragdoll", PredatorMeleeKilledRagdoll )
	AddAnimEvent( attacker, "synced_melee_enable_planting", EnablePlantingOnEntity )
	AddAnimEvent( attacker, "rocket_pod_fire_left", Northstar_Rocket_Pod_Left, target )
	AddAnimEvent( attacker, "rocket_pod_fire_right", Northstar_Rocket_Pod_Right, target )
	AddAnimEvent( target, "execution_battery_show", Execution_ShowBattery )
	AddAnimEvent( target, "execution_battery_hide", Execution_HideBattery )
	if ( attackerViewBody != null )
	{
		AddAnimEvent( attackerViewBody, "execution_battery_pilot", Execution_GivePilotBattery )
		AddAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets", Execution_BatteryStealJumpJets )
	}


	if ( isAttackerRef )
	{
		attackerSequence.enablePlanting = true
		attackerSequence.playerPushable = true
		targetSequence.useAnimatedRefAttachment = true
	}
	else
	{
		targetSequence.enablePlanting = true
		targetSequence.playerPushable = true
		attackerSequence.useAnimatedRefAttachment = true
	}

	array<entity> ignoreEnts = [ attacker, target ]

	vector refAngles = GetRefAnglesBetweenEnts( attacker, target )

	if ( !attacker.IsOnGround() )
	{
		refAngles = <0,refAngles.y,0>
	}

	vector fwd = AnglesToForward( refAngles )
	fwd *= -1
	vector targetAngles = VectorToAngles( fwd )
	if ( !target.IsNPC() )
	{
		targetAngles.x = 0
		target.SetAngles( targetAngles )
	}

	target.SetAngles( targetAngles )

	if ( attackerViewBody != null )
	{
		attackerBodySequence.useAnimatedRefAttachment = true
		thread FirstPersonSequence( attackerBodySequence, attackerViewBody, attacker )
	}

	if ( targetViewBody != null )
	{
		targetBodySequence.useAnimatedRefAttachment = true
		thread FirstPersonSequence( targetBodySequence, targetViewBody, target )
	}

	if ( isAttackerRef )
	{
		thread FirstPersonSequence( attackerSequence, attacker )
		waitthread FirstPersonSequence( targetSequence, target, attacker )
	}
	else
	{
		thread FirstPersonSequence( targetSequence, target )
		waitthread FirstPersonSequence( attackerSequence, attacker, target )
	}
}

// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
// needs to end execution if target respawned
void function EndThreadOnPlayerRespawn( entity player )
{
	player.EndSignal( "RespawnMe" )
	player.EndSignal( "OnRespawned" )
	player.EndSignal( "PlayerRespawnStarted" )
}
//

void function Execution_ShowBattery( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) ) //Out of bounds
		return
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity batteryContainer = titanSoul.soul.batteryContainer
	Assert( IsValid( titanSoul.soul.batteryContainer ), " need to find the repro for this" )
	if ( !IsValid( titanSoul.soul.batteryContainer ) )
		return

	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up_idle" )  )
}

void function Execution_HideBattery( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) ) //Out of bounds
		return
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity batteryContainer = titanSoul.soul.batteryContainer
	Assert( IsValid( titanSoul.soul.batteryContainer ), " need to find the repro for this" )
	if ( !IsValid( titanSoul.soul.batteryContainer ) )
		return

	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down_idle" )  )
	EmitSoundOnEntity( batteryContainer, GetAudioFromAlias( titanType, "rodeo_battery_steal_3p" ) )
}

void function Execution_GivePilotBattery( entity fakePilotModel )
{
	entity tempBattery3p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery3p.SetParent( fakePilotModel, "R_HAND", false, 0.0 )
	tempBattery3p.RemoveFromSpatialPartition()
	tempBattery3p.Show()
	Battery_StartFX( tempBattery3p )
}


void function Execution_BatteryStealJumpJets( entity fakePilotModel )
{
	int attachmentIndex = fakePilotModel.LookupAttachment( "vent_left" )
	int fxIndex = GetParticleSystemIndex( TEAM_JUMPJET_DBL )
	StartParticleEffectOnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )

	attachmentIndex = fakePilotModel.LookupAttachment( "vent_right" )
	StartParticleEffectOnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
}

/*
void function RodeoBatteryRemoval( entity pilot )
{
	entity titan = GetTitanBeingRodeoed( pilot )
	if ( !IsValid( titan ) )
		return

	// THROW RODEO RIDER OFF
	entity soul = titan.GetTitanSoul()
	string titanType = GetSoulTitanSubClass( soul )

	soul.SetLastRodeoHitTime( Time() )

	RodeoBatteryPackRemovalDamage( pilot, titan, soul )

	if ( !PlayerHasBattery( pilot ) )
	{
		AddPlayerScore( pilot, "PilotBatteryStolen" )
		entity battery = Rodeo_CreateBatteryPack( titan )
		Rodeo_PilotPicksUpBattery( pilot, battery )
		thread BatteryThiefHighlight( pilot )

		if ( titan.IsPlayer() )
		{
			EmitSoundOnEntityOnlyToPlayer( titan, titan, TITAN_GOT_BATTERY_RIPPED_SOUND ) //Consider playing this in world once we get sounds that aren't just notification beeps
		}
	}

	vector direction = CalculateDirectionToThrowOffBatteryThief( pilot, titan )

	ThrowRiderOff( pilot, titan, direction ) //This signals RodeoOver
}
*/

void function ClearParentOnDeathOrDestroy( entity clearParentEntity, entity onDeathOrDestroyEntity )
{
	Assert( IsValid( clearParentEntity ) )
	Assert( IsAlive( clearParentEntity ) )

	Assert( IsValid( onDeathOrDestroyEntity ) )
	Assert( IsAlive( onDeathOrDestroyEntity ) )

	OnThreadEnd(
		function() : ( clearParentEntity, onDeathOrDestroyEntity )
		{
			if ( IsValid( clearParentEntity ) )
			{
				clearParentEntity.ClearParent()

				if ( IsValid( onDeathOrDestroyEntity ) )
				{
					PutEntityInSafeSpot( clearParentEntity, onDeathOrDestroyEntity, null, onDeathOrDestroyEntity.GetOrigin(), clearParentEntity.GetOrigin() )
				}
			}
		}
	)

	onDeathOrDestroyEntity.EndSignal( "OnDeath" )
	onDeathOrDestroyEntity.WaitSignal( "OnDestroy" )
}

void function PredatorMeleeKilledRagdoll( entity titan )
{
	// vanilla predator cannon execution will leave a body
	// seems they fix the player ragdoll exploit
	if ( !titan.IsPlayer() ) // player's forceRagdollDeath will never gets cleared, which is bad
		titan.e.forceRagdollDeath = true
}

void function MeleePinkMistFakeBody( entity target )
{
	target.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

void function TitanLostArm( entity titan )
{
	table e = expect table( GetOptionalAnimEventVar( titan, "lost_arm" ) )

	e.lostArm = true
}

void function MeleeKilledRagdoll( entity titan ) // this is actually "pilot" inside the titan 
{
	entity attacker = expect entity( GetOptionalAnimEventVar( titan, "melee_killed_ragdoll" ) )

	if ( !IsValid( attacker ) )
		return
	if( !IsAlive( titan ) )
	{
		if( !titan.IsPlayer() )
			return
		titan = titan.GetPetTitan()
		if( IsAlive( titan ) )
			titan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
	}
	titan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
	titan.SetContinueAnimatingAfterRagdoll( true )
	titan.BecomeRagdoll( < 0, 0, 0 >, false )
}

void function OnNPCTitanDeath( entity titan, var damageInfo ) //Debug function, for bug 129802
{
	PrintFunc()
}

void function OnNPCTitanSignalDeath( entity titan ) //Debug function, for bug 129802
{
	PrintFunc()

	titan.WaitSignal( "OnDeath" )

	printt( "titan : " + titan + " recieved OnDeath Signal in OnNPCTitanSignalDeath" )
}


void function Northstar_Rocket_Pod_Left( entity guy )
{
	entity victim = expect entity( GetOptionalAnimEventVar( guy, "rocket_pod_fire_left" ) )
	// defensive fixes here, for ronin usage
	//Rocket_Pod( guy, "muzzle_flash", victim )
	string tag = "muzzle_flash" // default, left rocket pod
	int attachID = guy.LookupAttachment( tag )
	if ( attachID <= 0 ) // not valid!
	{
		tag = "HAND_L" // try to use left hand
		attachID = guy.LookupAttachment( tag )
		if ( attachID <= 0 ) // still not valid!
			return
	}
	Rocket_Pod( guy, tag, victim )
}

void function Northstar_Rocket_Pod_Right( entity guy )
{
	entity victim = expect entity( GetOptionalAnimEventVar( guy, "rocket_pod_fire_right" ) )
	// defensive fixes here, for ronin usage
	//Rocket_Pod( guy, "muzzle_flash2", victim )
	string tag = "muzzle_flash2" // default, right rocket pod
	int attachID = guy.LookupAttachment( tag )
	if ( attachID <= 0 ) // not valid!
	{
		tag = "HAND_R" // try to use right hand
		attachID = guy.LookupAttachment( tag )
		if ( attachID <= 0 ) // still not valid!
			return
	}
	Rocket_Pod( guy, tag, victim )
}

void function Rocket_Pod( entity guy, string tag, entity victim )
{
	entity oldOffhandWeapon = guy.GetOffhandWeapon( 0 )
	guy.TakeOffhandWeapon( 0 )
	guy.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", 0, [ "northstar_prime_execution" ] )

	entity newOffhandWeapon = guy.GetOffhandWeapon( 0 )
	int attachID = guy.LookupAttachment( tag )
	vector angles = guy.GetAttachmentAngles( attachID )
	WeaponPrimaryAttackParams params
	params.pos = guy.GetAttachmentOrigin( attachID )
	params.dir = AnglesToForward( angles )

	if ( IsAlive( victim ) && victim.IsTitan() )
	{
		vector victimTagPos = victim.GetAttachmentOrigin( victim.LookupAttachment( "CHESTFOCUS" ) ) + RandomVec( 30 )
		params.dir = Normalize( victimTagPos - params.pos )
		StartParticleEffectInWorld(GetParticleSystemIndex( $"P_muzzleflash_predator" ), params.pos, VectorToAngles( params.dir ) )
	}

	// DebugDrawSphere(params.pos, 10, 255,0,0, true, 1.0 )
	// DebugDrawLine( params.pos, params.pos + params.dir*200, 255,0,0, true, 1.0 )

	thread OnWeaponPrimaryAttack_titanweapon_salvo_rockets( newOffhandWeapon, params )

	guy.TakeOffhandWeapon( 0 )

	if ( oldOffhandWeapon )
 		guy.GiveOffhandWeapon( oldOffhandWeapon.GetWeaponClassName(), 0, oldOffhandWeapon.GetMods() )
}


////////////////////
///// MODIFIED /////
////////////////////
#if MP
void function ExecutedTitanDropWeapon( entity titan )
{
	thread ExecutedTitanDropWeapon_Threaded( titan )
}

void function ExecutedTitanDropWeapon_Threaded( entity titan )
{
	if ( titan.GetMainWeapons().len() == 0 )
		return

	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" ) // if titan won't drop weapon on being executed, will be handled by OnTitanKilled()
	
	table results = {}
	results.droppedWeapon <- false

	// create weaponProp here, to prevent messed up by AE_DROP_WEAPON, hide it for now
	if ( !TitanPick_ShouldTitanDropWeapon( titan ) )
		return
	entity weaponProp = TitanPick_TitanDropWeapon( titan )
	if ( !IsValid( weaponProp ) )
		return
	weaponProp.NotSolid() // prevent it mess up execution
	weaponProp.Hide()
	weaponProp.UnsetUsable()
	// don't drop weapon again for this soul
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, false )

	OnThreadEnd
	(
		function(): ( weaponProp, results )
		{
			if ( IsValid( weaponProp ) )
			{
				if ( results.droppedWeapon ) // dropped another weapon in this func?
				{
					//print( "should destroy existing weaponProp!" )
					weaponProp.Destroy()
					return
				}
				// show weaponProp again
				weaponProp.Solid()
				weaponProp.Show()
				weaponProp.SetUsable()
			}
		}
	)

	entity weaponToDrop = titan.GetMainWeapons()[0]
	string name = weaponToDrop.GetWeaponClassName()
	array<string> mods = weaponToDrop.GetMods()
	int skin = weaponToDrop.GetSkin()
	int camo = weaponToDrop.GetCamo()
	int ammoLeft = 0
	try { ammoLeft = weaponToDrop.GetWeaponPrimaryClipCount() }
    catch(ex) {}

	// manually handle AE_DROP_WEAPON, wait for this weapon being dropped, then create a new one and drop it
	while ( TitanHasWeaponEntity( titan, weaponToDrop ) )
		WaitFrame()
	
	// AE_DROP_WEAPON triggered! re-enable weapon drop
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, true )

	//print( "TitanPick_ShouldTitanDropWeapon( titan ): " + string( TitanPick_ShouldTitanDropWeapon( titan ) ) )
	if ( !TitanPick_ShouldTitanDropWeapon( titan ) )
		return

	//print( "Titan dropped weapon for being executed" )
	// temp give a weapon
	foreach ( entity weapon in titan.GetMainWeapons() )
		titan.TakeWeapon( weapon.GetWeaponClassName() )
	entity newWeapon = titan.GiveWeapon( name, mods )
	newWeapon.SetSkin( skin )
	newWeapon.SetCamo( camo )
	try { newWeapon.SetWeaponPrimaryClipCount( ammoLeft ) }
	catch(ex1) {}

	TitanPick_TitanDropWeapon( titan ) // drop this weapon
	results.droppedWeapon = true // mark as we dropped weapon!
	newWeapon.Destroy()

	// don't drop weapon again for this soul
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, false )
}

bool function TitanHasWeaponEntity( entity titan, entity weapon )
{
	foreach ( entity holdingWeapon in titan.GetMainWeapons() )
	{
		//print( "holdingWeapon: " + string( holdingWeapon ) )
		//print( "weapon: " + string( weapon ) )
		if ( holdingWeapon == weapon )
			return true
	}
	return false
}
#endif

//
void function MeleeSyncedTitan_ExecutionNotInvulnerable( bool notInvulnerable )
{
	file.titanExecutionNotInvulnerable = notInvulnerable
}

void function MeleeSyncedTitan_SetSoulDoClassicExecution( entity titanSoul, bool doClassic )
{
	if ( !( titanSoul in file.soulDoClassicExecution ) )
		file.soulDoClassicExecution[ titanSoul ] <- false // default value
	file.soulDoClassicExecution[ titanSoul ] = doClassic
}

bool function GetSoulDoClassicExecution( entity titanSoul )
{
	if ( !( titanSoul in file.soulDoClassicExecution ) )
		return false // default value
	return file.soulDoClassicExecution[ titanSoul ]
}

void function MeleeSyncedTitan_DisableVanguardKitExecution( bool disable )
{
	file.disableVanguardKit = disable
}

void function MeleeSyncedTitan_SetSoulUseExecutionCallback( entity titanSoul, bool useCallback )
{
	if ( !( titanSoul in file.soulUseExecutionCallback ) )
		file.soulUseExecutionCallback[ titanSoul ] <- true // default value
	file.soulUseExecutionCallback[ titanSoul ] = useCallback
}

bool function GetSoulUseExecutionCallback( entity titanSoul )
{
	if ( !( titanSoul in file.soulUseExecutionCallback ) )
		return true // default value
	return file.soulUseExecutionCallback[ titanSoul ]
}

void function MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( entity titanSoul, bool useCallback )
{
	if ( !( titanSoul in file.soulShouldReplaceLoadout ) )
		file.soulShouldReplaceLoadout[ titanSoul ] <- false // default value
	file.soulShouldReplaceLoadout[ titanSoul ] = useCallback
}

bool function GetSoulReplaceLoadoutOnExecution( entity titanSoul )
{
	if ( !( titanSoul in file.soulShouldReplaceLoadout ) )
		return false // default value
	return file.soulShouldReplaceLoadout[ titanSoul ]
}

// shared with sh_melee_titan.gnut
void function MeleeSyncedTitan_SetSoulCanBeExecuted( entity soul, bool canBeExecuted )
{
	if ( !( soul in file.soulCanBeExecuted ) )
		file.soulCanBeExecuted[ soul ] <- true // default value
	file.soulCanBeExecuted[ soul ] = canBeExecuted
}

bool function MeleeSyncedTitan_SoulCanBeExecuted( entity soul )
{
	if ( !IsValid( soul ) ) // soul invalid?
		return false
	if ( !( soul in file.soulCanBeExecuted ) ) // no settings
		return true // default value
	return file.soulCanBeExecuted[ soul ]
}
///////////////
///// END /////
///////////////