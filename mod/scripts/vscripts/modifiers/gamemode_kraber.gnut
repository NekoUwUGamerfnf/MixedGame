global function Modded_Gamemode_Kraber_Init

const string DEFAULT_REPLACEMENT_TACTICAL = "mp_ability_grapple"
const array<string> TACTICALS_LIST = 
[
    "mp_ability_heal", 
    "mp_ability_grapple", 
    "mp_ability_holopilot", 
    "mp_weapon_grenade_sonar"
]

// for ordnance_boost
const string DEFAULT_REPLACEMENT_ORDNANCE = "mp_weapon_satchel"
const array<string> ORDNANCES_LIST =
[
    "mp_weapon_grenade_gravity",
    "mp_weapon_satchel",
    "mp_weapon_frag_grenade"
]

const array<string> KRABER_PLAYLIST = 
[
    "mp_glitch",
    "mp_colony02",
    "mp_wargames",
    "mp_eden",
    "mp_drydock",
    "mp_black_water_canal",
    "mp_thaw",
    "mp_grave",
    "mp_homestead",
    "mp_forwardbase_kodai",
    "mp_angel_city",
]

const bool INFINITE_CLIP = false
const bool ENABLE_CHARGE_RIFLE = true
const bool GRAPPLE_PLAYER_ALLOWED = false
const bool ENABLE_RESPAWN_SPEED = true
const bool ORDNANCE_BOOST = true

void function Modded_Gamemode_Kraber_Init()
{
    HackedDeath_SetEnabled( true ) // powerful thing, no any screen blur and flash on death

    // enable normal settings, since this modifier didn't change so many things
    Nessie_Normal_Settings_NonTitan_Init()
    SetDeathCamLengthForced( 2.0 ) // shorter death cam, maybe not needed

    // gamemode_kraber specific settings
    Melee_SetSyncedMeleeNoLimit( true ) // enable execution
	SetShouldFUCKOFFAWALL( true ) // no awall allowed
    SetOverridesBaseForcedPlayList( true ) // overrides base forced playlist
    SetWeaponDropsEnabled( false ) // don't let players pickup other kraber
    //SetBattleChatterEnableToAll( true ) // play chatter to their enemies

    // funny!!!
    //SetFriendlyFireOn( true )
    //MeleeSyncedDecoy_EnableExecutingOwnedDecoy( true )
    //MeleeSyncedDecoy_EnableExecutingProps( true )
    Nessie_SetHoloSprayEnabled( true ) // kraber mode has no ordnances, so we replace them with holosprays
    
    Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
    AddSpawnCallback( "player", OnPlayerEntSpawned ) // ordnance boost
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_GameStateEnter( eGameState.Playing, OnGameStart )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
	AddCallback_GameStateEnter( eGameState.Postmatch, OnGamePostmatch )

    // marvin
    AddCallback_GameStateEnter( eGameState.Prematch, OnGamePrematch )
}

void function OnPlayerEntSpawned( entity player )
{
    if ( ORDNANCE_BOOST )
        AddEntityCallback_OnDamaged( player, OrdnanceBoostOnPlayerDamaged )
}

void function OnPlayerRespawned( entity player )
{
    // respawn not giving loadout, which will mess things up
	//GiveKraber( player )
    if ( !GRAPPLE_PLAYER_ALLOWED )
        DisableGrappleContent( player ) // make players unable to be grappled
    DisableBoostBar( player )
    if ( ENABLE_RESPAWN_SPEED && GetGameState() >= eGameState.Playing )
        PlayerRespawnSpeedBoost( player )
}

void function OnPlayerChangeLoadout( entity player , PilotLoadoutDef p)
{
	GiveKraber( player )
    //DisableBoostBar( player ) // no need to reset boost everytime player try to change loadout
}

void function OnGamePrematch()
{
    Nessie_CreateMenuMarvin()
}

void function OnGameStart()
{
    SetPlayerDeathsHidden( true ) // temp for some situations
    // change settings here to prevent being overwriten
    // be sure to set much higher prop limit
    Nessie_SetWorldMaxNessieCount( 80 )
    Rodeo_SetWorldBatteryMaxCount( 80 )
    HoloSpray_SetMaxCountPerPlayer( 4 )

    foreach( entity player in GetPlayerArray() )
        DisableBoostBar( player ) // starting will re-enable player's boost, lets set it to disable again

    if ( INFINITE_CLIP )
        RestorePlayerKraberClip()
}

void function OnGamePostmatch()
{
    KraberForcedPlaylist()
}

// utilities
void function DisableBoostBar( entity player )
{
    thread DisableBoostBar_Threaded( player )
}

void function DisableBoostBar_Threaded( entity player )
{
    WaitFrame() // wait for player earn meter being set up
    if( IsValid( player ) )
        PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

void function GiveKraber( entity player )
{
    player.TakeWeaponNow( "melee_pilot_emptyhanded" )

    array<string> allowedWeapons = [ "mp_weapon_sniper" ]
    if ( ENABLE_CHARGE_RIFLE )
        allowedWeapons.append( "mp_weapon_defender" )
    array<string> defaultMods = ["pas_fast_ads", "extended_ammo"]
    if ( INFINITE_CLIP )
        defaultMods = ["pas_fast_ads", "ricochet"]
    
    bool hasKraber = PlayerHasWeapon( player, "mp_weapon_sniper" )
	foreach ( entity weapon in player.GetMainWeapons() )
    {
        string weaponName = weapon.GetWeaponClassName()

        if( !allowedWeapons.contains( weaponName ) )
        {
            player.TakeWeaponNow( weapon.GetWeaponClassName() )

            if ( !hasKraber )
            {
                player.GiveWeapon( "mp_weapon_sniper", defaultMods )
                hasKraber = true
            }
        }

        if ( ENABLE_CHARGE_RIFLE )
        {
            if( weaponName == "mp_weapon_defender" )
            {
                if ( weapon.HasMod( "extended_ammo" ) )
                {
                    weapon.RemoveMod( "extended_ammo" )
                    weapon.SetWeaponPrimaryAmmoCount( weapon.GetWeaponSettingInt( eWeaponVar.ammo_default_total ) ) // update clip
                }
                
                if ( INFINITE_CLIP )
                    weapon.AddMod( "at_unlimited_ammo" ) // unlimited ammo for quick charge
            }
        }
    }

	foreach( entity weapon in player.GetOffhandWeapons() )
	{
        array<string> availableOffhands = TACTICALS_LIST
        // ordnance boost
        if ( ORDNANCE_BOOST )
            availableOffhands.extend( ORDNANCES_LIST )

		if( !availableOffhands.contains( weapon.GetWeaponClassName() ) )
			player.TakeWeaponNow( weapon.GetWeaponClassName() )
	}
    if( !IsValid( player.GetOffhandWeapon( OFFHAND_SPECIAL ) ) )
        player.GiveOffhandWeapon( DEFAULT_REPLACEMENT_TACTICAL, OFFHAND_SPECIAL )
    // ordnance boost
    if ( ORDNANCE_BOOST )
    {
        entity ordnance = player.GetOffhandWeapon( OFFHAND_ORDNANCE )
        if ( !IsValid( ordnance ) )
            player.GiveOffhandWeapon( DEFAULT_REPLACEMENT_ORDNANCE, OFFHAND_ORDNANCE, ["kraber_ordnance"] )
        else
        {
            ordnance.AddMod( "kraber_ordnance" )
            try { ordnance.SetWeaponPrimaryClipCount( ordnance.GetWeaponPrimaryClipCountMax() ) }
            catch (ex) {}
        }
    }
    
    SetPlayerCooldowns( player ) // update cooldowns again
}

void function DisableGrappleContent( entity player )
{
    if( IsAlive( player ) )
        player.kv.contents = (int(player.kv.contents) | CONTENTS_NOGRAPPLE) // make player unable to be grappled
}

void function EnableGrappleContent( entity player )
{
    player.kv.contents = (int(player.kv.contents) & ~CONTENTS_NOGRAPPLE) // remove unable to be grappled content
}

const float RESPAWN_SPEED_BOOST_DURATION_MAX = 5.0
const float RESPAWN_SPEED_BOOST_SEVERITY = 0.4 // insanly high
const float RESPAWN_SPEED_BOOST_DEACTIVATE_RANGE = 1500 // if we have enemy within this range we stop the speed boost

void function PlayerRespawnSpeedBoost( entity player )
{
    thread PlayerRespawnSpeedBoost_Threaded( player )
}

void function PlayerRespawnSpeedBoost_Threaded( entity player )
{
    if ( HasEnemyInBoostDeactivateRange( player ) )
        return

    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    //Remote_CallFunction_Replay( player, "ServerCallback_SpottingHighlight" ) // temp, just for fun, will highlight predicted fp proxy
    EmitSoundOnEntityOnlyToPlayer( player, player, "UI_MapPing_Victim_1P" ) // the spottingHighlight will keep player's predicted proxy highlighted, which will cause other highlights to disappear while it's shown
    int effect = StatusEffect_AddTimed( player, eStatusEffect.speed_boost, RESPAWN_SPEED_BOOST_SEVERITY, RESPAWN_SPEED_BOOST_DURATION_MAX, 0 )
    int stimVisual = StatusEffect_AddTimed( player, eStatusEffect.stim_visual_effect, 1.0, 9999, 9999 )

    OnThreadEnd
    (
        function(): ( player, stimVisual )
        {
            if ( IsValid( player ) )
                StatusEffect_Stop( player, stimVisual )
        }
    )

    float endTime = Time() + RESPAWN_SPEED_BOOST_DURATION_MAX
    while ( Time() <= endTime )
    {
        WaitFrame()
       
        if ( HasEnemyInBoostDeactivateRange( player ) ) // found enemy...
        {
            StatusEffect_Stop( player, effect )
            StatusEffect_Stop( player, stimVisual )
            return
        }
    }
}

bool function HasEnemyInBoostDeactivateRange( entity player )
{
    array<entity> enemies = GetPlayerArrayOfEnemies_Alive( player.GetTeam() )
    if ( enemies.len() == 0 )
        return false
    entity closestEnemy = GetClosest( enemies, player.GetOrigin(), RESPAWN_SPEED_BOOST_DEACTIVATE_RANGE )
    if ( IsValid( closestEnemy ) )
        return true
    return false
}

void function RestorePlayerKraberClip()
{
    thread RestorePlayerKraberClip_Threaded()
}

void function RestorePlayerKraberClip_Threaded()
{
    while( GetGameState() == eGameState.Playing )
    {
        foreach ( entity player in GetPlayerArray() )
        {
            entity weapon = player.GetActiveWeapon()
            if ( IsValid( weapon ) )
            {
                if ( weapon.GetWeaponClassName() == "mp_weapon_sniper" )
                    weapon.SetWeaponPrimaryClipCount( weapon.GetWeaponPrimaryClipCountMax() )
            }
        }

        WaitFrame()
    }
}

// ordnance boost
void function OrdnanceBoostOnPlayerDamaged( entity player, var damageInfo )
{
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    if ( !IsValid( inflictor ) )
        return
    if ( !inflictor.IsProjectile() )
        return
    array<string> mods = inflictor.ProjectileGetMods()
    if ( !mods.contains( "kraber_ordnance" ) )
        return
    entity attacker = DamageInfo_GetAttacker( damageInfo )
    if ( attacker != player ) // not attacked by self damage
        DamageInfo_SetDamage( damageInfo, 0 )
    else // self damage
    {
        if ( DamageInfo_GetDamage( damageInfo ) >= player.GetMaxHealth() ) // this will kill the player
            DamageInfo_SetDamage( damageInfo, player.GetMaxHealth() - 1 ) // save player if they're with max health
    }
}

void function KraberForcedPlaylist()
{
    thread KraberForcedPlaylist_Threaded()
}

void function KraberForcedPlaylist_Threaded()
{
    wait 5
    
    array<string> curPlayList = KRABER_PLAYLIST
    int mapIndex = curPlayList.find( GetMapName() )
    mapIndex += 1 // next map index
	if( mapIndex == curPlayList.len() ) // reached last map?
		mapIndex = 0
	string nextMap = curPlayList[mapIndex]

    ServerCommand( "map " + nextMap )
}
