global function MpAbilityJetPack_Init

#if SERVER
global function SignalJetPackStart
global function JetPackThink
#endif

const string JET_PACK_WEAPON = "mp_titanability_hover" // button callback handle in weapon's script
global const string JET_PACK_MOD = "jet_pack"
const float JET_PACK_BURST_VELOCITY_VERTICAL = 300 // shouldn't set this very high
const float JET_PACK_BURST_VELOCITY_HORIZONAL = 320 // this can be bit higher
const float JET_PACK_BURST_TO_LIFT_DELAY = 0.4 // basically no need to change this
const float JET_PACK_LIFT_SPEED_VERTICAL = 300
const float JET_PACK_LIFT_ACCELERATION_VERTICAL = 100
// reworked over here, using airSpeed for better behavior
//const float JET_PACK_LIFT_SPEED_HORIZONAL = 250 // actual behaviors not this high, so set higher.
const float JET_PACK_LIFT_SPEED_HORIZONAL = 280 // player's air speed, also air speed limit
const float JET_PACK_LIFT_ACCELERATION_HORIZONAL = 3000 // player's air acceleration, for better control
const float JET_PACK_GLIDE_GRAVITY_SCALE = 0.6
const float JET_PACK_GLIDE_DURATION = 0.5
const float JET_PACK_DEACCELERATETION_HORIZONAL = 70 // takes 4 ticks(.4s) to de-accelerate if player have no input
const float JET_PACK_DEACCELERATETION_VERTICAL = 50 // takes 6 ticks(.6s) to de-accelerate if player try to hover
const float JET_PACK_HOVER_VERTICAL_SPEED_SCALE = 0.1 // hover speed scale

const float HOVER_SOUND_DURATION = 2.2 // should relap a sound if ends, no need to change

const int JET_PACK_AMMO_REDUCE_PER_BURST = 25
const int JET_PACK_AMMO_REDUCE_PER_TICK = 3

// for passive_jetpack! less effective since you still have tacticals normally
const int JET_PACK_AMMO_REDUCE_PER_BURST_PASSIVE = 55
const int JET_PACK_AMMO_REDUCE_PER_TICK_PASSIVE = 8

// grunt mode flyer, much less effective
const float JET_PACK_BURST_VELOCITY_VERTICAL_GRUNT = 180 // shouldn't set this very high
const float JET_PACK_BURST_VELOCITY_HORIZONAL_GRUNT = 200 // this can be bit higher
const float JET_PACK_LIFT_SPEED_VERTICAL_GRUNT = 150
const float JET_PACK_LIFT_SPEED_HORIZONAL_GRUNT = 150 // actual behaviors not this high, so set higher.
const float JET_PACK_LIFT_ACCELERATION_HORIZONAL_GRUNT = 900 // higher for better control
const float JET_PACK_DEACCELERATETION_HORIZONAL_GRUNT = 30 // takes 5 ticks(.5s) to de-accelerate if player have no input
const float JET_PACK_DEACCELERATETION_VERTICAL_GRUNT = 30 // takes 5 ticks(.5s) to de-accelerate if player try to hover

const int JET_PACK_AMMO_REDUCE_PER_BURST_GRUNT = 40 // higher so player won't have bad looping sound
const int JET_PACK_AMMO_REDUCE_PER_TICK_GRUNT = 5

// use this function to add callback to movements
// AddPlayerMovementEventCallback( entity player, int playerMovementEvent, void functionref( entity player ) callbackFunc )

struct
{
    table< entity, bool > playerJumpUsedTable // for "disable_doublejump" conditions
    table< entity, bool > playerDoubleJumpUsedTable // for activating jet packs
} file

void function MpAbilityJetPack_Init()
{
#if SERVER
    RegisterSignal( "ActivateJetPack" )
    RegisterSignal( "JetPackThinkStart" )
    RegisterSignal( "JetPackThinkEnd" )
    RegisterSignal( "JetPackBurst" )
    RegisterSignal( "JetPackLift" )
    RegisterSignal( "StartGlideThink" )
    RegisterSignal( "StartFreeFallSound" )
    RegisterSignal( "ConsumeJetPackAmmo" ) // this should signal a table, but it requires file to be untyped
    /* //jet pack ammo table:
        table
        {
            float ammoReduce
        }
    */
    AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPilotGetLoadout )
#endif
}

#if SERVER
void function OnClientConnected( entity player )
{
    // using OnWeaponOwnerChanged() now, add this after player get the jet pack weapon
    //AddButtonPressedPlayerInputCallback( player, IN_JUMP, SignalJetPackStart )
    //AddPlayerMovementEventCallback( entity player, int playerMovementEvent, void functionref( entity player ) callbackFunc )

    // init
    file.playerJumpUsedTable[ player ] <- false
    file.playerDoubleJumpUsedTable[ player ] <- false
}

bool function PlayerCanDoubleJump( entity player )
{
    return !player.GetPlayerSettingsMods().contains( "disable_doublejump" )
}

void function PlayerJumpUsed( entity player )
{
    if ( PlayerCanDoubleJump( player ) )
        return
    thread PlayerJumpUsed_Threaded( player )
}

void function PlayerJumpUsed_Threaded( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    WaitFrame() // do a wait!
    if( !player.IsOnGround() ) // still not touch ground
        file.playerJumpUsedTable[ player ] = true // consider jump used, not supporting multiple jumps unfortunately
}

void function PlayerDoubleJumpUsed( entity player )
{
    thread PlayerDoubleJumpUsed_Threaded( player )
}

void function PlayerDoubleJumpUsed_Threaded( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    WaitFrame() // do a wait!
    if( !player.IsOnGround() ) // still not touch ground
        file.playerDoubleJumpUsedTable[ player ] = true // consider double jump used, not supporting multiple jumps unfortunately
}

void function PlayerJumpRestored( entity player )
{
    file.playerJumpUsedTable[ player ] = false
    file.playerDoubleJumpUsedTable[ player ] = false // consider double jump restored, not supporting multiple jumps unfortunately
}

void function SignalJetPackStart( entity player )
{
    // leave checks here, valkery uses passives but I don't have that
    //print( "Player tried to signal jetpack!" )

    // for better control
    //if( !player.IsInputCommandHeld( IN_SPEED ) ) // for better control, use a combo to activate 
    //    return
    bool shouldStartJetPack = true
    if( !file.playerDoubleJumpUsedTable[ player ] && PlayerCanDoubleJump( player ) ) // double jump not used yet!
        shouldStartJetPack = false
    if( !file.playerJumpUsedTable[ player ] && !PlayerCanDoubleJump( player ) ) // no doublejump, but player haven't used their jump!
        shouldStartJetPack = false
    // normal checks
    if( player.IsPhaseShifted() ||
        player.IsWallHanging() ||
        player.IsWallRunning() ||
        player.IsZiplining() ||
        player.IsOnGround() ||
        player.IsTraversing() ||
        player.GetParent() != null )
        shouldStartJetPack = false

    if ( !shouldStartJetPack )
        return

    player.Signal( "ActivateJetPack" )
}

void function OnPilotGetLoadout( entity player, PilotLoadoutDef p )
{
    // using OnWeaponOwnerChanged() now, check this after player get the jet pack weapon
    //thread DelayedCheckJetPackAvailable( player )
}

void function JetPackThink( entity player, entity weapon )
{
    if( !player.IsPlayer() )
        return
    player.Signal( "JetPackThinkStart" )
    player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )
    player.EndSignal( "JetPackThinkStart" )
    player.EndSignal( "JetPackThinkEnd" )
    weapon.EndSignal( "OnDestroy" )
    
    file.playerDoubleJumpUsedTable[ player ] = false // always reset this
    // single jump callbacks
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, PlayerJumpUsed )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.LEAVE_GROUND, PlayerJumpUsed )
    // double jump callbacks
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, PlayerDoubleJumpUsed )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, PlayerJumpRestored )
    AddButtonPressedPlayerInputCallback( player, IN_JUMP, SignalJetPackStart )
    OnThreadEnd(
        function():( player )
        {
            if( IsValid( player ) )
            {
                RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, PlayerJumpUsed )
                RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.LEAVE_GROUND, PlayerJumpUsed )
                RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, PlayerDoubleJumpUsed )
                RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, PlayerJumpRestored )
                RemoveButtonPressedPlayerInputCallback( player, IN_JUMP, SignalJetPackStart )
            }    
        }
    )

    thread JetPackAmmoThink( weapon )
    while( true )
    {
        player.WaitSignal( "ActivateJetPack" )
        waitthread JetPackActivateThink( player, weapon )
    }
}

void function JetPackActivateThink( entity player, entity weapon )
{
    int currentAmmo = weapon.GetWeaponPrimaryClipCount() // don't run anything if no enough ammo
    
    if( currentAmmo <= 1 )
    {
        EmitSoundOnEntityOnlyToPlayer( player, player, "titan_dryfire" )
        return
    }

    table savedStatus = {}
    savedStatus.airSpeed <- player.kv.airSpeed
    savedStatus.airAccel <- player.kv.airAcceleration
    //savedStatus.gravity <- player.kv.gravity // can't find a better way to store gravity

    player.Signal( "OnPrimaryAttack" ) // should signal this to end loadout grace period
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    weapon.EndSignal( "OnDestroy" )

    player.HolsterWeapon() // defensive fix
    
    array<entity> fx

	OnThreadEnd(
		function () : ( player, fx, savedStatus )
		{
            if( IsValid( player ) )
            {
                StopSoundOnEntity( player, "Boost_Hover_Body_1P" )
                StopSoundOnEntity( player, "Boost_Hover_Body_3P" )
                EmitSoundOnEntityOnlyToPlayer( player, player, "Boost_Hover_End_1P" )
                EmitSoundOnEntityExceptToPlayer( player, player, "Boost_Hover_End_3P" )

                player.kv.gravity = 0.0 // defensive fix
                player.DeployWeapon() // defensive fix
                player.Server_TurnOffhandWeaponsDisabledOff() // this can turn on offhand weapons
                thread JetPackGlideThink( player ) // do need a glide, or player will fall very fast
                // annoying sound, no need to play
                //thread JumpJetFreeFallSound( player )

                // recover behavior
                //print( "resetting airSpeed to" + string ( savedStatus.airSpeed ) )
                //print( "resetting airAcceleration to " + string ( savedStatus.airAccel ) )
                player.kv.airSpeed = savedStatus.airSpeed
                player.kv.airAcceleration = savedStatus.airAccel
            }
			foreach ( effect in fx )
			{
				if ( !IsValid( effect ) )
					continue

				effect.ClearParent()
				effect.Destroy()
			}
		}
	)

    if( player.LookupAttachment( "vent_center" ) > 0 )
    {
        entity fxSmokeCenter = PlayFXOnEntity( $"Rocket_Smoke_Large", player, "vent_center" )
        //fxSmokeCenter.SetOwner( player )
        //fxSmokeCenter.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
        fx.append( fxSmokeCenter )
    }

    if( player.LookupAttachment( "vent_left_out" ) > 0 ) // was vent_left_back, this is better
    {
        // $"P_team_jet_hover_HLD" is good enough for both team players and owner themself
        entity fxJetLeft = PlayFXOnEntity( $"P_team_jet_hover_HLD", player, "vent_left_out" )
        fxJetLeft.SetOwner( player )
        SetTeam( fxJetLeft, player.GetTeam() )
        fxJetLeft.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY // owner can't see
        fx.append( fxJetLeft )
        
        //entity fxSmokeLeft = PlayFXOnEntity( $"wpn_grenade_frag_softball", player, "vent_left_out" )
        //fx.append( fxSmokeLeft )
    }

    if( player.LookupAttachment( "vent_right_out" ) > 0 ) // was vent_right_back, this is better
    {
        entity fxJetRight = PlayFXOnEntity( $"P_team_jet_hover_HLD", player, "vent_right_out" )
        fxJetRight.SetOwner( player )
        SetTeam( fxJetRight, player.GetTeam() )
        fxJetRight.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY // owner can't see
        fx.append( fxJetRight )

        //entity fxSmokeRight = PlayFXOnEntity( $"wpn_grenade_frag_softball", player, "vent_right_out" )
        //fx.append( fxSmokeRight )
    }

    EmitSoundOnEntityOnlyToPlayer( player, player, "Boost_Hover_Start_1P" )
    EmitSoundOnEntityExceptToPlayer( player, player, "Boost_Hover_Start_3P" )
    EmitSoundOnEntityOnlyToPlayer( player, player, "Boost_Hover_Body_1P" )
    EmitSoundOnEntityExceptToPlayer( player, player, "Boost_Hover_Body_3P" )

    // speed
    float burstVelHorizonal = JET_PACK_BURST_VELOCITY_HORIZONAL
    float burstVelVertical = JET_PACK_BURST_VELOCITY_VERTICAL
    float liftVelHorizonal = JET_PACK_LIFT_SPEED_HORIZONAL
    float liftAccelHorizonal = JET_PACK_LIFT_ACCELERATION_HORIZONAL
    float liftVelVertical = JET_PACK_LIFT_SPEED_VERTICAL
    float liftAccelVertical = JET_PACK_LIFT_ACCELERATION_VERTICAL
    float deAccelHorizonal = JET_PACK_DEACCELERATETION_HORIZONAL
    float deAccelVertical = JET_PACK_DEACCELERATETION_VERTICAL
    float hoverSpeedScale = JET_PACK_HOVER_VERTICAL_SPEED_SCALE
    // grunt speed
    if ( weapon.HasMod( "gm_flyer" ) )
    {
        burstVelHorizonal = JET_PACK_BURST_VELOCITY_HORIZONAL_GRUNT
        burstVelVertical = JET_PACK_BURST_VELOCITY_VERTICAL_GRUNT
        liftVelHorizonal = JET_PACK_LIFT_SPEED_HORIZONAL_GRUNT
        liftAccelHorizonal = JET_PACK_LIFT_ACCELERATION_HORIZONAL_GRUNT
        liftVelVertical = JET_PACK_LIFT_SPEED_VERTICAL_GRUNT
        deAccelHorizonal = JET_PACK_DEACCELERATETION_HORIZONAL_GRUNT
        deAccelVertical = JET_PACK_DEACCELERATETION_VERTICAL_GRUNT
    }

    // start burst: forced velocity for a while
    player.kv.gravity = 0.0001
    vector burstVector = GetVectorFromInput( player ) * burstVelHorizonal
    burstVector.z = burstVelVertical

    Signal( weapon, "JetPackBurst" )

    float startTime = Time()
    int soundRelapCount = 1

    float burstEndTime = startTime + JET_PACK_BURST_TO_LIFT_DELAY - 0.1
    while ( Time() < burstEndTime )
    {
        player.SetVelocity( burstVector )
        WaitFrame()
    }

    // start lifting
    player.kv.airSpeed = liftVelHorizonal
    player.kv.airAcceleration = liftAccelHorizonal
    while( true )
    {
        if( !player.IsInputCommandHeld( IN_JUMP ) ) // if player released jump button, stop this
            break
        currentAmmo = weapon.GetWeaponPrimaryClipCount()
        if( currentAmmo <= 1 )
        {
            EmitSoundOnEntityOnlyToPlayer( player, player, "titan_dryfire" )
            break
        }

        if( startTime + HOVER_SOUND_DURATION * soundRelapCount < Time() )
        {
            soundRelapCount += 1
            EmitSoundOnEntityOnlyToPlayer( player, player, "Boost_Hover_Body_1P" )
            EmitSoundOnEntityExceptToPlayer( player, player, "Boost_Hover_Body_3P" )
        }
        WaitFrame() // wait before triggers "continue"

        // return if player meets these behavior
        if( player.IsPhaseShifted() ||
            player.IsWallHanging() ||
            player.IsWallRunning() ||
            player.IsZiplining() ||
            player.IsOnGround() ||
            player.IsTraversing() ||
            player.GetParent() != null )
            return

        player.HolsterWeapon() // defensive fix
        player.Server_TurnOffhandWeaponsDisabledOn() // this can turn off offhand weapons
        player.kv.gravity = 0.0001 // defensive fix
        vector liftVector = player.GetVelocity() //GetVectorFromInput( player ) * liftVelHorizonal // pretty bad if you got high latency
        // hovering, more like valk's jecpack
        bool playerWantsToHover = player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE )
        if( playerWantsToHover )
        {
            float minLiftSpeed = liftVelVertical * hoverSpeedScale
            liftVector = GainVelocityVertical( liftVector, -deAccelVertical, minLiftSpeed )
        }
        else
        {
            liftVector = GainVelocityVertical( liftVector, liftAccelVertical )
            liftVector.z = min( liftVelVertical, liftVector.z )
        }
        // if player is on ground, you need at least 220 vel to make them off ground
        if ( !playerWantsToHover && player.IsOnGround() && liftVector.z < 220 )
            liftVector.z = 220
        liftVector = LimitVelocityHorizontal( liftVector, liftVelHorizonal ) // better handling control
        //print( "liftVector.z: " + string( liftVector.z ) )

        if ( PlayerNotDoingInput( player ) ) // player not doing any input?
            liftVector = GainVelocityHorizonal( liftVector, -deAccelHorizonal )

        player.SetVelocity( liftVector )

        Signal( weapon, "JetPackLift" )
    }
}

vector function LimitVelocityHorizontal( vector vel, float speed )
{
	vector horzVel = <vel.x, vel.y, 0>
	if ( Length( horzVel ) <= speed )
		return vel

	horzVel = Normalize( horzVel )
	horzVel *= speed
	vel.x = horzVel.x
	vel.y = horzVel.y
	return vel
}

bool function PlayerNotDoingInput( entity player )
{
	vector inputVec = GetVectorFromInput( player )
    vector inputAngs = VectorToAngles( inputVec )
    inputAngs.x = 0
    inputAngs.y -= 180
    //print( inputAngs )
	return inputAngs.x == 0 && inputAngs.y == 0
}

vector function GainVelocityHorizonal( vector vel, float speedGain, float minSpeed = 0.0 )
{
    vector horzVel = <vel.x, vel.y, 0>

    float speed = max( minSpeed, Length( horzVel ) + speedGain )
	horzVel = Normalize( horzVel )
	horzVel *= speed
	vel.x = horzVel.x
	vel.y = horzVel.y
	return vel
}

vector function GainVelocityVertical( vector vel, float speedGain, float minSpeed = 0.0 )
{
    vector vertiVel = <0, 0, vel.z>

    float speed = max( minSpeed, Length( vertiVel ) + speedGain )
	vertiVel = Normalize( vertiVel )
	vertiVel *= speed
    vertiVel.z = max( minSpeed, vertiVel.z )
	vel.z = vertiVel.z
	return vel
}

void function JetPackGlideThink( entity player )
{
    player.Signal( "StartGlideThink" )
    player.EndSignal( "StartGlideThink" )
    
    float startTime = Time()
    player.kv.gravity = JET_PACK_GLIDE_GRAVITY_SCALE
    while( true )
    {
        if( player.IsOnGround() )
            break
        if( startTime + JET_PACK_GLIDE_DURATION < Time() )
            break
        player.kv.gravity = JET_PACK_GLIDE_GRAVITY_SCALE // defensive fix

        WaitFrame()
    }
    if( IsValid( player ) ) // don't reset gravity if triggered another "StartGlideThink"
        player.kv.gravity = 0.0 // this is hardcoded!!!
}

void function JumpJetFreeFallSound( entity player )
{
    player.Signal( "StartFreeFallSound" )
    player.EndSignal( "StartFreeFallSound" )
    StopSoundOnEntity( player, "jumpjet_freefall_body_1p" )
    EmitSoundOnEntityOnlyToPlayer( player, player, "jumpjet_freefall_body_1p" )
    while( true )
    {
        if( player.IsOnGround() )
            break

        WaitFrame()
    }
    if( IsValid( player ) )
        StopSoundOnEntity( player, "jumpjet_freefall_body_1p" )
}

void function JetPackAmmoThink( entity weapon )
{
    weapon.EndSignal( "OnDestroy" )
    while( true )
    {
        table result = WaitSignal( weapon, "JetPackBurst", "JetPackLift" )
        //print( "Got a signal!" )

        int ammoReduce 
        bool isPassiveJet = weapon.HasMod( "passive_jet_pack" ) // nerfed one!
        bool isGruntJet = weapon.HasMod( "gm_flyer" )
        bool isJetBurst = result.signal == "JetPackBurst"
        if( isJetBurst )
        {
            if( isPassiveJet )
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_BURST_PASSIVE
            else if ( isGruntJet )
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_BURST_GRUNT
            else
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_BURST
        }
        else
        {
            if( isPassiveJet )
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_TICK_PASSIVE
            else if ( isGruntJet )
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_TICK_GRUNT
            else
                ammoReduce = JET_PACK_AMMO_REDUCE_PER_TICK
        }

        int currentAmmo = weapon.GetWeaponPrimaryClipCount()
        weapon.SetWeaponPrimaryClipCountAbsolute( max( 0, currentAmmo - ammoReduce ) )
    }
}

vector function GetVectorFromInput( entity player )
{
	vector angles = player.EyeAngles()
	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	vector directionForward = GetDirectionFromInput( angles, xAxis, yAxis )

	return directionForward
}

vector function GetDirectionFromInput( vector playerAngles, float xAxis, float yAxis )
{
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}

void function DelayedCheckJetPackAvailable( entity player )
{
    entity jetPackWeapon = GetPlayerJetPackWeapon( player )
    if( IsValid( jetPackWeapon ) )
        thread JetPackThink( player, jetPackWeapon )
}

entity function GetPlayerJetPackWeapon( entity player )
{
    foreach( entity offhand in player.GetOffhandWeapons() )
    {
        if( offhand.GetWeaponClassName() == JET_PACK_WEAPON )
        {
            if( offhand.HasMod( JET_PACK_MOD ) )
                return offhand
        }
    }
    return null
}
#endif