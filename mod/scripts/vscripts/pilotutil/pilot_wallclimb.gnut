// TODO: add controllder input check
global function Pilot_WallClimb_Init

const bool WALLCLIMB_ALLOW_VERTICAL_INPUT = false // client will mostly desync, don't allow this
const float WALLCLIMB_ANGLE_LIMIT = 45.0 // other than this will consider as not facing a wall
const float WALLCLIMB_GRACE_PERIOD_TIME = 0.4 // if you're not facing wall at start, press left or right within this time won't be kick off wall

struct
{
	table<entity, float> playerWallRunBeinTime
} file

void function Pilot_WallClimb_Init()
{
    // I can't handle "PilotStartWallClimb" now
    RegisterSignal( "PilotStartWallClimb" )
    RegisterSignal( "PilotStopWallClimb" )

	RegisterSignal( "PilotWallClimbThink" )
	// ttf2 don't have other ways to modify classmods other than change class, so this is enough
	AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
}


//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnClientConnected( entity player )
{
	file.playerWallRunBeinTime[player] <- 0.0
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLRUN, UpdatePlayerWallRunBeginTime )
}

void function OnPlayerClassChanged( entity player )
{
    thread PilotWallClimbThink( player )
}

void function UpdatePlayerWallRunBeginTime( entity player )
{
	file.playerWallRunBeinTime[player] = Time()
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// UTILITY FUNCTIONS /////
/////////////////////////////

void function PilotWallClimbThink( entity player )
{
	// only run for living players( dead players will also change class to "spectator", prevent it )
	if ( !IsAlive( player ) )
		return

	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.Signal( "PilotWallClimbThink" )
	player.EndSignal( "PilotWallClimbThink" )

	// check wallclimb mod, ttf2 don't have other ways to modify classmods than change class so this is enough
	bool hasWallClimb = false
	float angleLimit
	array<string> classMods = player.GetPlayerSettingsMods()
	// grunt mode climber
	if ( classMods.contains( "only_wallclimb" ) ||
		 classMods.contains( "normal_wallclimb" ) ||
		 classMods.contains( "amped_wallclimb" )
	) 
	{
		hasWallClimb = true
		angleLimit = WALLCLIMB_ANGLE_LIMIT
	}

	if ( !hasWallClimb )
		return

	bool isClimbingWall
	vector wallAngles
	vector lastTickVel
	bool facingWallAtStart
	while( true )
	{
		if ( isClimbingWall && !player.IsWallRunning() ) // considering player has left the wall?
		{
			player.Signal( "PilotStopWallClimb" )
			isClimbingWall = false
			facingWallAtStart = false
		}
		lastTickVel = player.GetVelocity()

		WaitFrame() // always wait first

		if ( player.IsWallHanging() ) // allow player to do wallhang
			continue

		// main mechanic: kick player off wall if they're not facing it, only wall climbing!
		if ( player.IsWallRunning() )
		{
			if ( !isClimbingWall ) // new wall climbing
			{
				float eyeAnglesYawBeforeTrace = VectorToAngles( player.GetViewVector() ).y

				vector ornull currentAngs = TracePlayerWallAngles( player, lastTickVel )
				if ( currentAngs == null ) // can't trace!
				{
					thread KickPlayerOffWall( player )
					continue
				}
				wallAngles = expect vector ( currentAngs )
				
				facingWallAtStart = fabs( fabs( wallAngles.y - eyeAnglesYawBeforeTrace ) - 180 ) <= angleLimit
				//print( "wallAngles.y: " + string( wallAngles.y ) )
				//print( "eyeAnglesYawBeforeTrace : " + string( eyeAnglesYawBeforeTrace ) )
				//print( fabs( fabs( wallAngles.y - eyeAnglesYawBeforeTrace ) - 180 ) )
			}

			// comparing yaw is enough
			float wallAnglesYaw = wallAngles.y

			// get player's viewing angle, comparing yaw is enough
			float eyeAnglesYaw = VectorToAngles( player.GetViewVector() ).y

			float angDiffer = fabs( fabs( wallAnglesYaw - eyeAnglesYaw ) - 180 ) // formatting the differ
			//print( angDiffer )

			// try to move on the wall( can't handle controller for now )
			if ( !WALLCLIMB_ALLOW_VERTICAL_INPUT )
			{
				//print( "facingWallAtStart: " + string( facingWallAtStart ) )
				if ( file.playerWallRunBeinTime[player] + WALLCLIMB_GRACE_PERIOD_TIME < Time() || facingWallAtStart ) // if we're not facing wall at the start of climbing, give some grace period
				{
					if ( player.IsInputCommandHeld( IN_MOVELEFT ) || player.IsInputCommandHeld( IN_MOVERIGHT ) )
					{
						thread KickPlayerOffWall( player ) // knock player off
						continue
					}
					else // contoller input?
					{
						vector inputAngs = VectorToAngles( GetPlayerInputDirection( player ) )
						float inputAngsYaw = inputAngs.y
						angDiffer = fabs( fabs( wallAnglesYaw - inputAngsYaw ) - 180 ) // formatting the differ
						//print( "inputAngs: " + string( inputAngs ) )
						//print( "angDiffer: " + string( angDiffer ) )
						if ( angDiffer > angleLimit ) // the angle diffrence is bigger than limit?
							thread KickPlayerOffWall( player )
					}
				}
			}

			if ( angDiffer > angleLimit ) // the angle diffrence is bigger than limit?
				thread KickPlayerOffWall( player )

			if ( !isClimbingWall )
			{
				player.Signal( "PilotStartWallClimb" )
				isClimbingWall = true // mark as start climbing
			}
		}
	}
}

vector ornull function TracePlayerWallAngles( entity player, vector lastTickVel )
{
	vector startPos = player.GetOrigin()
	//vector startPos = player.EyePosition()
	//int attachID = player.LookupAttachment( "CHESTFOCUS" )
	//if ( attachID > 0 )
	//	startPos = player.GetAttachmentOrigin( attachID )
	
	vector directionForward = GetPlayerInputDirection( player ) // default is use player's input
	directionForward = AnglesToForward( < 0, VectorToAngles( directionForward ).y, 0 > ) // comparing yaw is enough
	//print( VectorToAngles( directionForward ) )
	vector moveAngs = VectorToAngles( lastTickVel )
	//print( "moveAngs: " + string( moveAngs ) )
	if ( moveAngs.y != 0 ) // if moveAngs valid, use it instead
		directionForward = AnglesToForward( < 0, moveAngs.y, 0 > )
	vector endPos = startPos + directionForward * 100 // get player's viewing wall

	//vector moveAngs = VectorToAngles( lastTickVel )
	//vector traceVec = AnglesToForward( < 0, VectorToAngles( lastTickVel ).y, 0 > ) * 50
	//vector endPos = startPos + traceVec // get player's viewing wall

	TraceResults traceResult = TraceLine( 
											startPos, 
											endPos,
											player,
											(TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), 
											TRACE_COLLISION_GROUP_NONE 
										)

	// can't trace anything?
	if ( !IsValid( traceResult.hitEnt ) )
		return null

	// get the wall's normal
	vector normal = traceResult.surfaceNormal
	// get the wall's angle
	vector wallAngles = VectorToAngles( normal )

	// lerp player's view
	//player.PlayerCone_FromAnim()
	player.PlayerCone_SetMinYaw( -45 )
	player.PlayerCone_SetMaxYaw( 45 )
	player.PlayerCone_SetMinPitch( 0 )
	player.PlayerCone_SetMaxPitch( 0 )
	
	vector playerAngs = player.EyeAngles()
	playerAngs.y = wallAngles.y - 180
	player.SetAngles( playerAngs )

	return wallAngles
}

vector function GetPlayerInputDirection( entity player )
{
	vector playerAngles = player.EyeAngles()
	playerAngles.x = 0
	playerAngles.z = 0
	vector forward = AnglesToForward( playerAngles )
	vector right = AnglesToRight( playerAngles )

	float xAxis = player.GetInputAxisRight()
	float yAxis = player.GetInputAxisForward()
	xAxis = GraphCapped( xAxis, -1.0, 1.0, -0.4, 0.4 )
	yAxis = GraphCapped( yAxis, -1.0, 1.0, 1.0, 0.75 ) //Cap it so you don't actually let the players jump forwards
	//print( "xAxis: " + string( xAxis ) )
	//print( "yAxis: " + string( xAxis ) )
	vector directionVec = Vector(0,0,0)
	directionVec += right * xAxis
	directionVec += forward * yAxis

	vector directionAngles = VectorToAngles( directionVec )
	vector directionForward = AnglesToForward( directionAngles )

	return directionForward
}

void function KickPlayerOffWall( entity player )
{
	player.ForceCrouch() // best way to do it
	WaitFrame() // wait is needed if you want to make them able to stand again
	player.UnforceCrouch() // restore stand
	player.ForceStand() // make player stand up for fight, no need to manually cancel crouch
	WaitFrame()
	player.UnforceStand() // restore crouch
}

/////////////////////////////////
///// UTILITY FUNCTIONS END /////
/////////////////////////////////
