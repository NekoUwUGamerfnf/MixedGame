// 11.27: Changed all settings to "titan_soul" entity instead of player
untyped // I really don't like this thing but .SetPlayerSettings() need it...

global function TitanReplace_Enabled_Init // for enabling in loadedinits_after
global function TitanReplace_Init

// settings
global function TitanReplace_SetEnabled

global function TitanReplace_UseGunnerBisonVariant // bison variant

// fixes, always gets applied no matter titan_replace is enabled or not
global function TitanReplace_EnableNorthstarReBalance // rebalance northstar's railgun
global function TitanReplace_EnableRoninCoreFix // fix ronin's sword core behavior

///// acrossFile utilities
global function TitanReplace_GiveTitanLoadoutReplace
global function TitanReplace_GetSoulStartingPassive // passive which titan spawn with
global function TitanReplace_GetSoulStartingExecutionRef // executionref which titan spawn with

// title
global function TitanReplace_UpdateSoulTitanTitle
global function TitanReplace_GetSoulSavedTitanTitle

// passive
global function TitanReplace_RegisterPassiveType
global function TitanReplace_RegisterCharacterOwnedPassives
global function TitanReplace_GetPassiveType
global function TitanReplace_RemoveUnmatchedPassivesForTitan // this actually uses TitanPick_GetTitanWeaponDropCharacterName() for getting character name!!

global enum eTitanReplacePassiveTypes
{
	WEAPON
	DEFENSE,
	UTILITY,
	OFFENSE,
	CORE,
}

///// titanType utilities
global function TitanReplace_BecomeIon
global function TitanReplace_BecomeTone
global function TitanReplace_BecomeAtlas
global function TitanReplace_BecomeRonin
global function TitanReplace_BecomeNorthstar
global function TitanReplace_BecomeStryder
global function TitanReplace_BecomeScorch
global function TitanReplace_BecomeLegion
global function TitanReplace_BecomeOgre
global function TitanReplace_BecomeBison
global function TitanReplace_BecomeGunnerBison // bison variant
global function TitanReplace_BecomeMonarch
global function TitanReplace_BecomeArchon
global function TitanReplace_BecomeBrute

// client install required
global function TitanReplace_BecomeModdedBrute4
global function TitanReplace_BecomeModdedArchon


const array<string> moddedPlayers = 
[ 
	"1007270968017", 	// VoyageDB
	"1003302185211", 	// DZ
	"2311706887", 		// mite
	"1011338569992", 	// G41
	"1007340426216", 	// Jerry_Wang#8123
	"1010087865132", 	// chillyue#5400
	"1007606851794", 	// 军团#7939
	"1000374987953", 	// RCtd#0852
	"1006403284636", 	// wodemaya#0028
	"1007932882179", 	// 抑郁寡欢Z骡子#1903
	"1011146305825", 	// H_A#3930
	"1006393068081", 	// 一位屑中屑的屑铁驭屑铁驭#3838
	"1011667472349", 	// COOPER#7592
	"1007468387616", 	// LOGIC0214( logic#0886 )
	"1003338759893", 	// R9390X#1342
	"1008061878974", 	// yogre416#1123
	"1013455793584", 	// 114514#1281
	"1006799764479"		// ILoveSteam#6158
]

struct
{
	// settings
	bool defaultReplaceEnabled

	bool useGunnerBison

	// fixes
	bool northstarReBalanceEnabled
	bool roninCoreFixEnabled

	// entity table
	table<entity, string> soulTitleTable
	table<entity, int> soulPassiveTable // for saving player's starting passive
	table<entity, string> soulExecutionRefTable // for saving player's starting executions

	// registered stuffs
	table<int, int> titanPassiveType
	table< string, array<int> > titanCharacterOwnedPassives
} file

void function TitanReplace_Enabled_Init()
{
	TitanReplace_SetEnabled( true )
}

void function TitanReplace_Init() 
{
	AddSoulInitFunc( TitanReplace_InitSoulSettings )
	AddSpawnCallback( "npc_titan", OnTitanSpawned )
	AddCallback_OnPilotBecomesTitan( SetPlayerTitanTitle )

	RegisterDefaultTitanPickCharacters()
}

void function TitanReplace_SetEnabled( bool enabled )
{
	file.defaultReplaceEnabled = enabled
}

void function TitanReplace_UseGunnerBisonVariant( bool use )
{
	file.useGunnerBison = use
}

// fixes
void function TitanReplace_EnableNorthstarReBalance( bool enable )
{
	file.northstarReBalanceEnabled = enable
}

void function TitanReplace_EnableRoninCoreFix( bool enable )
{
	file.roninCoreFixEnabled = enable
}

void function OnTitanSpawned( entity titan )
{
	TitanReplace_GiveTitanLoadoutReplace( titan )
}

// default replace
void function TitanReplace_GiveTitanLoadoutReplace( entity titan )
{
	// always init everything
	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // soul not spawned yet, mostly because disembarking, no worries
		return

	// following are player titans( pet titans )
	entity player = GetPetTitanOwner( titan )
	if( !IsValid( player ) )
		return
	if ( "spawnWithoutSoul" in titan.s )
	{
		// this is defined in CreateAutoTitanForPlayer_ForTitanTitanReplace_BecomesPilot(), mark the titan as "disembarked" not "hotdropping"
		if ( expect bool ( titan.s.spawnWithoutSoul ) )
			return
	}

	// get passives and executionrefs here
	file.soulPassiveTable[ titanSoul ] = _PassiveFromEnum[titanSoul.soul.titanLoadout.passive2] // for saving player's starting passive
	file.soulExecutionRefTable[ titanSoul ] = titanSoul.soul.titanLoadout.titanExecution // for saving player's starting executions
	//print( "soul " + string( titanSoul ) + " 's executionRef is: " + file.soulExecutionRefTable[ titanSoul ] )

	asset modelName = titan.GetModelName()
	//print( "modelName is: " + string( modelName ) )

	// titan fixes and balance, always run
	switch( modelName )
	{
		// northstar balance...
		case $"models/titans/light/titan_light_raptor.mdl":
			if ( file.northstarReBalanceEnabled )
			{
				if ( titan.GetMainWeapons().len() > 0 )
				{
					entity mainWeapon = titan.GetMainWeapons()[0]
					mainWeapon.AddMod( "rebalanced_weapon" )
				}
			}
			break

		// ronin balance...
		case $"models/titans/light/titan_light_locust.mdl":
			if ( file.roninCoreFixEnabled )
			{
				entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
				if ( IsValid( coreWeapon ) )
				{
					coreWeapon.AddMod( "sword_core_fix" )
				}
			}
			break
	}

	// loadout replace
	if( file.defaultReplaceEnabled ) // don't run loadout functions automatically if settings disabled
	{
		switch( modelName )
		{
			case $"models/titans/medium/titan_medium_vanguard.mdl":
				//TitanPick_SoulSetEnableWeaponPick( titanSoul, false ) // set players unable to replace weapons from ground
				break

			case $"models/titans/medium/titan_medium_tone_prime.mdl":
				SendHudMessage(player, "已启用天图泰坦装备，取消至尊泰坦以使用原版强力",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1)
				TitanReplace_BecomeAtlas( titan, false, true )
				break

			case $"models/titans/heavy/titan_heavy_legion_prime.mdl":
				SendHudMessage(player, "已启用巨妖泰坦装备，取消至尊泰坦以使用原版军团",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeOgre( titan, false, true )
				break

			case $"models/titans/light/titan_light_ronin_prime.mdl":
				SendHudMessage(player, "已启用游侠泰坦装备，取消至尊泰坦以使用原版浪人",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeStryder( titan, false, true )
				break

			case $"models/titans/heavy/titan_heavy_scorch_prime.mdl":
				SendHudMessage(player, "已启用野牛泰坦装备，取消至尊泰坦以使用原版烈焰",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				if ( file.useGunnerBison ) // bison vairant
				{
					// Gunner Bison
					TitanReplace_BecomeGunnerBison( titan, false, true )
				}
				else
				{
					// Melee Bison
					TitanPick_SoulSetEnableWeaponDrop( titanSoul, false ) // setting titans won't drop weapon
					TitanPick_SoulSetEnableWeaponPick( titanSoul, false ) // setting players unable to replace weapons from ground
					TitanReplace_BecomeBison( titan, false, true )
				}
				break

			case $"models/titans/medium/titan_medium_ion_prime.mdl":
				SendHudMessage(player, "已启用执政官泰坦装备，取消至尊泰坦以使用原版离子",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeArchon( titan, false, true )
				break
			
			case $"models/titans/light/titan_light_northstar_prime.mdl":
				SendHudMessage(player, "已启用野兽泰坦装备，取消至尊泰坦以使用原版北极星",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeBrute( titan, false, true )
				break
		}
	}

	//temp fix, these are client install required titans
	/* // removed for now, we've got other server-side titans
	if( moddedPlayers.contains( player.GetUID() ) )
	{
		switch( modelName )
		{
			case $"models/titans/medium/titan_medium_ion_prime.mdl":
				SendHudMessage(player, "已启用执政官泰坦装备，取消至尊泰坦以使用原版离子",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeModdedArchon( titan, false, true )
				break
			case $"models/titans/light/titan_light_northstar_prime.mdl":
				SendHudMessage(player, "已启用野兽四号泰坦装备，取消至尊泰坦以使用原版北极星",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeModdedBrute4( titan, false, true )
				break
		}
	}
	*/
}

int function TitanReplace_GetSoulStartingPassive( entity soul )
{
	return file.soulPassiveTable[ soul ]
}

string function TitanReplace_GetSoulStartingExecutionRef( entity soul )
{
	return file.soulExecutionRefTable[ soul ]
}

void function TitanReplace_UpdateSoulTitanTitle( entity soul, string newTitle )
{
	file.soulTitleTable[ soul ] = newTitle
}

string function TitanReplace_GetSoulSavedTitanTitle( entity soul )
{
	return file.soulTitleTable[ soul ]
}

void function SetPlayerTitanTitle( entity player, entity titan )
{
	thread SetPlayerTitanTitle_Threaded( player ) // needs thread, to make soul valid
}

void function SetPlayerTitanTitle_Threaded( entity player )
{
	player.EndSignal( "OnDestroy" )
	WaitEndFrame() // wait for titan transfer set titan title

	entity titanSoul = player.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return
	string soulSaveTitle = TitanReplace_GetSoulSavedTitanTitle( titanSoul )
	if( soulSaveTitle != "" )
	{
		//print( "soulSaveTitle: " + soulSaveTitle )
		if( IsAlive( player ) )
			player.SetTitle( soulSaveTitle )
	}
	//else
	//	print( "can't find titan's title!" )
}

///// settings functions!
void function TitanReplace_InitSoulSettings( entity titanSoul ) // both using for players and titanSouls
{
	if ( !( titanSoul in file.soulTitleTable ) )
		file.soulTitleTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulPassiveTable ) )
		file.soulPassiveTable[ titanSoul ] <- -1
	if ( !( titanSoul in file.soulExecutionRefTable ) )
		file.soulExecutionRefTable[ titanSoul ] <- ""
}
///////////


///// loadout functions
void function TitanReplace_BecomeIon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 离子 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_ION" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_ION" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ion" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as ion
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
                {
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon"])
                    GivePassive( titan, ePassives.PAS_ION_WEAPON )
                }
                else if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon_ads"])
					GivePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["pas_ion_vortex"] )
					GivePassive( titan, ePassives.PAS_ION_VORTEX )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire"] )
					GivePassive( titan, ePassives.PAS_ION_TRIPWIRE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["pas_ion_lasercannon"] )
					GivePassive( titan, ePassives.PAS_ION_LASERCANNON )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
            }
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_ion", "execution_random_0" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeTone( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 强力 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_TONE" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_TONE" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "tone" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as tone
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_weapon"])
					GivePassive( titan, ePassives.PAS_TONE_WEAPON )
				}
				else if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_burst"])
					GivePassive( titan, ePassives.PAS_TONE_BURST )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["pas_tone_wall"] )
					GivePassive( titan, ePassives.PAS_TONE_WALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["pas_tone_sonar"] )
					GivePassive( titan, ePassives.PAS_TONE_SONAR )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE, ["pas_tone_rockets"] )
					GivePassive( titan, ePassives.PAS_TONE_ROCKETS )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE )
				
				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_tone", "execution_random_4" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeAtlas( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 天图 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_ATLAS_NAME" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_ATLAS_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "atlas" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as atlas
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan ) 

				//Weapon
                entity newWeapon = titan.GiveWeapon( "mp_titanweapon_sticky_40mm", ["atlas_40mm"] )
				// pending funny mods: ["fd_tone_weapon_2_fixed", "extended_ammo_fixed", "fast_reload", "mortar_shots", "atlas_40mm", "atlas_40mm_burst", "pas_tone_burst"]
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "impact_drain_vortex"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_smoke", OFFHAND_ANTIRODEO, ["fast_warmup"] )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE, ["upgradeCore_Vanguard", "atlas_rockets"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["damage_core"] )
			
				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )
				titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE, ["dash_punch", "big_punch"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
        }
	}
}

void function TitanReplace_BecomeRonin( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
           		SendHudMessage( player, "更换至 浪人 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_RONIN" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_RONIN" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ronin" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as ronin
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall", ["pas_ronin_weapon"])
					GivePassive( titan, ePassives.PAS_RONIN_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				titan.GiveOffhandWeapon("mp_titanability_basic_block", OFFHAND_SPECIAL )

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_autoshift"] )
					GivePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
				}
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_phase"] )
					GivePassive( titan, ePassives.PAS_RONIN_PHASE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO)
				
				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["pas_ronin_arcwave"] )
					GivePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["pas_ronin_swordcore"] )
					GivePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_ronin", "execution_random_3" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeNorthstar( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
            
			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 北极星 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_NORTHSTAR" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_NORTHSTAR" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "northstar" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as northstar
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				
				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_weapon"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
				}
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_optics"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL, ["pas_northstar_trap"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL )

				//Tacticals, northstar is a bit special
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO, ["pas_northstar_flightcore"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO)

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["pas_northstar_flightcore"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
			}
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_northstar", "execution_random_2" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeStryder( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 游侠 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_STRYDER_NAME" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_STRYDER_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "stryder" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as stryder
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan )

				//Weapon
                //titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream" )
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["stryder_xo16"] )
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				// stryder reworked: don't want to make it use rocket pods, since ronin don't have such a bodygroup
				//Defence
				//titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["pas_vanguard_shield", "stryder_laser"] ) // was["energy_field", "stryder_laser"]
				titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield"] )

				//Tactical
				//titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO )
				titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire", "stryder_tripwire"] )

				//Offence
				//titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )
				//titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["stryder_rockets"] )
				
				//titan.GiveOffhandWeapon( "mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["modelset_prime", "stryder_fire_wave"] )
				// flame wall mod for fire wave
				titan.GiveOffhandWeapon( "mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["stryder_fire_wave"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["dash_core"] )
				// testing tesla core
				//titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["tesla_core"] )

				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
				//titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE, ["dash_punch", "big_punch"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeScorch( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 烈焰 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_SCORCH" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_SCORCH" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "scorch" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as scorch
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor", ["pas_scorch_weapon"])
					GivePassive( titan, ePassives.PAS_SCORCH_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["pas_scorch_shield"] )
					GivePassive( titan, ePassives.PAS_SCORCH_SHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL )

				//Tacticals, scorch is a bit special
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					GivePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
				titan.GiveOffhandWeapon("mp_titanability_slow_trap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["pas_scorch_firewall"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["pas_scorch_flamecore"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )
            }

			// pick up scorch loadout
			if ( isPickup )
			{
				//Passives
				if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
					soul.SetPreventCrits( true )

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch", "execution_random_1" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeLegion( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 军团 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_LEGION" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_LEGION" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "legion" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as legion
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_weapon"])
					GivePassive( titan, ePassives.PAS_LEGION_WEAPON)
				}
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_spinup"])
					GivePassive( titan, ePassives.PAS_LEGION_SPINUP )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon")
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL, ["pas_legion_gunshield"] )
					GivePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL )

				//Tacticals
				titan.GiveOffhandWeapon("mp_titanability_ammo_swap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE, ["pas_legion_chargeshot"] )
					GivePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE )
				
				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT, ["pas_legion_smartcore"] )
					GivePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )
            }
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_legion", "execution_random_5" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeOgre( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 巨妖 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_OGRE_NAME" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_OGRE_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ogre" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as ogre
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan )

				//Weapon
                titan.GiveWeapon ("mp_titanweapon_triplethreat", ["ogre_triplethreat"])

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["ogre_shield"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO ) //["ogre_sonar"]

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_homing_rockets", OFFHAND_ORDNANCE, ["ogre_rockets"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT, ["shield_core"] )
				soul.SetTitanSoulNetInt( "upgradeCount", 3 )
            	//soul.SetShieldHealthMax( 3500 )

				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )
				titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE, ["dash_punch", "big_punch"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeBison( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 野牛 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#NPC_TITAN_OGRE_FIGHTER" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_OGRE_FIGHTER" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute bison

			// spawn as bison
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Bison have damage reduction
				soul.SetPreventCrits( true )
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Defence
				titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield", "molting_dome", "bison_dome"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_ANTIRODEO, ["bison_grapple"] )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster", "fd_twin_cluster"] )
				//titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["wrecking_ball"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["ground_slam"] )
				
				//Melee, primary weapon for bison
				titan.GiveOffhandWeapon( "melee_titan_punch_fighter", OFFHAND_MELEE, ["berserker", "allow_as_primary", "dash_punch", "bison_punch"] )
				titan.SetActiveWeaponByName( "melee_titan_punch_fighter" ) // needs to setup

				// version2: try to use mp_weapon_gunship_missile as a melee primary placeholder
				//titan.GiveWeapon( "mp_weapon_gunship_missile", ["titan_electric_fist_primary"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_fighter", OFFHAND_MELEE, ["berserker", "dash_punch", "bison_punch"] )
				//titan.SetActiveWeaponByName( "mp_weapon_gunship_missile" )

				// Execution
    			soul.soul.titanLoadout.titanExecution = "execution_scorch_prime" 
			}
		}
	}
}

// bison variant
void function TitanReplace_BecomeGunnerBison( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 野牛 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#NPC_TITAN_OGRE_FIGHTER" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_OGRE_FIGHTER" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "bison_gunner" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute bison

			// spawn as bison
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Bison have damage reduction
				//Gunner bison shouldn't have?
				soul.SetPreventCrits( true )
				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				//Weapon
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_xo16_shorty", ["gunner_bison_xo16", "extended_ammo"] ) // removed "electric_rounds", it's horribles
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["pas_vanguard_shield"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_ability_heal", OFFHAND_ANTIRODEO, ["bc_long_stim1", "pas_power_cell"] )

				//Offence
				// can't handle sharedEnergyTotal without modifying bison_util.nut, just temp removed here
				// needs to add a weapon mod named "gunner_bison_laser", and do SetSharedEnergyTotal() in bison util checks
				// should be handled by weapon's OwnerChanged callbacks...
				// it's WIP now
				//titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE, ["gunner_bison_laser"] )
				titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["berserker_core"] )

				//Melee, primary weapon for bison
				titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )
			}

			// pick up bison loadout
			if ( isPickup )
			{
				//Passives
				soul.SetPreventCrits( true )

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch_prime", "execution_random_1" )
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
		}
	}
}

void function TitanReplace_BecomeMonarch( entity titan, bool isPickup = false, bool isSpawning = false )
{
    if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
            	SendHudMessage( player, "更换至 帝王 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_VANGUARD" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_VANGUARD" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "vanguard" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as monarch
			if ( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon = titan.GiveWeapon ("mp_titanweapon_xo16_vanguard")
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				
				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_rearm", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
				//soul.SetTitanSoulNetInt( "upgradeCount", 3 ) // so player can't upgrade, they can only receive shields
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_vanguard", OFFHAND_MELEE )
			}

			// switch to monarch loadout
			if ( isPickup )
			{
				int upgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
				// bodygroup
				if ( upgradeCount >= 1 ) // upgraded
				{
					int statesIndex = titan.FindBodyGroup( "states" )
					if ( statesIndex > 0 )
						titan.SetBodygroup( statesIndex, 1 )
				}

				//Passives
				// maelstrom
				if ( upgradeCount >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) )
				{
					entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
					if ( IsValid( smokeWeapon ) )
					{
						array<string> mods = smokeWeapon.GetMods()
						mods.append( "maelstrom" )
						smokeWeapon.SetMods( mods )
					}
				}
				// superior chassis
				if ( upgradeCount >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) )
				{
					if ( !GetDoomedState( titan ) && IsAlive( titan ) )
					{
						array<string> settingMods = titan.GetPlayerSettingsMods()
						settingMods.append( "core_health_upgrade" )
						// update health and class
						float healthFrac = GetHealthFrac( titan )
						titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
						int maxHealth = titan.GetMaxHealth()
						titan.SetHealth( int( maxHealth * healthFrac ) )

						//Hacky Hack - Append core_health_upgrade to setFileMods so that we have a way to check that this upgrade is active.
						soul.soul.titanLoadout.setFileMods.append( "core_health_upgrade" )
					}
					
					// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
					soul.SetPreventCrits( true )
				}

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_vanguard", "execution_random_6", false ) // monarch don't have _prime suffix ones
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeArchon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			
			if( !isSpawning )
			{
				SendHudMessage( player, "更换至 执政官 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ARC" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "archon" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as archon
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_meteor", ["storm_launcher", "fd_wpn_upgrade_1"] )
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["vortex_blocker"] )
				
				// Utility
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["archon_stun_impact"] )

				//Offence
				titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_laser"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["tesla_core", "archon_tesla"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeBrute( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
				SendHudMessage( player, "更换至 野兽 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ROCKET" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ROCKET" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "brute" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as brute
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				titan.GiveWeapon ( "mp_titanweapon_rocketeer_rocketstream", ["brute_rocket"] )

				//Defence
				titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "impact_drain_vortex"] )
				
				// Utility
				titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

// modded titans, client install required
void function TitanReplace_BecomeModdedBrute4( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
				SendHudMessage( player, "更换至 野兽四号 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "brute4_modded" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			// spawn as archon
			if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				if( passiveType == eTitanReplacePassiveTypes.WEAPON )
					titan.GiveWeapon ("mp_titanweapon_rocketeer_rocketstream", ["brute4_quad_rocket", "straight_shot"])
				else
					titan.GiveWeapon ("mp_titanweapon_rocketeer_rocketstream", ["brute4_quad_rocket"])

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield", "molting_dome"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield"] )

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					titan.GiveOffhandWeapon("mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO, ["brute4_cluster_payload", "explosive_reserves"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO, ["brute4_cluster_payload"] )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley", "magnetic_rollers"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley"] )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core", "rapid_detonator"] )
				else
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeModdedArchon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心启动期间不可以更换装备", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			if( !isSpawning )
			{
				SendHudMessage( player, "更换至 执政官 泰坦技能组", -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )
			}
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ARC" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "archon_modded" )
			TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )
			
			// spawn as archon
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
				if( passiveType == eTitanReplacePassiveTypes.WEAPON )
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon", "chain_reaction"])
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon", "static_feedback"])
				else
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon"])
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield", "bolt_from_the_blue"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield"] )
					
				//Tactical
				//if(SoulHasPassive( soul, ePassives.PAS_ION_LASERCANNON ))
				//	titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node", "dual_nodes"] )
				//else
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node"] )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball", "thylord_module"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball"] )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core", "bring_the_thunder"] )
				else
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

///// titan pick loadout functions
void function RegisterDefaultTitanPickCharacters()
{
	RegisterIonTitanCharacter()
	RegisterToneTitanCharacter()
	RegisterMonarchTitanCharacter()
	RegisterAtlasTitanCharacter()
	RegisterRoninTitanCharacter()
	RegisterNorthstarTitanCharacter()
	RegisterStryderTitanCharacter()
	RegisterScorchTitanCharacter()
	RegisterLegionTitanCharacter()
	RegisterOgreTitanCharacter()
	RegisterGunnerBisonTitanCharacter() // bison variant
	RegisterArchonTitanCharacter()
	RegisterBruteTitanCharacter()

	RegisterModdedArchonTitanCharacter()
	RegisterModdedBrute4TitanCharacter()
}

// ion
void function RegisterIonTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_VORTEX, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_TRIPWIRE, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_WEAPON_ADS, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_LASERCANNON, eTitanReplacePassiveTypes.CORE )
	
	TitanReplace_RegisterCharacterOwnedPassives( 
		"ion",							// character name
		[	// passives array
			ePassives.PAS_ION_WEAPON,
			ePassives.PAS_ION_VORTEX,
			ePassives.PAS_ION_TRIPWIRE,
			ePassives.PAS_ION_WEAPON_ADS,
			ePassives.PAS_ION_LASERCANNON,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "ion", IonWeaponWeaponPropFunc, IonWeaponDisplayNameFunc, TitanReplace_BecomeIon )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_ION_TRIPWIRE )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_VORTEX )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_LASERCANNON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON_ADS )

	// classmods
	TitanPick_AddChangableClassMod( "fd_energy_regen" )
	TitanPick_AddChangableClassMod( "fd_energy_max" )
}

entity function IonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function IonWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "離子 技能組"
	if ( SoulHasPassive( soul, ePassives.PAS_ION_WEAPON ) || primaryMods.contains( "pas_ion_weapon" ) )
		displayName += "【纏結能量】"
	else if ( antiRodeoMods.contains( "pas_ion_tripwire" ) )
		displayName += "【零點絆線】"
	else if ( specialMods.contains( "pas_ion_vortex" ) )
		displayName += "【漩渦擴大器】"
	else if ( coreMods.contains( "pas_ion_lasercannon" ) )
		displayName += "【大型火砲】"
	else if ( primaryMods.contains( "pas_ion_weapon_ads" ) )
		displayName += "【折射鏡片】"

	return displayName
}

// tone
void function RegisterToneTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_WALL, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_SONAR, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_ROCKETS, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_BURST, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"tone",							// character name
		[	// passives array
			ePassives.PAS_TONE_WEAPON,
			ePassives.PAS_TONE_WALL,
			ePassives.PAS_TONE_SONAR,
			ePassives.PAS_TONE_ROCKETS,
			ePassives.PAS_TONE_BURST,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "tone", ToneWeaponWeaponPropFunc, ToneWeaponDisplayNameFunc, TitanReplace_BecomeTone )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_BURST )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_ROCKETS )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_SONAR )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WALL )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WEAPON )

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanweapon_tracker_rockets" )
}

entity function ToneWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ToneWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	string displayName = "強力 技能組"
	if ( primaryMods.contains( "pas_tone_weapon" ) )
        displayName += "【強化追蹤彈藥】"
	else if ( SoulHasPassive( soul, ePassives.PAS_TONE_WALL ) || specialMods.contains( "pas_tone_wall" ) )
		displayName += "【強化粒子障壁】"
	else if ( antiRodeoMods.contains( "pas_tone_sonar" ) )
		displayName += "【脈衝回波】"
	else if ( ordnanceMods.contains( "pas_tone_rockets" ) )
		displayName += "【脈衝回波】"
	else if ( primaryMods.contains( "pas_tone_burst" ) )
		displayName += "【連發填充器】"

	return displayName
}

// atlas
void function RegisterAtlasTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "atlas", AtlasWeaponWeaponPropFunc, AtlasWeaponDisplayNameFunc, TitanReplace_BecomeAtlas )
}

entity function AtlasWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "atlas_40mm" ) )
		return

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function AtlasWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	if ( !mods.contains( "atlas_40mm" ) )
        return ""

	return "天圖 技能組"
}

// ronin
void function RegisterRoninTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_AUTOSHIFT, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_PHASE, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_ARCWAVE, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_SWORDCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"ronin",							// character name
		[	// passives array
			ePassives.PAS_RONIN_WEAPON,
			ePassives.PAS_RONIN_AUTOSHIFT,
			ePassives.PAS_RONIN_PHASE,
			ePassives.PAS_RONIN_ARCWAVE,
			ePassives.PAS_RONIN_SWORDCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "ronin", RoninWeaponWeaponPropFunc, RoninWeaponDisplayNameFunc, TitanReplace_BecomeRonin )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "super_charged" )
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "super_charged" )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_ARCWAVE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_AUTOSHIFT )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_PHASE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_SWORDCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_WEAPON )

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanability_basic_block" )
}

entity function RoninWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_leadwall" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function RoninWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_leadwall" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "浪人 技能組"
	if ( primaryMods.contains( "pas_ronin_weapon" ) )
		displayName += "【彈跳彈藥】"
	else if ( ordnanceMods.contains( "pas_ronin_arcwave" ) )
		displayName += "【雷暴】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_AUTOSHIFT ) || antiRodeoMods.contains( "pas_ronin_autoshift" ) )
		displayName += "【瞬間反應】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_SWORDCORE ) || coreMods.contains( "pas_ronin_swordcore" ) )
		displayName += "【高地戰士】"
	else if ( antiRodeoMods.contains( "pas_ronin_phase" ) )
		displayName += "【時間異常】"

	return displayName
}

// northstar
void function RegisterNorthstarTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_TRAP, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_OPTICS, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_CLUSTER, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_FLIGHTCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"northstar",						// character name
		[	// passives array
			ePassives.PAS_NORTHSTAR_WEAPON,
			ePassives.PAS_NORTHSTAR_TRAP,
			ePassives.PAS_NORTHSTAR_OPTICS,
			ePassives.PAS_NORTHSTAR_CLUSTER,
			ePassives.PAS_NORTHSTAR_FLIGHTCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "northstar", NorthstarWeaponWeaponPropFunc, NorthstarWeaponDisplayNameFunc, TitanReplace_BecomeNorthstar )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_CLUSTER )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_FLIGHTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_OPTICS )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_TRAP )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_WEAPON )
}

entity function NorthstarWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function NorthstarWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "北極星 技能組"
	if ( primaryMods.contains( "pas_northstar_weapon" ) )
		displayName += "【穿刺射擊】"
	else if ( ordnanceMods.contains( "pas_northstar_cluster" ) )
		displayName += "【強化負載重量】"
	else if ( specialMods.contains( "pas_northstar_trap" ) )
		displayName += "【雙重陷阱】"
	else if ( SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_FLIGHTCORE ) || coreMods.contains( "pas_northstar_flightcore" ) )
		displayName += "【毒蛇推進器】"
	else if ( primaryMods.contains( "pas_northstar_optics" ) )
		displayName += "【威脅光鏡】"

	return displayName
}

// stryder
void function RegisterStryderTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "stryder", StryderWeaponWeaponPropFunc, StryderWeaponDisplayNameFunc, TitanReplace_BecomeStryder )
}

entity function StryderWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "stryder_xo16" ) )
		return

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function StryderWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "stryder_xo16" ) )
		return ""

	return "游俠 技能組"
}

// scorch
void function RegisterScorchTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_SHIELD, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_SELFDMG, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_FIREWALL, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_FLAMECORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"scorch",							// character name
		[	// passives array
			ePassives.PAS_SCORCH_WEAPON,
			ePassives.PAS_SCORCH_SHIELD,
			ePassives.PAS_SCORCH_SELFDMG,
			ePassives.PAS_SCORCH_FIREWALL,
			ePassives.PAS_SCORCH_FLAMECORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "scorch", ScorchWeaponWeaponPropFunc, ScorchWeaponDisplayNameFunc, TitanReplace_BecomeScorch, SwitchOffScorchLoadout )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FIREWALL )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FLAMECORE )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SELFDMG )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_WEAPON )
}

entity function ScorchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ScorchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "烈焰 技能組"
	if ( primaryMods.contains( "pas_scorch_weapon" ) )
		displayName += "【野火投射器】"
	else if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
		displayName += "【回火加工武裝】"
	else if ( specialMods.contains( "pas_scorch_shield" ) )
		displayName += "【煉獄護罩】"
	else if ( ordnanceMods.contains( "pas_scorch_firewall" ) )
		displayName += "【增強火力】"
	else if ( coreMods.contains( "pas_scorch_flamecore" ) )
		displayName += "【一片焦土】"

	return displayName
}

void function SwitchOffScorchLoadout( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
			soul.SetPreventCrits( false ) // clean up
	}
}

// legion
void function RegisterLegionTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_GUNSHIELD, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_SPINUP, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_CHARGESHOT, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_SMARTCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"legion",							// character name
		[	// passives array
			ePassives.PAS_LEGION_WEAPON,
			ePassives.PAS_LEGION_GUNSHIELD,
			ePassives.PAS_LEGION_SPINUP,
			ePassives.PAS_LEGION_CHARGESHOT,
			ePassives.PAS_LEGION_SMARTCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "legion", LegionWeaponWeaponPropFunc, LegionWeaponDisplayNameFunc, TitanReplace_BecomeLegion )
	
	// invalid mods
	// smart core
	TitanPick_AddIllegalWeaponMod( "Smart_Core" )
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "Smart_Core" )
	// close range mode
	TitanPick_AddIllegalWeaponMod( "CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_CloseRangePowerShot" )
	// long range mode
	TitanPick_AddIllegalWeaponMod( "LongRangeAmmo" )
	TitanPick_AddIllegalWeaponMod( "LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "power_shot_ranged_mode" ) // mp_titanability_power_shot icon
	TitanPick_AddIllegalWeaponMod( "ammo_swap_ranged_mode" ) // mp_titanability_ammo_swap icon

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_CHARGESHOT )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_GUNSHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SMARTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SPINUP )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_WEAPON )

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanability_ammo_swap" )
}

entity function LegionWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_predator/w_titan_predator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function LegionWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "軍團 技能組"
	if ( primaryMods.contains( "pas_legion_weapon" ) )
		displayName += "【強化彈藥容量】"
	else if ( coreMods.contains( "pas_legion_smartcore" ) )
		displayName += "【感測器陣列】"
	else if ( SoulHasPassive( soul, ePassives.PAS_LEGION_GUNSHIELD ) || specialMods.contains( "pas_legion_gunshield" ) )
		displayName += "【堡壘】"
	else if ( primaryMods.contains( "pas_legion_spinup" ) )
		displayName += "【輕合金】"
	else if ( ordnanceMods.contains( "pas_legion_chargeshot" ) )
		displayName += "【隱藏部件】"

	return displayName
}

// ogre
void function RegisterOgreTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "ogre", OgreWeaponWeaponPropFunc, OgreWeaponDisplayNameFunc, TitanReplace_BecomeOgre )
}

entity function OgreWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_triplethreat" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "ogre_triplethreat" ) )
		return
	
	asset modelName = $"models/weapons/titan_triple_threat_og/w_titan_triple_threat_og.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function OgreWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_triplethreat" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "ogre_triplethreat" ) )
		return ""

	return "巨妖 技能組"
	/* // unused
	if ( mods.contains( "rolling_rounds" ) )
		return "三連環榴彈【滾動彈藥】"
	if ( mods.contains( "hydraulic_launcher" ) )
		return "三連環榴彈【液壓驅動】"
	if ( mods.contains( "mine_field" ) )
		return "三連環榴彈【地雷區】"
	return "三連環榴彈"
	*/
}

// bison shouldn't drop any weapon

// bison gunner variant
void function RegisterGunnerBisonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "bison_gunner", GunnerBisonWeaponWeaponPropFunc, GunnerBisonWeaponDisplayNameFunc, TitanReplace_BecomeGunnerBison, SwitchOffGunnerBisonLoadout )
}

entity function GunnerBisonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_shorty" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "gunner_bison_xo16" ) )
		return

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function GunnerBisonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_shorty" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "gunner_bison_xo16" ) )
		return ""

	return "野牛 技能組"
}

void function SwitchOffGunnerBisonLoadout( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		soul.SetPreventCrits( false ) // clean up
	}
}

// monarch, code name is "vanguard", should we use that?
void function RegisterMonarchTitanCharacter()
{
	// Titan Replace( current file )
	// monarch only have 4 kits, and they're mostly not related with monarch itself
	// guess I'll use core upgrades
	// NOTE: in general this will only take first valid upgrade

	// Arc Rounds and XO16 Accelerator count as "WEAPON"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE1, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE9, eTitanReplacePassiveTypes.WEAPON )
	
	// Energy Transfer and Energy Field count as "DEFENSE"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE3, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.DEFENSE )

	// Rapid Rearm and Superior Chassis count as "UTILITY"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.UTILITY )
	
	// Missile Racks and Multi-Target Missiles count as "OFFENSE"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE2, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE7, eTitanReplacePassiveTypes.OFFENSE )
	
	// Maelstrom count as "CORE"( cuz they earn from core )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE5, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"vanguard",							// character name
		[	// passives array
			ePassives.PAS_VANGUARD_COREMETER,
			ePassives.PAS_VANGUARD_SHIELD,
			ePassives.PAS_VANGUARD_REARM,
			ePassives.PAS_VANGUARD_DOOM,
			ePassives.PAS_VANGUARD_CORE1,
			ePassives.PAS_VANGUARD_CORE2,
			ePassives.PAS_VANGUARD_CORE3,
			ePassives.PAS_VANGUARD_CORE4,
			ePassives.PAS_VANGUARD_CORE5,
			ePassives.PAS_VANGUARD_CORE6,
			ePassives.PAS_VANGUARD_CORE7,
			ePassives.PAS_VANGUARD_CORE8,
			ePassives.PAS_VANGUARD_CORE9,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "vanguard", MonarchWeaponWeaponPropFunc, MonarchWeaponDisplayNameFunc, TitanReplace_BecomeMonarch, SwitchOffMonarchLoadout )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_COREMETER )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_REARM )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_DOOM )

	// core upgrades
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE1 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE2 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE3 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE4 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE5 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE6 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE7 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE8 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE9 )

	// classmods
	//TitanPick_AddChangableClassMod( "core_health_upgrade" ) // should be handled by switchoff funcs
}

entity function MonarchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function MonarchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	// mornach has variant mods
	// passives
	string passive = ""
	if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_SHIELD ) || specialMods.contains( "pas_vanguard_shield" ) )
		passive = "防護罩放大器"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
		passive = "能量盜取"
	else if ( antiRodeoMods.contains( "pas_vanguard_rearm" ) )
		passive = "疾速武裝"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_DOOM ) )
		passive = "適者生存"
	// upgrade 1
	string firstUpgrade = ""
	if ( primaryMods.contains( "arc_rounds" ) || primaryMods.contains( "arc_rounds_with_battle_rifle" ) )
		firstUpgrade = "電弧彈藥"
	else if ( specialMods.contains( "energy_transfer" ) || specialMods.contains( "energy_field_energy_transfer" ) )
		firstUpgrade = "能量轉換"
	else if ( ordnanceMods.contains( "missile_racks" ) || ordnanceMods.contains( "upgradeCore_MissileRack_Vanguard" ) )
		firstUpgrade = "飛彈架"
	// upgrade 2
	string secondUpgrade = ""
	if ( primaryMods.contains( "rapid_reload" ) )
		secondUpgrade = "快速武裝"
	else if ( specialMods.contains( "energy_field" ) || specialMods.contains( "energy_field_energy_transfer" ) )
		secondUpgrade = "能量場"
	else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) )
		secondUpgrade = "漩渦"
	// upgrade 3
	string finalUpgrade = ""
	if ( weapon.HasMod( "battle_rifle" ) || weapon.HasMod( "arc_rounds_with_battle_rifle" ) )
		finalUpgrade = "加速器"
	else if ( ordnance.HasMod( "upgradeCore_Vanguard" ) || ordnance.HasMod( "upgradeCore_MissileRack_Vanguard" ) )
		finalUpgrade = "多目標飛彈"
	else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) )
		finalUpgrade = "高級機種"

	string displayName = "帝王 技能組"
	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "【" // start

	if ( passive != "" )
		displayName += passive
	if ( firstUpgrade != "" )
		displayName += " " + firstUpgrade // add a space
	if ( secondUpgrade != "" )
		displayName += " " + secondUpgrade // add a space
	if ( finalUpgrade != "" )
		displayName += " " + finalUpgrade // add a space

	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" )
		displayName += "】" // end

	return displayName
}

void function SwitchOffMonarchLoadout( entity titan )
{
	// bodygroup
	int statesIndex = titan.FindBodyGroup( "states" )
	if ( statesIndex > 0 )
		titan.SetBodygroup( statesIndex, 0 )

	// maelstrom
    entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
    if ( IsValid( smokeWeapon ) ) // take off maelstrom, will be given by loadout funcs
    {
        array<string> mods = smokeWeapon.GetMods()
        mods.removebyvalue( "maelstrom" )
        smokeWeapon.SetMods( mods )
    }

    // superior chassis
    entity soul = titan.GetTitanSoul()
    if ( IsValid( soul ) )
    {
        if ( titan.IsPlayer() )
        {
            array<string> settingMods = titan.GetPlayerSettingsMods()
            if ( settingMods.contains( "core_health_upgrade" ) ) // monarch upgrade
			{
				if ( !GetDoomedState( titan ) && IsAlive( titan ) )
				{
					settingMods.removebyvalue( "core_health_upgrade" ) // remove existing classmod
					// update health and class
					float healthFrac = GetHealthFrac( titan )
					titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
					int maxHealth = titan.GetMaxHealth()
					titan.SetHealth( int( maxHealth * healthFrac ) )

					soul.soul.titanLoadout.setFileMods.removebyvalue( "core_health_upgrade" ) // remove from setFileMods
				}

				// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
				soul.SetPreventCrits( false ) // clean up
			}
        }
    }
}

// archon
void function RegisterArchonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "archon", ArchonWeaponWeaponPropFunc, ArchonWeaponDisplayNameFunc, TitanReplace_BecomeArchon )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "tesla_core_charged" )
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "tesla_core_charged" )
}

entity function ArchonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "storm_launcher" ) )
		return 

	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )
	PlayFXOnEntity( $"wpn_arc_cannon_electricity", weaponProp, "muzzle_flash" ) // do a visual effect on weapon

	return weaponProp
}

string function ArchonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop

	if ( !mods.contains( "storm_launcher" ) )
		return ""

	return "執政官 技能組"
}

// brute
void function RegisterBruteTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "brute", BruteWeaponWeaponPropFunc, BruteWeaponDisplayNameFunc, TitanReplace_BecomeBrute )
}

entity function BruteWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function BruteWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute_rocket" ) )
		return ""

	return "野獸 技能組"
}

// brute4(modded)
void function RegisterModdedBrute4TitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "brute4_modded", ModdedBrute4WeaponWeaponPropFunc, ModdedBrute4WeaponDisplayNameFunc, TitanReplace_BecomeModdedBrute4 )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "brute4_cluster_payload_ammo" )
}

entity function ModdedBrute4WeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute4_quad_rocket" ) )
		return

	asset modelName = $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ModdedBrute4WeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute4_quad_rocket" ) )
		return ""

	return "野獸四號 技能組"
	/* // unused
	if( mods.contains( "straight_shot" ) )
		return "四段火箭(野獸四號) [直射系統]"
	if( mods.contains( "rapid_detonator" ) )
		return "四段火箭(野獸四號) [快速引爆]"
	return "四段火箭(野獸四號)"
	*/
}

// archon(modded)
void function RegisterModdedArchonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "archon_modded", ModdedArchonWeaponWeaponPropFunc, ModdedArchonWeaponDisplayNameFunc, TitanReplace_BecomeModdedArchon )
}

entity function ModdedArchonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "archon_arc_cannon" ) )
		return

	asset modelName = $"models/weapons/titan_arc_rifle/w_titan_arc_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )
	PlayFXOnEntity( $"wpn_arc_cannon_electricity", weaponProp, "muzzle_flash" ) // do a visual effect on weapon

	return weaponProp
}

string function ModdedArchonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "archon_arc_cannon" ) )
		return ""

	return "執政官 技能組"
	/* // unused
	if ( mods.contains( "capacitor" ) )
		return "電弧機炮 [電容器]"
	if ( mods.contains( "chain_reaction" ) )
		return "電弧機炮 [連鎖反應]"
	if ( mods.contains( "generator_mod" ) )
		return "電弧機炮 [發電裝置]"
	return "電弧機炮"
	*/
}


///// utilities
void function TakeTitanEarnMeterSmoke( entity titan )
{
	titan.EndSignal( "OnDestroy" )

	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	
	// change PAS_ANTI_RODEO to PAS_HYPER_CORE
	if ( SoulHasPassive( soul, ePassives.PAS_ANTI_RODEO ) )
	{
		TakePassive( soul, ePassives.PAS_ANTI_RODEO )
		GivePassive( soul, ePassives.PAS_HYPER_CORE )
		if ( TitanDamageRewardsTitanCoreTime() )
			SoulTitanCore_SetNextAvailableTime( soul, 0.20 )
	}

	WaitEndFrame() // wait for titan get smoke weapon

	titan.TakeOffhandWeapon( OFFHAND_INVENTORY )
}

void function TitanReplace_RegisterPassiveType( int passive, int passiveType )
{
	if ( !( passive in file.titanPassiveType ) )
		file.titanPassiveType[ passive ] <- passiveType
	else
	{
		print( "[TITAN REPLACE] Passive index " + string( passive ) + " Has already been registered" )
	}
}

void function TitanReplace_RegisterCharacterOwnedPassives( string characterName, array<int> passives )
{
	if ( !( characterName in file.titanCharacterOwnedPassives ) )
		file.titanCharacterOwnedPassives[ characterName ] <- passives
	else
	{
		print( "[TITAN REPLACE] Titan characer " + characterName + " already have owned passives registered" )
	}
}

// change to settings, no longer hardcoded
int function TitanReplace_GetPassiveType( int passive )
{
	if ( !( passive in file.titanPassiveType ) )
		return -1 // invalid!

	return file.titanPassiveType[ passive ]
}

void function TitanReplace_RemoveUnmatchedPassivesForTitan( entity titan )
{
    if( !titan.IsTitan() )
		return

	string charaName = TitanPick_GetTitanWeaponDropCharacterName( titan )
	// for npcs, we take passives from their soul
	if ( !titan.IsPlayer() )
	{
		titan = titan.GetTitanSoul()
		if ( !IsValid( titan ) )
			return
	}

	foreach ( name, passives in file.titanCharacterOwnedPassives )
	{
		if ( charaName != name )
		{
			foreach ( passive in passives )
			{
				// debug
				string passiveName
				foreach ( name, index in _PassiveFromEnum )
				{
					if ( index == passive )
						passiveName = name
				}
				print( "REMOVING passive: " + passiveName )
				TakePassive( titan, passive )
			}
		}
	}
}

void function ChangeSoulTitanExecution( entity soul, string desiredRef, string desiredRandomRef, bool checkPrime = true )
{
	TitanLoadoutDef loadout = soul.soul.titanLoadout
	
	string curRef = loadout.titanExecution
	bool isRandom = curRef.find( "random" ) != null //
	//print( "isRandom: " + string ( isRandom ) )
	if ( isRandom )
	{
		//print( "soul has random execution, try changing to new one: " + desiredRandomRef )
		soul.soul.titanLoadout.titanExecution = desiredRandomRef
		return
	}

	// non-random checks
	string primeSuffix = ""
	if ( checkPrime && loadout.isPrime == "titan_is_prime" )
		primeSuffix = "_prime"
	string newRef = desiredRef + primeSuffix
	//print( "try changing to execution: " + newRef )
	soul.soul.titanLoadout.titanExecution = newRef
}