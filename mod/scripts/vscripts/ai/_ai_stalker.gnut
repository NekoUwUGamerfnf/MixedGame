//
// Base npc script shared between all npc types (regular, suicide, etc.)
//

untyped
global function AiStalker_Init
global function GetDeathForce
global function StalkerGearOverloads
global function StalkerMeltingDown
global function IsStalkerLimbBlownOff

// FD stalker shouldn't be in this file, it's hardcoded as hell
global function FDStalkerThink

/*
	// nessie TODO:
		- make stalkers no longer overload in any critical hit, 
		  instead add a setting that makes overloading hit uses health percent like gibbing the body parts
		  also make npcs able to overload them...? because we have npc critcal hit settings

		- make FD stalkers no longer hardcoded to specific gamemode
		  the sprinting and overload think needs able to be called by any function
*/

// modified settings
global function AiStalker_SetDismemberHitGroupRequiredDamage // negative value means always dismember
//global function AiStalker_SetDamageRequiredToHeadshot // maybe can be merged into AiStalker_SetDismemberHitGroupRequiredDamage()? use HITGROUP_HEAD
global function AiStalker_SetGearOverloadOnHitRequiredHealthPercent
global function AiStalker_SetUpGearOverloadOnDeath // should we make them not overloading on stepping on? idk maybe make that a setting to

global function AiStalker_SetGearOverloadDuration
global function AiStalker_SetCrawlLifeTime

global function AiStalker_SetStaggerRequiredHealthPercent // negative value means they never stagger
global function AiStalker_SetHealthPercentOnTransitionToCrawl // negative value( like -1 ) means we don't change health on stalker starts crawl

global function AiStalker_SetCreateHeavyArmorDangerousArea // make titans try to dodge when a stalker is overloading

// these are vanilla consts
const float STALKER_DAMAGE_REQUIRED_TO_HEADSHOT = 0.3
const STALKER_REACTOR_CRITIMPACT_SOUND_1P_VS_3P = "ai_stalker_bulletimpact_nukecrit_1p_vs_3p"
const STALKER_REACTOR_CRITIMPACT_SOUND_3P_VS_3P = "ai_stalker_bulletimpact_nukecrit_3p_vs_3p"
const STALKER_REACTOR_CRITICAL_SOUND = "ai_stalker_nukedestruct_warmup_3p"
const STALKER_REACTOR_CRITICAL_FX = $"P_spectre_suicide_warn"

// modified consts to get rid of vanilla meaningless variables
const float STALKER_GEAR_OVERLOAD_DURATION = 2.1

global const float STALKER_DISMEMBER_DAMAGE_ALWAYS = -1.0 // negative value means we always dismember
global const float STALKER_DISMEMBER_DAMAGE_DISABLED = 10000.0 // 1000000% of max health, only gets dismembered after death

// fun fact: vanilla didn't use limbHealthPercentOfMax in function StalkerLimbBlownOff() AT ALL
// which means in vanilla all of stalker's bodyGroup( except for right arm ) gets dismembered in ONE SHOT
// keeping vanilla value as negative so they always get dismembered, right arm should never be dismembered in vanilla
const float STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_LEFT_ARM = STALKER_DISMEMBER_DAMAGE_ALWAYS // losing left arm disables their ability to do syncedMelee against other npcs
const float STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_RIGHT_ARM = STALKER_DISMEMBER_DAMAGE_DISABLED // vanilla don't have dismembering right arm feature, might because it's the arm they used for holding weapons
const float STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_LEFT_LEG = STALKER_DISMEMBER_DAMAGE_ALWAYS // losing a leg makes them crawling
const float STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_RIGHT_LEG = STALKER_DISMEMBER_DAMAGE_ALWAYS // losing a leg makes them crawling

const float STALKER_CRAWL_LIFE_SUPPORT_DURATION = 8 // gets added to death time if stalker has LOS of enemy
const float STALKER_CRAWL_MAX_TIME_BEFORE_DEATH = 16 // max death time a crawling stalker can have

global const float STALKER_STAGGER_DAMAGE_DISABLED = -1.0 // negative value means they never stagger
const float STALKER_DAMAGE_REQUIRED_TO_STAGGER = 0.5

global const float STALKER_MAINTAIN_HEALTH_ON_TRANSITION_TO_CRAWL = -1.0 // negative value( like -1 ) means we don't change health on stalker starts crawl
const float STALKER_HEALTH_ON_TRANSITION_TO_CRAWL = 0.5

// modified settings default value
const float STALKER_HEALTH_PERCENT_REQUIRED_TO_OVERLOAD_ON_HIT = 1.0 // in vanilla stalker can be overloaded in any gear hit
const bool STALKER_OVERLOAD_ON_DEATH = false
const bool STALKER_SHOULD_OVERLOAD_ON_HEADSHOT_DEATH = false
const bool STALKER_ONLY_OVERLOAD_ON_KILLED_BY_TITAN = false
const bool STALKER_USE_LAST_ATTACKER_TO_SELF_TERMINATE = false // in vanilla stalker just dies
const bool STALKER_SHOULD_CREATE_HEAVY_ARMOR_DANGEROUS_AREA = false

// HACKY way to fix right arm lost stalkers: use sp zombie stalker setfile for handling melee behavior
const table<string, string> HACK_STALKER_MELEE_SETFILE = 
{
	["npc_stalker"]		= "npc_stalker_zombie",
	["npc_stalker_fd"]	= "npc_stalker_zombie_mossy",
}

// structs for storing modified settings
// modified settings: can set stalkers to always overload on death
struct StalkerDeathOverloadSettings
{
	bool alwaysOverloadOnDeath
	bool noOverloadOnHeadshot
	bool onlyOverloadOnKilledByTitans
}

struct StalkerCrawlLifeTimeSettings // vanilla behavior turns to settings
{
	float lifeSupportDuration
	float maxDeathTime
	bool useLastAttackerToSelfTerminate // modified settings: rewards last attacker the kill if stlaker self terminates
}

struct
{
	// modified variable for handling stalker killshot
	table<entity, bool> stalkerOverloadedFromThisDamage

	table< entity, table<int, float> > stalkerDismemberHitGroupRequiredDamage
	table<entity, float> stalkerGearOverloadOnHitRequiredHealthPercent
	table<entity, StalkerDeathOverloadSettings> stalkerGearOverloadOnDeathSettingsTable
	table<entity, float> stalkerGearOverloadDuration
	table<entity, StalkerCrawlLifeTimeSettings> stalkerCrawlLifeTimeSettingsTable
	table<entity, float> stalkerStaggerRequiredHealthPercent
	table<entity, float> stalkerHealthPercentOnTransitionToCrawl
	table<entity, bool> stalkerShouldCreateHeavyArmorDangerousArea
} file
//


void function AiStalker_Init()
{
	PrecacheImpactEffectTable( "exp_stalker_powersupply" )
	PrecacheImpactEffectTable( "exp_small_stalker_powersupply" )
	PrecacheParticleSystem( STALKER_REACTOR_CRITICAL_FX )
	AddDamageCallback( "npc_stalker", StalkerOnDamaged ) // why this isn't final damage or post damage?
	AddDeathCallback( "npc_stalker", StalkerOnDeath )
	AddSpawnCallback( "npc_stalker", StalkerOnSpawned )

	// modified for pre-death overload
	// AddDamageCallback() can't handle modified damage like plasma railgun and scorch thermites
	AddDamageFinalCallback( "npc_stalker", StalkerOnFinalDamaged )
}

void function StalkerOnSpawned( entity npc )
{
	StalkerOnSpawned_Think( npc )
}

void function StalkerOnSpawned_Think( entity npc )
{
	npc.SetCanBeMeleeExecuted( false ) // this is for player syncedMelee only

	for ( int hitGroup = 0; hitGroup < HITGROUP_COUNT; hitGroup++ )
	{
		npc.ai.stalkerHitgroupDamageAccumulated[ hitGroup ] <- 0
		npc.ai.stalkerHitgroupLastHitTime[ hitGroup ] <- 0
	}

	// modified variable for handling stalker killshot
	file.stalkerOverloadedFromThisDamage[ npc ] <- false

	if ( npc.Dev_GetAISettingByKeyField( "ScriptSpawnAsCrawler" ) == 1 )
	{
		EnableStalkerCrawlingBehavior( npc )
		PlayCrawlingAnim( npc, "ACT_RUN" )
		npc.Anim_Stop() // start playing a crawl anim then cut it off so it doesnt loop
	}
}

void function StalkerOnDeath( entity npc, var damageInfo )
{
	thread StalkerOnDeath_Internal( npc, damageInfo )

	#if MP
	int sourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	if ( sourceId == eDamageSourceId.damagedef_titan_step ) // so this is also hardcoded... not funny, really
	{
		// make this a function
		/*
		Explosion_DamageDefSimple(
			damagedef_stalker_powersupply_explosion_large_at,
			npc.GetOrigin(),
			npc,
			npc,
			npc.GetOrigin()
		)
		*/
		StalkerExplodeOnSteppedOn( npc )
	}
	#endif

}

void function StalkerExplodeOnSteppedOn( entity npc )
{
	Explosion_DamageDefSimple(
		damagedef_stalker_powersupply_explosion_large_at,
		npc.GetOrigin(),
		npc,
		npc,
		npc.GetOrigin()
	)
}

void function StalkerOnDeath_Internal( entity npc, var damageInfo )
{
	int customDamageFlags = DamageInfo_GetCustomDamageType( damageInfo )
	bool allowDismemberment = bool( customDamageFlags & DF_DISMEMBERMENT )
	if ( allowDismemberment )
	{
		int hitGroup = GetHitGroupFromDamageInfo( npc, damageInfo )
		if ( hitGroup >= HITGROUP_GENERIC )
		{
			entity attacker = DamageInfo_GetAttacker( damageInfo )
			TryDismemberStalker( npc, damageInfo, attacker, hitGroup )
		}
	}

	if ( IsCrawling( npc ) )
	{
		WaitFrame() // or head won't disappear
		if ( IsValid( npc ) )
			npc.BecomeRagdoll( Vector( 0, 0, 0 ), false )
		return
	}
}


// All damage to stalkers comes here for modification and then either branches out to other npc types (Suicide, etc) for custom stuff or it just continues like normal.
void function StalkerOnDamaged( entity npc, var damageInfo )
{
	StalkerOnDamaged_Internal( npc, damageInfo )
}

void function StalkerOnDamaged_Internal( entity npc, var damageInfo )
{
	// modified: clean up variable every time stalker takes damage
	file.stalkerOverloadedFromThisDamage[ npc ] = false

	if ( !IsAlive( npc ) )
		return

	if ( StalkerMeltingDown( npc ) )
	{
		DamageInfo_ScaleDamage( damageInfo, 0.0 )
		return
	}

	// can't shoot, don't blow off limbs
	if ( IsCrawling( npc ) )
	{
		if ( Time() - npc.ai.startCrawlingTime < 0.75 )
		{
			DamageInfo_SetDamage( damageInfo, 0 )
			return
		}
	}

	int hitGroup = GetHitGroupFromDamageInfo( npc, damageInfo )
	if ( hitGroup < HITGROUP_GENERIC )
		hitGroup = HITGROUP_GENERIC

	float damage = DamageInfo_GetDamage( damageInfo )

	// modified here: we've added shield health for npcs that can't use shield normally
	// now we do nothing if shield can blank out the damage
	// no further checks, maybe not accurate but whatever
	if ( GetShieldHealthWithFix( npc ) - int( damage ) >= 0 )
		return
	//

	// limb dead yet?
	npc.ai.stalkerHitgroupDamageAccumulated[ hitGroup ] += int( damage )
	npc.ai.stalkerHitgroupLastHitTime[ hitGroup ] = Time()

	entity attacker = DamageInfo_GetAttacker( damageInfo )

	// modified here: use a better check for handling modified overload cases
	//if ( PlayerHitGear( npc, damageInfo, hitGroup ) )
	if ( DamageShouldOverloadStalker( npc, damageInfo ) )
	{
		StalkerGearOverloadsFromDamageInfo( npc, damageInfo )

		// modified condition: overload on death
		// if we reached here it must means this stalker won't die from damage
		if ( AiStalker_ShouldOverloadOnDeath( npc ) )
		{
			// only setup this for modded stalkers...
			// vanilla stalker can still be killed when being shot at weakpoint with plasma railgun
			// what it seems like: 
			// stalker took basic damage from railgun, triggering overload, damage is reduced to not killing them
			// railgun increases damage taken, which called later than this function and damage maybe enough to kill them

			// to not break vanilla behavior, only setup variables in this modded scope...
			file.stalkerOverloadedFromThisDamage[ npc ] = true

			// hardcoded for stepping, so they can still deal burst explosion damage and then go to overload
			// this will cause self damage to stalker, so it's better to handle it here, after StalkerMeltingDown() can return true
			if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == eDamageSourceId.damagedef_titan_step )
				StalkerExplodeOnSteppedOn( npc )
		}
		//

		return
	}

	int customDamageFlags = DamageInfo_GetCustomDamageType( damageInfo )
	bool allowDismemberment = bool( customDamageFlags & DF_DISMEMBERMENT )
	if ( !allowDismemberment )
		return

	bool canBeStaggered = TryDismemberStalker( npc, damageInfo, attacker, hitGroup )

	if ( canBeStaggered && !IsCrawling( npc ) && !npc.ai.transitioningToCrawl )
	{
		// modified: use settings for triggering stagger
		/*
		if ( npc.GetHealth().tofloat() / npc.GetMaxHealth().tofloat() <= 0.5 )
		{
			thread AttemptStandToStaggerAnimation( npc )
			npc.SetActivityModifier( ACT_MODIFIER_STAGGER, true )
		}
		*/
		float staggerRequiredHealth = AiStalker_GetStaggerRequiredHealthPercent( npc )
		if ( staggerRequiredHealth > 0 ) // negative value means they never stagger
		{
			if ( npc.GetHealth().tofloat() / npc.GetMaxHealth().tofloat() <= staggerRequiredHealth )
			{
				thread AttemptStandToStaggerAnimation( npc )
				npc.SetActivityModifier( ACT_MODIFIER_STAGGER, true )
			}
		}
	}

	// this is seriously hardcoded, shoud add a setting like "AiStalker_EnableSprintOnDamaged"
	// or just move into FDStalkerThink
	if ( GameRules_GetGameMode() == FD )
		thread StalkerSprint( npc, damageInfo )
	/*
		// temp:
			thread StalkerSprintOnDamageThink( stalker )

			void function StalkerSprintOnDamageThink( entity stalker )
			{
				stalker.EndSignal( "OnDeath" )
				stalker.EndSignal( "OnDestroy" )
				while ( true )
				{
					WaitFrame()
					if ( StalkerMeltingDown( stalker ) || IsCrawling( stalker ) )
						return
					
					if ( npc.GetHealth() > 50 )
						continue

					thread StalkerSprint( stalker )
					return
				}
			}
	*/
}

void function StalkerDeathProtection( entity npc, var damageInfo )
{
	// don't die from damage
	float damage = DamageInfo_GetDamage( damageInfo )
	damage = npc.GetHealth() - 1.0
	DamageInfo_SetDamage( damageInfo, damage )
}

void function StalkerGearOverloadsFromDamageInfo( entity npc, var damageInfo )
{
	// melting down checks so we don't do it over and over
	if ( StalkerMeltingDown( npc ) )
		return
	
	// don't die from damage
	StalkerDeathProtection( npc, damageInfo )

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	thread StalkerGearOverloads( npc, attacker )

	// vanilla missing behavior: add DF_KILLSHOT for overloading hit, so player can better know that they killed stalker
	// this breaks vanilla behavior but whatever
	// due we added npc position based damage, killshot should leave only for players
	if ( IsValid( attacker ) && attacker.IsPlayer() )
		DamageInfo_AddCustomDamageType( damageInfo, DF_KILLSHOT )
	// no more killshot sound after we add it manually
	npc.ai.killShotSound = false
}

// modified condition here, basically for pre-death overload
// AddDamageCallback() can't handle modified damage like plasma railgun and scorch thermites
void function StalkerOnFinalDamaged( entity npc, var damageInfo )
{
	if ( !IsAlive( npc ) )
		return
	
	// modified here: we've added shield health for npcs that can't use shield normally
	// now we do nothing if shield can blank out the damage
	// no further checks, maybe not accurate but whatever
	if ( GetShieldHealthWithFix( npc ) - int( DamageInfo_GetDamage( damageInfo ) ) >= 0 )
		return

	// modified condition here: if stalker already overloaded in StalkerOnDamaged_Internal()
	// we reduce the damage so nothing can kill them
	if ( file.stalkerOverloadedFromThisDamage[ npc ] )
	{
		// don't die from damage
		StalkerDeathProtection( npc, damageInfo )
		return
	}

	// use a better check for handling modified overload cases
	if ( DamageShouldOverloadStalker( npc, damageInfo ) )
	{
		StalkerGearOverloadsFromDamageInfo( npc, damageInfo )
		return
	}
}

// this should be renamed as StalkerTrySprintOnDamaged(), move the sprinting codes into StalkerSprint()
void function StalkerSprint( entity npc, var damageInfo )
{
	npc.EndSignal("OnDeath")
	npc.EndSignal("OnDestroy")
	float damage = DamageInfo_GetDamage( damageInfo )

	if (!IsCrawling(npc)&&( npc.GetHealth() - damage < 50 || npc.GetHealth() <= 80))
	{
		// the sprinting really should be a function instead of runnig the same code everywhere
		entity weapon = npc.GetActiveWeapon()
		if (IsValid(weapon))
			npc.TakeActiveWeapon() // when stalkers fall over on harvester they will randomly shoot their guns, we don't want that.
		npc.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
		npc.SetCapabilityFlag( bits_CAP_MOVE_SHOOT | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )
		npc.SetNPCFlag( NPC_IGNORE_ALL, true )
		npc.SetNPCFlag( NPC_DISABLE_SENSING, true )
		npc.SetNoTarget( true )
		npc.ClearMoveAnim()
		npc.SetMoveAnim("sp_spectre_sprint_F")
		npc.s.isSprinting = true
	}
}
/*
	// temp:
		void function StalkerSprint( entity stalker )
		{
			if ( !StalkerCanSprint( stalker ) )
				return

			// unsure if kv.allowShoot = 0 can prevent stalkers from shooting when getting stunned
			//entity weapon = stalker.GetActiveWeapon()
			//if ( IsValid(weapon) )
			//	stalker.TakeActiveWeapon() // when stalkers fall over on harvester they will randomly shoot their guns, we don't want that.
			
			stalker.kv.allowShoot = 0 // when stalkers fall over on harvester they will randomly shoot their guns, we don't want that.
			stalker.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
			stalker.SetCapabilityFlag( bits_CAP_MOVE_SHOOT | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )
			stalker.SetNPCFlag( NPC_IGNORE_ALL, true )
			stalker.SetNPCFlag( NPC_DISABLE_SENSING, true )
			stalker.SetNoTarget( true )
			stalker.ClearMoveAnim()
			stalker.SetMoveAnim("sp_spectre_sprint_F")
			stalker.s.isSprinting = true
		}

		bool function StalkerCanSprint( entity stalker )
		{
			// cant sprint with 1 leg or already exploding
			if ( IsCrawling( stalker ) || StalkerMeltingDown( stalker ) )
				return false
			
			// can't sprint if not setting up
			if ( "isSprinting" in stalker.s )
				return false
			
			// can't sprint if already sprinting
			if ( stalker.s.isSprinting )
				return false
			
			// all checks passed
			return true
		}
*/

// this is hardcoded as hell
void function FDStalkerThink( entity npc, entity generator )
{
	npc.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" )
	generator.EndSignal( "OnDeath" )
	generator.EndSignal( "OnDestroy" )
	npc.s.isSprinting <- false
	thread FDStalkerGetsStunned( npc , generator )
	while ( IsAlive( npc ) )
	{
		WaitFrame()

		// cant sprint with 1 leg
		// also upped to 1800 so that stalkers sprint from roughly their vanilla positions, could probably do it based on % of distance left to go?
		if ( DistanceSqr( npc.GetOrigin(), generator.GetOrigin() ) < (1800 * 1800)  )
		{
			if(!IsCrawling( npc ) && !npc.s.isSprinting)
			{
				entity weapon = npc.GetActiveWeapon()
				if (IsValid(weapon))
					npc.TakeActiveWeapon() // when stalkers fall over on harvester they will randomly shoot their guns, we don't want that.
				npc.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
				npc.SetCapabilityFlag( bits_CAP_MOVE_SHOOT | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )
				npc.EnableNPCFlag( NPC_DISABLE_SENSING | NPC_IGNORE_ALL )
				npc.ClearMoveAnim()
				npc.SetMoveAnim("sp_spectre_sprint_F")
				npc.SetNoTarget( true )
				// stalkers were just going to the final node and stopping, meaning they never actually reached the harvester
				npc.s.isSprinting = true
			}
			npc.AssaultPoint(generator.GetOrigin())
		}

		// upped from 230 to more accurately mimic vanilla i think?
		if ( DistanceSqr( npc.GetOrigin(), generator.GetOrigin() ) > (275 * 275) )
			continue

		break
	}

	thread StalkerGearOverloads( npc )
}

void function FDStalkerGetsStunned( entity npc , entity generator )
{
	npc.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" )
	npc.WaitSignal( "ArcStunned" )
	print("arc trapped...")

	if(IsCrawling(npc))
		return

	entity weapon = npc.GetActiveWeapon()
	if (IsValid(weapon))
		npc.TakeActiveWeapon() // when stalkers fall over on harvester they will randomly shoot their guns, we don't want that.
	npc.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT )
	npc.SetCapabilityFlag( bits_CAP_MOVE_SHOOT | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )
	npc.EnableNPCFlag( NPC_DISABLE_SENSING | NPC_IGNORE_ALL )
	npc.ClearMoveAnim()
	npc.SetMoveAnim("sp_spectre_sprint_F")
	npc.SetNoTarget( true ) // stop keeping track of any player and instead go for the harvester
	npc.s.isSprinting = true
}
// FD hardcoded stuffs end

bool function TryDismemberStalker( entity npc, var damageInfo, entity attacker, int hitGroup )
{
	string fpSound
	string tpSound

	switch ( hitGroup )
	{
		case HITGROUP_CHEST:
		case HITGROUP_STOMACH:
			fpSound = "AndroidArmored.BulletImpact_1P_vs_3P"
			tpSound = "AndroidArmored.BulletImpact_3P_vs_3P"
			break

		default:
			fpSound = "AndroidVulnerable.BulletImpact_1P_vs_3P"
			tpSound = "AndroidVulnerable.BulletImpact_3P_vs_3P"
			break
	}

	if ( IsAlive( attacker ) && attacker.IsPlayer() )
	{
		EmitSoundOnEntityOnlyToPlayer( npc, attacker, fpSound )
		EmitSoundOnEntityExceptToPlayer( npc, attacker, tpSound )
	}
	else
	{
		EmitSoundOnEntity( npc, tpSound )
	}

	bool justAFleshWound = true

	switch ( hitGroup )
	{
		case HITGROUP_HEAD:
			thread StalkerHeadShot( npc, damageInfo, hitGroup )
			justAFleshWound = false
			break

		case HITGROUP_LEFTARM:
			// modified here: use settings damage for dismembering a stalker, no longer hardcoded
			//if ( StalkerLimbBlownOff( npc, damageInfo, hitGroup, 0.085, "left_arm", [ "left_arm", "l_hand" ], "Spectre.Arm.Explode" ) )
			if ( StalkerLimbBlownOff( 
					npc, 
					damageInfo, 
					hitGroup, 
					AiStalker_GetDamageRequiredToDismemberHitGroup( npc, HITGROUP_LEFTARM ), 
					"left_arm", 
					[ "left_arm", "l_hand" ], 
					"Spectre.Arm.Explode" 
				) )
			{
				npc.SetActivityModifier( ACT_MODIFIER_ONEHANDED, true )

				// Some of his synced melees depend on using his left arm
				npc.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false )
			}
			break

		// modified hitgroup: RIGHTARM
		// this isn't featured in vanilla possibly because stalker depend on this arm to shoot
		// but I want to add it for fun
		// note that a standing stalker will become nearly unharmful after taking out their right arm
		// now using a HACKY way to fix: change to crawling settings so they can start chasing enemies
		// changed to another HACKY way: use sp zombie stalker setfile for handling it's melee behavior
		case HITGROUP_RIGHTARM:
			if ( StalkerLimbBlownOff( 
					npc, 
					damageInfo, 
					hitGroup, 
					AiStalker_GetDamageRequiredToDismemberHitGroup( npc, HITGROUP_RIGHTARM ), 
					"right_arm", 
					[ "right_arm", "r_hand" ], 
					"Spectre.Arm.Explode" 
				) )
			{
				// drop down weapon
				entity activeWeapon = npc.GetActiveWeapon()
				if ( IsValid( activeWeapon ) )
				{
					npc.DropWeapon( activeWeapon )
					activeWeapon.SetVelocity( npc.GetVelocity() )
				}
				// remove all weapons
				TakeAllWeapons( npc )

				// many ability depending on their right arm, they can only do un-charged melee now
				npc.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK | bits_CAP_INNATE_MELEE_ATTACK2 | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )

				// not crawling: try to make them start melee behavior
				if ( !IsCrawling( npc ) )
				{
					// HERE'S HACKY: change to crawling settings makes them able to chase their target( lowered chaseStopDist )
					// breaks some behavior( like bad replay camera offset and weird stair walking )
					// but whatever, modifying only server-side is too hard to handle everything
					//string crawlingSettings = string ( npc.Dev_GetAISettingByKeyField( "crawlingSettingsWrapper" ) )
					// Changing the setting file includes changing the behavior file to	"behavior_stalker_crawling"
					//SetAISettingsWrapper( npc, crawlingSettings )

					// changed to another HACKY way: use sp zombie stalker setfile for handling it's melee behavior
					string aiSettings = npc.GetAISettingsName()
					if ( aiSettings in HACK_STALKER_MELEE_SETFILE )
					{
						string meleeSetFile = HACK_STALKER_MELEE_SETFILE[ aiSettings ]
						// Changing the setting file includes changing the behavior file to	"behavior_stalker_crawling"
						// standing stalkers sometimes pretty silly about melee... don't know what to do with that
						SetAISettingsWrapper( npc, meleeSetFile )
					}
				}
				else // already crawling: disable uncharged melee attack
				{
					npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false )
				}
			}
			
			break
		//

		case HITGROUP_LEFTLEG:
			// modified here: use settings damage for dismembering a stalker, no longer hardcoded
			//justAFleshWound = TryLegBlownOff( npc, damageInfo, hitGroup, 0.17, "left_leg", [ "left_leg", "foot_L_sole" ], "Spectre.Leg.Explode" )
			justAFleshWound = TryLegBlownOff( 
								  npc, 
								  damageInfo, 
								  hitGroup, 
								  AiStalker_GetDamageRequiredToDismemberHitGroup( npc, HITGROUP_LEFTLEG ), 
								  "left_leg", 
								  [ "left_leg", "foot_L_sole" ], 
								  "Spectre.Leg.Explode" 
							  )
			break

		case HITGROUP_RIGHTLEG:
			// modified here: use settings damage for dismembering a stalker, no longer hardcoded
			//justAFleshWound = TryLegBlownOff( npc, damageInfo, hitGroup, 0.17, "right_leg", [ "right_leg", "foot_R_sole" ], "Spectre.Leg.Explode" )
			justAFleshWound = TryLegBlownOff( 
								  npc, 
								  damageInfo, 
								  hitGroup, 
								  AiStalker_GetDamageRequiredToDismemberHitGroup( npc, HITGROUP_RIGHTLEG ), 
								  "right_leg", 
								  [ "right_leg", "foot_R_sole" ], 
								  "Spectre.Leg.Explode" 
							  )
			break
	}

	// here goes a modiifed condition: we've added dismembering right arm
	// means that we can now dismember all of stalker's arms
	if ( IsStalkerAllArmsBlownOff( npc ) )
	{
		// make crawling stalker stop moving
		// this can't handle stalker that starts crawling from current function call 
		// because FallAndBecomeCrawlingStalker() will delay at least 1 frame before setting stalker to crawling
		// but SelfTerminateAfterDelay() will automatically kill stalkers those're still in falling animation
		// should working fine
		if ( IsCrawling( npc ) ) 
		{
			//print( "Stalker can't even crawl!" )
			npc.SetNPCMoveSpeedScale( 0.1 ) // stops moving. set to 0.0 won't change anything
			justAFleshWound = false // this isn't a flesh wound, really hurts!
		}

		// for any case, if both of their arms lost, disable ability to do uncharged melee( charged melee already disabled when losing right arm )
		npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false )
	}

	return justAFleshWound
}

// now using this for handle more stuffs, modified!
bool function DamageShouldOverloadStalker( entity npc, var damageInfo )
{
	// same hitGroup check as StalkerOnDamaged_Internal()
	int hitGroup = GetHitGroupFromDamageInfo( npc, damageInfo )
	if ( hitGroup < HITGROUP_GENERIC )
		hitGroup = HITGROUP_GENERIC
	
	float health = npc.GetHealth().tofloat()
	float damage = DamageInfo_GetDamage( damageInfo )
	// modified check: killshot to overload
	bool isKillShot = health - damage <= 1.0 // hitting stalker to 1HP means we can overload them. prevent accidentally kill them
	if ( isKillShot )
	{
		if ( AiStalker_ShouldOverloadOnDeath( npc ) )
		{
			entity attacker = DamageInfo_GetAttacker( damageInfo )
			// titans check
			bool attackerIsTitan = IsValid( attacker ) && attacker.IsTitan()
			bool canOverloadOnDeath = !AiStalker_OnlyOverloadOnKilledByTitan( npc )
			if ( attackerIsTitan )
				canOverloadOnDeath = true // titans always do overload

			if ( canOverloadOnDeath )
			{
				// headshot check
				if ( !AiStalker_ShouldOverloadOnHeadshotDeath( npc ) )
				{
					if ( !IsValidHeadShot( damageInfo, npc ) )
						return true
				}
				else // no more restriction, just overload on kill
					return true
			}
		}
	}

	// vanilla check: PlayerHitGear()
	if ( PlayerHitGear( npc, damageInfo, hitGroup ) )
	{
		// modified check: hit gear to overload required health percent
		float healthFracLeft = ( health - damage ) / npc.GetMaxHealth().tofloat() // we may one-shot the stalker, needs to minus current hit's damage
		bool canOverloadByHit = healthFracLeft < AiStalker_GetHealthPercentRequiredToOverloadOnHitGear( npc )
		//print( "healthFracLeft: " + string( healthFracLeft ) )
		//print( "requiredHitOverloadFrac: " + string( AiStalker_GetHealthPercentRequiredToOverloadOnHitGear( npc ) ) )
		if ( canOverloadByHit )
			return true
	}

	// default case is never overload
	return false
}

// this function really isn't good enough, should be "DamageShouldOverloadStalker"
bool function PlayerHitGear( entity npc, var damageInfo, int hitGroup )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )

	// modified: we've add npc location based damage in sh_damage_utility.gnut, npcs can do special hit group checks
	//if ( !attacker.IsPlayer() )
	if ( !attacker.IsPlayer() && !DamageUtility_IsNPCLocationBasedDamageEnabled() )
		return false

	if ( hitGroup != HITGROUP_GEAR )
		return false

	if ( !( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET ) )
		return false

	return true
}

int function GetHitGroupFromDamageInfo( entity npc, var damageInfo )
{
	int hitGroup = DamageInfo_GetHitGroup( damageInfo )

	if ( hitGroup <= HITGROUP_GENERIC )
	{
		int hitBox = DamageInfo_GetHitBox( damageInfo )
		if ( hitBox >= 0 )
			return GetHitgroupForHitboxOnEntity( npc, hitBox )
	}

	return hitGroup
}

bool function StalkerMeltingDown( entity npc )
{
	int bodyGroup = npc.FindBodyGroup( "gear" )
	// defensive fix
	//Assert( bodyGroup != -1 )
	if ( bodyGroup == -1 ) // can't find this bodygroup! don't do overload things
	{
		//print( "crash handled! npc's modelName is: " + string( npc.GetModelName() ) )
		return true
	}

	// gear already blown up?
	return npc.GetBodyGroupState( bodyGroup ) != 0
}

void function StalkerGearOverloads( entity npc, entity attacker = null )
{
	Assert( !StalkerMeltingDown( npc ) )

	if ( !IsCrawling( npc ) && StalkerCanCrawl( npc ) )
		thread FallAndBecomeCrawlingStalker( npc )

	int bodyGroup = npc.FindBodyGroup( "gear" )

	// hide gear
	npc.SetBodygroup( bodyGroup, 1 )

	string attachment = "CHESTFOCUS"

	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )

	entity nukeFXInfoTarget = CreateEntity( "info_target" )
	nukeFXInfoTarget.kv.spawnflags = SF_INFOTARGET_ALWAYS_TRANSMIT_TO_CLIENT
	DispatchSpawn( nukeFXInfoTarget )

	nukeFXInfoTarget.SetParent( npc, attachment )

	// due we've added npc dismemberment, needs to check player validation
	//if ( attacker != null )
	if ( IsValid( attacker ) && attacker.IsPlayer() )
	{
		EmitSoundOnEntityOnlyToPlayer( nukeFXInfoTarget, attacker, STALKER_REACTOR_CRITIMPACT_SOUND_1P_VS_3P )
		EmitSoundOnEntityExceptToPlayer( nukeFXInfoTarget, attacker, STALKER_REACTOR_CRITIMPACT_SOUND_3P_VS_3P )
	}
	else
	{
		EmitSoundOnEntity( nukeFXInfoTarget, STALKER_REACTOR_CRITIMPACT_SOUND_3P_VS_3P )
	}

	EmitSoundOnEntity( nukeFXInfoTarget, STALKER_REACTOR_CRITICAL_SOUND )

	// modified to add settings, allow npc titans aware their explosions
	//AI_CreateDangerousArea_DamageDef( damagedef_stalker_powersupply_explosion_small, nukeFXInfoTarget, TEAM_INVALID, true, false )
	// this one doesn't seem working well...
	// to make titans able to aware them, maybe we need larger explosion radius
	//AI_CreateDangerousArea_DamageDef( damagedef_stalker_powersupply_explosion_small, nukeFXInfoTarget, TEAM_INVALID, true, AiStalker_GetShouldCreateHeavyArmorDangerousArea( npc ) )
	if ( AiStalker_GetShouldCreateHeavyArmorDangerousArea( npc ) )
	{
		AI_CreateDangerousArea_DamageDef( damagedef_stalker_powersupply_explosion_large, nukeFXInfoTarget, TEAM_INVALID, true, true )
		// also, things should work better if we make titans stop targeting them
		npc.SetNoTarget( true )
		npc.SetNoTargetSmartAmmo( true )
	}
	else // vanilla behavior
		AI_CreateDangerousArea_DamageDef( damagedef_stalker_powersupply_explosion_small, nukeFXInfoTarget, TEAM_INVALID, true, false )

	entity fx = PlayFXOnEntity( STALKER_REACTOR_CRITICAL_FX, nukeFXInfoTarget )

	OnThreadEnd(
	function() : ( nukeFXInfoTarget, fx, npc, attacker )
		{
			if ( IsValid( npc ) )
				StopSoundOnEntity( nukeFXInfoTarget, STALKER_REACTOR_CRITICAL_SOUND )

			if ( IsValid( nukeFXInfoTarget ) )
				nukeFXInfoTarget.Destroy()

			if ( IsValid( fx ) )
				fx.Destroy()

			if ( IsAlive( npc ) )
			{
				entity damageAttacker
				if ( IsValid( attacker ) )
					damageAttacker = attacker
				else
					damageAttacker = npc

				vector force = GetDeathForce()
				npc.Die( damageAttacker, npc, { force = force, scriptType = DF_GIB, damageSourceId = eDamageSourceId.suicideSpectreAoE } )
			}
		}
	)

	wait 1.0

	// modified to use a setting
	//float duration = 2.1
	float duration = AiStalker_GetGearOverloadDuration( npc )
	float endTime = Time() + duration
	float startTime = Time()

	int tagID = npc.LookupAttachment( "CHESTFOCUS" )

	for ( ;; )
	{
		float timePassed = Time() - startTime
		float explodeMin = Graph( timePassed, 0, duration, 0.4, 0.1 )
		float explodeMax = explodeMin + Graph( timePassed, 0, duration, 0.21, 0.1 )
		wait RandomFloatRange( explodeMin, explodeMax )

		entity damageAttacker = GetNPCAttackerEnt( npc, attacker )

		// origin = npc.GetWorldSpaceCenter()
		vector origin = npc.GetAttachmentOrigin( tagID )

		if ( Time() >= endTime )
		{
			Explosion_DamageDefSimple( damagedef_stalker_powersupply_explosion_large, origin, damageAttacker, npc, origin )
			break
		}
		else
		{
			Explosion_DamageDefSimple( damagedef_stalker_powersupply_explosion_small, origin, damageAttacker, npc, origin )
		}
	}
}

bool function StalkerCanCrawl( entity npc )
{
	if ( !IsAlive( npc ) )
		return false

	if ( npc.Anim_IsActive() )
		return false

	return true
}

bool function TryLegBlownOff( entity npc, var damageInfo, int hitGroup, float limbHealthPercentOfMax, string leg, array<string> fxTags, string sound )
{
	if ( IsCrawling( npc ) )
	{
		// can blow off leg if stalker is already crawling
		StalkerLimbBlownOff( npc, damageInfo, hitGroup, limbHealthPercentOfMax, leg, fxTags, sound )
		return true
	}

	if ( !StalkerCanCrawl( npc ) )
		return true

	if ( StalkerLimbBlownOff( npc, damageInfo, hitGroup, limbHealthPercentOfMax, leg, fxTags, sound ) )
	{
		thread FallAndBecomeCrawlingStalker( npc )
		return false
	}

	return true
}

void function EnableStalkerCrawlingBehavior( entity npc )
{
	Assert( StalkerCanCrawl( npc ) )
	Assert( !IsCrawling( npc ) )

	DisableLeeching( npc )

	DisableMinionUsesHeavyWeapons( npc )

	string crawlingSettings = string ( npc.Dev_GetAISettingByKeyField( "crawlingSettingsWrapper" ) )

	// Changing the setting file includes changing the behavior file to	"behavior_stalker_crawling"
	SetAISettingsWrapper( npc, crawlingSettings )

	npc.ai.crawling = true
	npc.ai.startCrawlingTime = Time()
	npc.DisableGrappleAttachment()
	npc.EnableNPCMoveFlag( NPCMF_DISABLE_ARRIVALS )
	npc.SetCapabilityFlag( bits_CAP_MOVE_TRAVERSE | bits_CAP_MOVE_SHOOT | bits_CAP_WEAPON_RANGE_ATTACK1 | bits_CAP_AIM_GUN, false )
	npc.SetActivityModifier( ACT_MODIFIER_CRAWL, true )
	npc.SetActivityModifier( ACT_MODIFIER_STAGGER, false )
	npc.SetCanBeGroundExecuted( true )
	npc.ClearMoveAnim()

	// modified: we've added dismembering right arm
	// stalkers shouldn't able to melee after losing it because crawling melee animation depending on right arm
	if ( IsStalkerLimbBlownOff( npc, "right_arm" ) )
		npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false ) // charged melee already disabled when losing arm, now we disable uncharged one

	// modified: use settings for handling, no longer hardcoded
	//npc.SetHealth( npc.GetMaxHealth() * 0.5 )
	float healthPercentCrawl = AiStalker_GetHealthPercentOnTransitioningToCrawl( npc )
	if ( healthPercentCrawl > 0 ) // we don't update health if this settings has been set to negative value
		npc.SetHealth( npc.GetMaxHealth() * min( 1.0, healthPercentCrawl ) )

	npc.SetAimAssistForcePullPitchEnabled( true )

	thread SelfTerminateAfterDelay( npc )

	// modified: if a crawling stalker can't melee at all, we should try to overload them
	thread SelfOverloadIfCantMelee( npc )
}

void function SelfTerminateAfterDelay( entity npc )
{
	// modified to turn these into settings
	//const float lifeSupportDuration = 8
	//float deathTime = Time() + (lifeSupportDuration * 2)
	float lifeSupportDuration = AiStalker_GetCrawlLifeSupportDuration( npc ) // we only cache them here, no need to update
	float maxDeathTime = AiStalker_GetCrawlMaxDeathTime( npc )
	float deathTime = Time() + maxDeathTime

	npc.EndSignal( "OnDestroy" ) // vanilla definitely missing this
	npc.EndSignal( "OnDeath" )
	for ( ;; )
	{
		entity enemy = npc.GetEnemy()
		if ( IsAlive( enemy ) )
		{
			if ( Distance( npc.GetEnemyLKP(), npc.GetOrigin() ) < 500 )
			{
				if ( npc.TimeSinceSeen( enemy ) < 3 )
					deathTime = max( Time() + lifeSupportDuration, deathTime )
			}
		}

		// vanilla checks
		bool stalkerDeathTimeReached = Time() > deathTime

		// here goes a modified condition: we've added dismembering right arm
		// means that we can now dismember all of stalker's arms
		// in that case they shouldn't able to crawl
		// if that ever happen, just make stalkers die because they can't do anything
		// also needs to wait for crawling transition to end
		// doing in this think is because 1s wait can add some randomness, looks good
		bool stalkerCantCrawl = IsStalkerAllArmsBlownOff( npc ) 
								&& !npc.ai.transitioningToCrawl

		// doing modified checks
		//if ( Time() > deathTime )
		if ( stalkerDeathTimeReached || stalkerCantCrawl )
		{
			// we've added lots of settings here
			//npc.Die()

			entity damageAttacker = GetSelfTerminateAttacker( npc )
			
			// modified settings: stalker can always overload on death
			if ( AiStalker_ShouldOverloadOnDeath( npc ) )
			{
				if ( !StalkerMeltingDown( npc ) ) // if stalker already melting down we do nothing. to keep vanilla behavior we shouldn't put this check outside
					thread StalkerGearOverloads( npc, damageAttacker )
			}
			else if ( IsStalkerAllArmsBlownOff( npc ) ) // all arms blown off, should ragdoll immediately. don't let any part of death animation go through
				npc.Die( damageAttacker, npc, { scriptType = DF_RAGDOLL, damageSourceId = damagedef_suicide } )
			else // normal death, vanilla behavior
				npc.Die( damageAttacker, npc, { damageSourceId = damagedef_suicide } ) // inflictor should always be npc themselves, to keep identical with StalkerGearOverloads()
			
			return
		}

		wait 1.0
	}
}

void function SelfOverloadIfCantMelee( entity npc )
{
	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )
	while ( true )
	{
		// we do nothing if stalker already overloads
		if ( StalkerMeltingDown( npc ) )
			return

		// if stalker has lost their right arm they're unable to melee
		// to prevent that, do overload if enemy is close enough
		entity enemy = npc.GetEnemy()
		bool doOverloadWhenClose = IsStalkerLimbBlownOff( npc, "right_arm" ) 
								   && AiStalker_ShouldOverloadOnDeath( npc ) // only stalkers who setup this can overload
								   && IsAlive( enemy )
								   && Distance( npc.GetOrigin(), enemy.GetOrigin() ) < 150 // hardcoded! inner radius of small exp is 100, large exp is 200
	
		if ( doOverloadWhenClose )
		{
			thread StalkerGearOverloads( npc, GetSelfTerminateAttacker( npc ) )
		}

		WaitFrame() // faster think than SelfTerminateAfterDelay()
	}
}

entity function GetSelfTerminateAttacker( entity npc )
{
	entity damageAttacker = npc // default case is self-explode
	entity lastAttacker = GetLastAttacker( npc )
	// settings check
	if ( IsValid( lastAttacker ) && AiStalker_UseLastAttackerToSelfTerminate( npc ) )
		damageAttacker = lastAttacker

	return damageAttacker
}

void function FallAndBecomeCrawlingStalker( entity npc )
{
	// finish what he's doing
	npc.EndSignal( "OnDeath" )

	npc.ai.transitioningToCrawl = true

	// Workaround for Bug 114372
	WaitFrame()

	for ( ;; )
	{
		if ( npc.IsInterruptable() )
			break
		WaitFrame()
	}

	if ( !StalkerCanCrawl( npc ) )
		return

	if ( IsCrawling( npc ) )
		return

	EnableStalkerCrawlingBehavior( npc )

	npc.Anim_Stop() // stop leeching, etc.

	PlayCrawlingAnim( npc, "ACT_STAND_TO_CRAWL" )

	// vanilla missing: after behavior enabled, npc.ai.transitioningToCrawl should be cleaned up
	// we can already use IsCrawling() for handle stuffs after that
	npc.ai.transitioningToCrawl = false
}

void function PlayCrawlingAnim( entity npc, string animation )
{
	npc.Anim_ScriptedPlayActivityByName( animation, true, 0.1 )
	npc.UseSequenceBounds( true )
}

void function AttemptStandToStaggerAnimation( entity npc )
{
	// Check if we are already staggered
	if ( npc.IsActivityModifierActive( ACT_MODIFIER_STAGGER ) )
		return

	if ( !npc.IsInterruptable() )
		return

	if ( npc.ContextAction_IsBusy() )
		return

	// Are we blocking additional pain animations
	if ( npc.GetNPCFlag( NPC_NO_PAIN ) )
		return

	// finish what he's doing
	npc.EndSignal( "OnDeath" )

	// Workaround for Bug 114372
	WaitFrame()

	for ( ;; )
	{
		if ( npc.IsInterruptable() )
			break

		WaitFrame()
	}

	if ( IsCrawling( npc ) || npc.ai.transitioningToCrawl )
		return

	npc.Anim_ScriptedPlayActivityByName( "ACT_STAND_TO_STAGGER", true, 0.1 )
	npc.UseSequenceBounds( true )
	npc.EnableNPCFlag( NPC_PAIN_IN_SCRIPTED_ANIM )
}

bool function IsStalkerLimbBlownOff( entity npc, string limbName )
{
	int bodyGroup = npc.FindBodyGroup( limbName )
	if ( npc.GetBodyGroupState( bodyGroup ) != 0 )
		return true

	return false
}

// here goes a modiifed condition: we've added dismembering right arm
// means that we can now dismember all of stalker's limbs
bool function IsStalkerAllLimbsBlownOff( entity npc )
{
	return IsStalkerLimbBlownOff( npc, "left_arm" )
		   && IsStalkerLimbBlownOff( npc, "right_arm" )
		   && IsStalkerLimbBlownOff( npc, "left_leg" )
		   && IsStalkerLimbBlownOff( npc, "right_leg" )
}

// here goes a modiifed condition: we've added dismembering right arm
// means that we can now dismember all of stalker's arms
bool function IsStalkerAllArmsBlownOff( entity npc )
{
	return IsStalkerLimbBlownOff( npc, "left_arm" )
		   && IsStalkerLimbBlownOff( npc, "right_arm" )
}

// limbHealthPercentOfMax isn't used at all!!! stalker will always get dismembered in ONE SHOT
bool function StalkerLimbBlownOff( entity npc, var damageInfo, int hitGroup, float limbHealthPercentOfMax, string limbName, array<string> fxTags, string sound )
{
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	switch ( damageSourceId ) //SERIOUSLY?
	{
		case eDamageSourceId.mp_weapon_grenade_emp:
		case eDamageSourceId.mp_weapon_proximity_mine:
			return false
	}

	int bodyGroup = npc.FindBodyGroup( limbName )
	if ( bodyGroup == -1 )
		return false

	if ( IsStalkerLimbBlownOff( npc, limbName ) )
		return false

	// modified: add usage of limbHealthPercentOfMax
	//print( "limbHealthPercentOfMax: " + string( limbHealthPercentOfMax ) )
	if ( limbHealthPercentOfMax > 0 ) // negative value means we always try to dismember
	{
		int damageRequiredToBlowOffLimb = int( npc.GetMaxHealth().tofloat() * limbHealthPercentOfMax )
		int hitGroupDamageTaken = npc.ai.stalkerHitgroupDamageAccumulated[ hitGroup ]
		//print( "damageRequiredToBlowOffLimb: " + string( damageRequiredToBlowOffLimb ) )
		//print( "hitGroupDamageTaken: " + string( hitGroupDamageTaken ) )
		if ( hitGroupDamageTaken < damageRequiredToBlowOffLimb )
			return false
	}
	//

	EmitSoundOnEntity( npc, sound )

	// blow off limb
	npc.SetBodygroup( bodyGroup, 1 )

	return true
}

void function StalkerHeadShot( entity npc, var damageInfo, int hitGroup )
{
	// random chance to blow up head
//	if ( DamageInfo_GetDamage( damageInfo ) < 100 && RandomFloat( 100 ) <= 66 )
//		return

	if ( !IsValidHeadShot( damageInfo, npc ) )
		return

	// only players score headshots
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsAlive( attacker ) )
		return
	// modified: we've add npc location based damage in sh_damage_utility.gnut, npcs can do special hit group checks
	//if ( !attacker.IsPlayer() )
	if ( !attacker.IsPlayer() && !DamageUtility_IsNPCLocationBasedDamageEnabled() )
		return

	if ( DamageInfo_GetDamage( damageInfo ) < npc.GetHealth() )
	{
		// force lethal if we have done more than this much damage
		// modified to use a setting for headshot required damage
		//if ( npc.ai.stalkerHitgroupDamageAccumulated[ hitGroup ] < npc.GetMaxHealth() * STALKER_DAMAGE_REQUIRED_TO_HEADSHOT )
		int headShotDamageTaken = npc.ai.stalkerHitgroupDamageAccumulated[ hitGroup ]
		int headShotRequiredDamage = int( npc.GetMaxHealth() * AiStalker_GetDamageRequiredToDismemberHitGroup( npc, hitGroup ) )
		//print( "headShotDamageTaken: " + string( headShotDamageTaken ) )
		//print( "headShotRequiredDamage: " + string( headShotRequiredDamage ) )
		if ( headShotDamageTaken < headShotRequiredDamage )
			return
	}

	npc.Anim_Stop() // stop leeching, etc.
	npc.ClearParent()

	//DisableLeeching( npc )

	// No pain anims
	//DamageInfo_AddDamageFlags( damageInfo, DAMAGEFLAG_NOPAIN )

	// Set these so cl_player knows to kill the eye glow and play the right SFX
	DamageInfo_AddCustomDamageType( damageInfo, DF_HEADSHOT )
	DamageInfo_AddCustomDamageType( damageInfo, DF_KILLSHOT )

	// due we've added npc location based damage, needs to check player validation
	if ( attacker.IsPlayer() )
		EmitSoundOnEntityExceptToPlayer( npc, attacker, "SuicideSpectre.BulletImpact_HeadShot_3P_vs_3P" )

	// shouldn't hardcode like this without any crash handle
	/*
	int bodyGroupIndex = npc.FindBodyGroup( "removableHead" )
	int stateIndex = 1  // 0 = show, 1 = hide
	npc.SetBodygroup( bodyGroupIndex, stateIndex )
	*/
	// reworked:
	int bodyGroupIndex = npc.FindBodyGroup( "removableHead" )
	if ( bodyGroupIndex == -1 ) 
		bodyGroupIndex = npc.FindBodyGroup( "head" )
	if ( bodyGroupIndex > -1 )
	{
		int stateIndex = 1  // 0 = show, 1 = hide
		npc.SetBodygroup( bodyGroupIndex, stateIndex )
	}

	DamageInfo_SetDamage( damageInfo, npc.GetMaxHealth() )
}

vector function GetDeathForce()
{
	vector angles = <RandomFloatRange(-45,-75),RandomFloat(360),0>
	vector forward = AnglesToForward( angles )
	return forward * RandomFloatRange( 0.25, 0.75 )
}


// modified settings
void function AiStalker_SetDismemberHitGroupRequiredDamage( entity stalker, int hitGroup, float requiredDamage )
{
	if ( !( stalker in file.stalkerDismemberHitGroupRequiredDamage ) )
		file.stalkerDismemberHitGroupRequiredDamage[ stalker ] <- {} // init

	if ( !( hitGroup in file.stalkerDismemberHitGroupRequiredDamage[ stalker ] ) )
		file.stalkerDismemberHitGroupRequiredDamage[ stalker ][ hitGroup ] <- STALKER_DISMEMBER_DAMAGE_DISABLED // init

	file.stalkerDismemberHitGroupRequiredDamage[ stalker ][ hitGroup ] = requiredDamage
}

float function AiStalker_GetDamageRequiredToDismemberHitGroup( entity stalker, int hitGroup )
{
	if ( !( stalker in file.stalkerDismemberHitGroupRequiredDamage ) )
		return GetDefaultDamageRequiredToDismemberHitGroup( stalker, hitGroup ) // default return value

	if ( !( hitGroup in file.stalkerDismemberHitGroupRequiredDamage[ stalker ] ) )
		return GetDefaultDamageRequiredToDismemberHitGroup( stalker, hitGroup ) // default return value

	return file.stalkerDismemberHitGroupRequiredDamage[ stalker ][ hitGroup ]
}

// here's vanilla settings value, hardcoded
float function GetDefaultDamageRequiredToDismemberHitGroup( entity stalker, int hitGroup )
{
	switch ( hitGroup )
	{
		case HITGROUP_HEAD:
			return STALKER_DAMAGE_REQUIRED_TO_HEADSHOT
		case HITGROUP_LEFTARM:
			return STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_LEFT_ARM
		case HITGROUP_RIGHTARM:
			return STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_RIGHT_ARM
		case HITGROUP_LEFTLEG:
			return STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_LEFT_LEG
		case HITGROUP_RIGHTLEG:
			return STALKER_DAMAGE_REQUIRED_TO_DISMEMBER_RIGHT_LEG
	}

	return STALKER_DISMEMBER_DAMAGE_DISABLED // negative value means we never dismember
}

void function AiStalker_SetGearOverloadOnHitRequiredHealthPercent( entity stalker, float healthPercent )
{
	if ( !( stalker in file.stalkerGearOverloadOnHitRequiredHealthPercent ) )
		file.stalkerGearOverloadOnHitRequiredHealthPercent[ stalker ] <- STALKER_HEALTH_PERCENT_REQUIRED_TO_OVERLOAD_ON_HIT // init

	file.stalkerGearOverloadOnHitRequiredHealthPercent[ stalker ] = healthPercent
}

float function AiStalker_GetHealthPercentRequiredToOverloadOnHitGear( entity stalker )
{
	if ( !( stalker in file.stalkerGearOverloadOnHitRequiredHealthPercent ) )
		return STALKER_HEALTH_PERCENT_REQUIRED_TO_OVERLOAD_ON_HIT // default return value

	return file.stalkerGearOverloadOnHitRequiredHealthPercent[ stalker ]
}

void function AiStalker_SetUpGearOverloadOnDeath( entity stalker, bool alwaysOverloadOnDeath, bool noOverloadOnHeadshot = true, bool onlyOverloadOnKilledByTitans = false )
{
	StalkerDeathOverloadSettings deathSettings
	if ( !( stalker in file.stalkerGearOverloadOnDeathSettingsTable ) )
		file.stalkerGearOverloadOnDeathSettingsTable[ stalker ] <- deathSettings // init

	file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].alwaysOverloadOnDeath = alwaysOverloadOnDeath
	file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].noOverloadOnHeadshot = noOverloadOnHeadshot
	file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].onlyOverloadOnKilledByTitans = onlyOverloadOnKilledByTitans
}

bool function AiStalker_ShouldOverloadOnDeath( entity stalker )
{
	if ( !( stalker in file.stalkerGearOverloadOnDeathSettingsTable ) )
		return STALKER_OVERLOAD_ON_DEATH // default return value

	return file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].alwaysOverloadOnDeath
}

bool function AiStalker_ShouldOverloadOnHeadshotDeath( entity stalker )
{
	if ( !( stalker in file.stalkerGearOverloadOnDeathSettingsTable ) )
		return STALKER_SHOULD_OVERLOAD_ON_HEADSHOT_DEATH // default return value

	return !file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].noOverloadOnHeadshot // the meaning is reversed!
}

bool function AiStalker_OnlyOverloadOnKilledByTitan( entity stalker )
{
	if ( !( stalker in file.stalkerGearOverloadOnDeathSettingsTable ) )
		return STALKER_ONLY_OVERLOAD_ON_KILLED_BY_TITAN // default return value

	return file.stalkerGearOverloadOnDeathSettingsTable[ stalker ].onlyOverloadOnKilledByTitans
}

void function AiStalker_SetGearOverloadDuration( entity stalker, float duration )
{
	if ( !( stalker in file.stalkerGearOverloadDuration ) )
		file.stalkerGearOverloadDuration[ stalker ] <- STALKER_GEAR_OVERLOAD_DURATION // init

	file.stalkerGearOverloadDuration[ stalker ] = duration
}

float function AiStalker_GetGearOverloadDuration( entity stalker )
{
	if ( !( stalker in file.stalkerGearOverloadDuration ) )
		return STALKER_GEAR_OVERLOAD_DURATION // default return value

	return file.stalkerGearOverloadDuration[ stalker ]
}

void function AiStalker_SetCrawlLifeTime( entity stalker, float lifeSupportDuration, float maxDeathTime, bool useLastAttackerToSelfTerminate = false )
{
	StalkerCrawlLifeTimeSettings crawlSettings
	if ( !( stalker in file.stalkerCrawlLifeTimeSettingsTable ) )
		file.stalkerCrawlLifeTimeSettingsTable[ stalker ] <- crawlSettings // init

	file.stalkerCrawlLifeTimeSettingsTable[ stalker ].lifeSupportDuration = lifeSupportDuration
	file.stalkerCrawlLifeTimeSettingsTable[ stalker ].maxDeathTime = maxDeathTime
	file.stalkerCrawlLifeTimeSettingsTable[ stalker ].useLastAttackerToSelfTerminate = useLastAttackerToSelfTerminate
}

float function AiStalker_GetCrawlLifeSupportDuration( entity stalker )
{
	if ( !( stalker in file.stalkerCrawlLifeTimeSettingsTable ) )
		return STALKER_CRAWL_LIFE_SUPPORT_DURATION // default return value

	return file.stalkerCrawlLifeTimeSettingsTable[ stalker ].lifeSupportDuration
}

float function AiStalker_GetCrawlMaxDeathTime( entity stalker )
{
	if ( !( stalker in file.stalkerCrawlLifeTimeSettingsTable ) )
		return STALKER_CRAWL_MAX_TIME_BEFORE_DEATH // default return value

	return file.stalkerCrawlLifeTimeSettingsTable[ stalker ].maxDeathTime
}

bool function AiStalker_UseLastAttackerToSelfTerminate( entity stalker )
{
	if ( !( stalker in file.stalkerCrawlLifeTimeSettingsTable ) )
		return STALKER_USE_LAST_ATTACKER_TO_SELF_TERMINATE // default return value

	return file.stalkerCrawlLifeTimeSettingsTable[ stalker ].useLastAttackerToSelfTerminate
}

void function AiStalker_SetStaggerRequiredHealthPercent( entity stalker, float healthPercent )
{
	if ( !( stalker in file.stalkerStaggerRequiredHealthPercent ) )
		file.stalkerStaggerRequiredHealthPercent[ stalker ] <- STALKER_DAMAGE_REQUIRED_TO_STAGGER // init

	file.stalkerStaggerRequiredHealthPercent[ stalker ] = healthPercent
}

float function AiStalker_GetStaggerRequiredHealthPercent( entity stalker )
{
	if ( !( stalker in file.stalkerStaggerRequiredHealthPercent ) )
		return STALKER_DAMAGE_REQUIRED_TO_STAGGER // default return value

	return file.stalkerStaggerRequiredHealthPercent[ stalker ]
}

void function AiStalker_SetHealthPercentOnTransitionToCrawl( entity stalker, float healthPercent )
{
	if ( !( stalker in file.stalkerHealthPercentOnTransitionToCrawl ) )
		file.stalkerHealthPercentOnTransitionToCrawl[ stalker ] <- STALKER_HEALTH_ON_TRANSITION_TO_CRAWL // init

	file.stalkerHealthPercentOnTransitionToCrawl[ stalker ] = healthPercent
}

float function AiStalker_GetHealthPercentOnTransitioningToCrawl( entity stalker )
{
	if ( !( stalker in file.stalkerHealthPercentOnTransitionToCrawl ) )
		return STALKER_HEALTH_ON_TRANSITION_TO_CRAWL // default return value

	return file.stalkerHealthPercentOnTransitionToCrawl[ stalker ]
}

void function AiStalker_SetCreateHeavyArmorDangerousArea( entity stalker, bool createDangerousArea )
{
	if ( !( stalker in file.stalkerShouldCreateHeavyArmorDangerousArea ) )
		file.stalkerShouldCreateHeavyArmorDangerousArea[ stalker ] <- STALKER_SHOULD_CREATE_HEAVY_ARMOR_DANGEROUS_AREA // init

	file.stalkerShouldCreateHeavyArmorDangerousArea[ stalker ] = createDangerousArea
}

bool function AiStalker_GetShouldCreateHeavyArmorDangerousArea( entity stalker )
{
	if ( !( stalker in file.stalkerShouldCreateHeavyArmorDangerousArea ) )
		return STALKER_SHOULD_CREATE_HEAVY_ARMOR_DANGEROUS_AREA // default return value

	return file.stalkerShouldCreateHeavyArmorDangerousArea[ stalker ]
}