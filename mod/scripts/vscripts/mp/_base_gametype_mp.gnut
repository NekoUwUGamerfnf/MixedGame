untyped
global function BaseGametype_Init_MPSP
global function CodeCallback_OnClientConnectionStarted
global function CodeCallback_OnClientConnectionCompleted
global function CodeCallback_OnClientDisconnected
global function CodeCallback_OnPlayerRespawned
global function CodeCallback_OnPlayerKilled
global function DecideRespawnPlayer
global function RespawnAsPilot
global function RespawnAsTitan
global function TryGameModeAnnouncement

// modified callback: allowing change something before player actually respawns
global function AddCallback_OnPlayerDecideRespawn

global function SetKillcamsEnabled
global function KillcamsEnabled
global function SetPlayerDeathsHidden
global function TrackTitanDamageInPlayerGameStat

global function ShouldEntTakeDamage_SPMP
global function GetTitanBuildTime
global function TitanPlayerHotDropsIntoLevel

global function SetRecalculateRespawnAsTitanStartPointCallback

// I want my game to have this
global function PlayerWatchesKillReplayWrapper // this function should share with _gamestate_mp.nut
global function PlayerClassChangeToSpectator // shared with other files such _spectator.gnut
global function SetPlayerCameraToIntermissionCam // shared
global function GetReplayTimeSinceAttackerSpawned // shared with _gamestate_mp.nut
global function StopKillReplayForPlayer // shared with _gamestate_mp.nut

global function IsPlayerDeathsHidden // new added

global function SetPlayerRespawnForced
global function AddCallback_ShouldPlayerDoForcedRespawn // add a callback func to check whether we trigger forced respawn
global function ForcedRespawn_SetDisabledForPlayer // disable forced respawn for certain player
global function SetPlayerRespawnDelayForced // force a player to follow certain respawn delay. can be used for spawnwaves
global function ResetPlayerRespawnDelay // reset respawn delay to default value: playlistvar "respawn_delay"
global function GetPlayerRespawnDelay

global function SetLateJoinRespawnEnabled // respawn the player if they join mid-game in a elimination gamemode

global function SetGamemodeAnnouncementEnabled

global function SetDeathCamLengthForced
global function GetForcedDeathCamLength // shared with _utility_shared.nut
global function SetReplayStartDelayOverride // only gets applied when death cam modified!

global function SetDeathHintsEnabled
global function SetDeathHintsInterval

global function CalculateTitanDamageTaken // can be shared with gamemode files

// CodeCallbacks that exists in _base_gametype_sp.gnut
global function CodeCallback_OnWeaponAttack
global function CodeCallback_OnPlayerMatchmakingChanged
global function CodeCallback_OnWeaponTouch
global function CodeCallback_WeaponDropped
global function CodeCallback_PlayerHasBeenConnectedForDuration

// vanilla missing AddCallbacks
global function AddCallback_OnWeaponAttack
global function AddCallback_OnPlayerMatchmakingChanged
global function AddCallback_OnWeaponTouch
global function AddCallback_WeaponDropped
global function AddCallback_PlayerHasBeenConnectedForDuration

struct 
{
	bool killcamsEnabled = true
	bool playerDeathsHidden = false
	int titanDamageGameStat = -1
	
	entity intermissionCamera
	array<entity> specCams

	// modified callback: allowing change something before player actually respawns
	array<void functionref( entity player )> playerDecideRespawnCallbacks

	entity functionref( entity player, entity basePoint ) recalculateRespawnAsTitanStartPointCallback
	
	// modified
	bool forcedRespawn = true
	array<bool functionref( entity, table )> shouldDoForcedRespawnCallbacks
	table<entity, bool> playerDisableForcedRespawn
	table<entity, float> playerRespawnDelay

	bool enableLateRespawn = true
	array<string> respawnedPlayerUIDs = []
	bool enableGamemodeAnnouncement = true

	// death cam modifier
	float forcedDeathCamLength = -1
	float replayStartDelayOverride = -1
	// with modified deathcam player may unable to drop weapon... we need to force them drop at least one weapon on death
	table<entity, entity> playerActiveWeaponBeforeDeathPackage

	bool deathHintsEnabled = true
	table<entity, float> playerDeathHintAllowedTime
	int deathHintsInterval = 60

	// vanilla missing AddCallbacks
	array< void functionref( entity player, entity weapon, string weaponName, int ammoUsed ) > onWeaponAttackCallbacks // NOTE: this callback isn't called at all!
	array< void functionref( entity player ) > onPlayerMatchmakingChangedCallbacks
	array< void functionref( entity player, entity weapon, int ammoRecieved ) > onWeaponTouchCallbacks
	array< void functionref( entity weapon ) > weaponDroppedCallbacks
	array< void functionref( entity player, float durationInSeconds ) > playerHasBeenConnectedForDurationCallbacks
} file

void function BaseGametype_Init_MPSP()
{
	AddSpawnCallback( "info_intermission", SetIntermissionCamera )

	AddPostDamageCallback( "player", AddToTitanDamageStat )
	AddPostDamageCallback( "npc_titan", AddToTitanDamageStat )

	RegisterSignal( "PlayerRespawnStarted" )
	RegisterSignal( "KillCamOver" )

	// modified to handle titan obit
	// was using AddCallback_OnPlayerKilled() and AddCallback_OnNPCKilled(), but these two won't get called if attacker invalid
	AddDeathCallback( "player", HandleTitanDeathObit )
	AddDeathCallback( "npc_titan", HandleTitanDeathObit )

	// modified doomed state handle
	AddCallback_OnTitanDoomed( HandleTitanDoomedObit )
}

void function SetIntermissionCamera( entity camera )
{
	file.intermissionCamera = camera
}

void function CodeCallback_OnClientConnectionStarted( entity player )
{
	// not a real player?
	#if DEV
	if ( player.GetPlayerName() == "Replay" )
		return
	#endif

	if ( IsLobby() )
	{
		Lobby_OnClientConnectionStarted( player )
		return
	}

//	ScreenFade( player, 0, 0, 0, 255, 2.0, 0.5, FFADE_IN | FFADE_PURGE )

	SetTargetName( player, "player" + player.entindex() )

	player.p.controllableProjectiles_scriptManagedID = CreateScriptManagedEntArray()
	player.p.npcFollowersArrayID = CreateScriptManagedEntArray()

	player.s = {}
	player.s.attackerInfo <- {}
	player.p.clientScriptInitialized = player.IsBot()
	player.s.inPostDeath <- null
	player.s.respawnCount <- 0
	player.s.respawnTime <- 0
	player.s.lostTitanTime <- 0
	player.s.cloakedShotsAllowed <- 0
	player.s.startDashMeleeTime <- 0
	player.s.respawnSelectionDone <- true  // this gets set to false in postdeaththread but we need it to be true when connecting
	player.s.waveSpawnProtection <- false

	player.s.nextStatUpdateFunc <- null

	player.s.activeTrapArrayId <- CreateScriptManagedEntArray()

	player.s.restartBurnCardEffectOnSpawn <- false
	player.s.replacementDropInProgress <- false

	player.s.inGracePeriod <- true

	// should I just add these when playing coop?
	player.s.usedLoadoutCrate <- false
	player.s.restockAmmoTime <- 0
	player.s.restockAmmoCrate <- null

	player.s.autoTitanLastEngageCalloutTime <- 0
	player.s.autoTitanLastEngageCallout <- null
	player.s.lastAIConversationTime <- {} // when was a conversation last played?

	player.s.updatedPersistenceOnDisconnect <- false

	player.s.lastFriendlySpawnedOn <- null
	player.s.nextWaveSpawnTime <- 0.0

	player.s.meleeSlowMoEndTime <- 0.0
	
	player.p.connectTime = Time()

	// modified
	file.playerDeathHintAllowedTime[ player ] <- 0.0
	file.playerDisableForcedRespawn[ player ] <- false
	file.playerRespawnDelay[ player ] <- GetCurrentPlaylistVarFloat( "respawn_delay", 0.0 )
	file.playerActiveWeaponBeforeDeathPackage[ player ] <- null

	Assert( !player._entityVars )
	InitEntityVars( player )

	// Added via AddCallback_OnClientConnecting
	foreach ( callbackFunc in svGlobal.onClientConnectingCallbacks )
	{
		callbackFunc( player )
	}

	printl( "Player connect started: " + player + "---UID:" + player.GetUID() )
	
	InitPassives( player )
}

// playerconnected
void function CodeCallback_OnClientConnectionCompleted( entity player )
{
	InitPersistentData( player ) // defensive fix

	if ( IsLobby() )
	{
		Lobby_OnClientConnectionCompleted( player )
		return
	}
	else if ( !IsFDMode( GAMETYPE ) )
	{
		// reset this for non-fd modes
		// for some reason the postgame scoreboard uses this to
		// determine if it should show the FD aegis rank one
		// FD should either set this in their own mode, or add an else
		// to this if statement when it releases
		player.SetPersistentVar( "lastFDTitanRef", "" )
	}

	player.hasConnected = true

	InitMeleeAnimEventCallbacks( player )
	ZiplineInit( player )
	
	UpdateMinimapStatus( player )
	UpdateMinimapStatusToOtherPlayers( player )
	MinimapPlayerConnected( player )
	NotifyClientsOfConnection( player, 1 )
	PlayCurrentTeamMusicEventsOnPlayer( player )
	SetCurrentTeamObjectiveForPlayer( player )

	entity skycam = GetEnt( "skybox_cam_level" )
	if ( skycam != null )
		player.SetSkyCamera( skycam )

	FinishClientScriptInitialization( player )

	// Added via AddCallback_OnClientConnected
	foreach ( callbackFunc in svGlobal.onClientConnectedCallbacks )
		callbackFunc( player )

	if ( !Flag( "PlayerDidSpawn") )
		__PlayerDidSpawn( player )

	svGlobal.levelEnt.Signal( "PlayerDidSpawn", { player = player } )

	if ( GetConVarBool( "ns_allow_spectators" ) )
	{
		if ( IsPrivateMatchSpectator( player ) )
		{
			InitialisePrivateMatchSpectatorPlayer( player )
			return
		}
	}
	else
		player.SetPersistentVar( "privateMatchState", 0 )

	// handle spawning late joiners
	HandleRespawningLateJoiners( player )
}

void function HandleRespawningLateJoiners( entity player )
{
	// handle spawning late joiners
	if ( GetGameState() == eGameState.Playing )
	{
		bool connectingRespawned = false
		if ( RespawnsEnabled() )
		{
			ClearRespawnAvailable( player ) // need so the respawn icon doesn't show
			// likely temp, deffo needs some work
			if ( Riff_SpawnAsTitan() == 1 )	// spawn as titan
				thread RespawnAsTitan( player )
			else // spawn as pilot
				RespawnAsPilot( player )
			connectingRespawned = true
		}
		else // may not be useful, just want to make dedicated servers better
		{
			bool shouldDoLateSpawn = false

			if( GetPlayerArrayOfTeam( player.GetTeam() ).len() <= 1 )
				shouldDoLateSpawn = true
			else if( !file.respawnedPlayerUIDs.contains( player.GetUID() ) ) // avoid multiple late spawns by disconnecting
				shouldDoLateSpawn = true

			// do this so player don't have to wait so long till round end
			if( shouldDoLateSpawn && IsLateJoinRespawnEnabled() ) // never try to respawn if this mechanic is disabled manually
			{
				if ( Riff_SpawnAsTitan() == 1 )	// spawn as titan
					thread RespawnAsTitan( player )
				else // spawn as pilot
					RespawnAsPilot( player )
				connectingRespawned = true
			}
			else
				thread PlayerBecomesSpectator( player )
		}
		if( connectingRespawned )
			thread DelayedGamemodeAnnouncement( player )
	}
	else if ( GetGameState() == eGameState.Epilogue || GetGameState() == eGameState.SuddenDeath )// don't know why northstar not handling these
		thread PlayerBecomesSpectator( player )
	else if ( GetGameState() == eGameState.SwitchingSides || GetGameState() == eGameState.WinnerDetermined || GetGameState() == eGameState.Postmatch ) // match end state
		SetPlayerCameraToIntermissionCam( player ) // just make players go to intermission cam
}

void function DelayedGamemodeAnnouncement( entity player )
{
	player.EndSignal( "OnDestroy" )
	
	if( !IsAlive( player ) )
		player.WaitSignal( "OnRespawned" )
	wait 1.7 // vanilla behavior: wait for player screen fade from black and sound fade-in, then do a announcement
	if ( GetGameState() == eGameState.Playing )
		TryGameModeAnnouncement( player )
}

void function CodeCallback_OnClientDisconnected( entity player, string reason )
{
	if ( IsLobby() )
	{
		player.Signal( "_disconnectedInternal" )
		UpdateBadRepPresent()
		return
	}

	if ( !player.hasConnected )
		return

	// Added via AddCallback_OnClientDisconnected
	foreach ( callbackFunc in svGlobal.onClientDisconnectedCallbacks )
	{
		callbackFunc( player )
	}

	player.Disconnected()
	player.p.isDisconnected = true
	player.CleanupMPClasses()
}

void function CodeCallback_OnPlayerRespawned( entity player )
{
	// cleanup stuffs
	player.s.inGracePeriod = true // defensive fix, make sure player can get loadout on respawn
	player.s.respawnCount++
	player.s.respawnTime = Time()

	ClearPlayerEliminated( player ) // mark as player not eliminated
	ClearRecentDamageHistory( player )
	// these cleanup has been done in CPlayer::RespawnPlayer()
	//player.ClearReplayDelay()
	//player.ClearViewEntity()
	//player.SetPredictionEnabled( true ) doesn't seem needed, as native code seems to set this

	// clean up variables
	while ( player.IsInvulnerable() ) // invulnerability can stack
		player.ClearInvulnerable()
	player.SetNoTarget( false )
	player.SetNoTargetSmartAmmo( false )

	// clean up death package
	// vanilla seem to have this behavior, otherwise being executed by titan will make player force ragdoll forever
	player.e.forceGibDeath = false
	player.e.forceRagdollDeath = false
	// modified cleanup
	file.playerActiveWeaponBeforeDeathPackage[ player ] = null

	// clean up titan abilities
	while ( player.GetMeleeDisabled() ) // melee disable can stack
		player.ClearMeleeDisabled()
	player.SetTitanDisembarkEnabled( true )
	
	// insure visibility that might be changed by executions, before calling other respawn callbacks
	player.Show()
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE


	// done cleanup, below are setups
	player.Signal( "OnRespawned" ) // kill any postdeaththreads that could be running
	
	SetHumanRagdollImpactTable( player )

	// give loadout
	Loadouts_TryGivePilotLoadout( player )
	foreach ( entity weapon in player.GetMainWeapons() )
		weapon.SetProScreenOwner( player )

	// always don't let them to do another late respawn if they once respawned
	if( !file.respawnedPlayerUIDs.contains( player.GetUID() ) )
		file.respawnedPlayerUIDs.append( player.GetUID() )
	
	// Added via AddCallback_OnPlayerRespawned()
	foreach ( void functionref( entity ) callback in svGlobal.onPlayerRespawnedCallbacks )
		callback( player )
		
	Remote_CallFunction_NonReplay( player, "ServerCallback_YouRespawned" )
	ClearLastAttacker( player ) // so dying to anything doesn't credit the same attacker after respawning
}

void function CodeCallback_OnPlayerKilled( entity player, var damageInfo )
{
	// disable prediction to prevent it messing with ragdoll in some places, as well as killreplay and such
	player.SetPredictionEnabled( false )

	// store last active weapon before death package drop player's weapon( gib or ragdoll )
	if ( !player.IsTitan() )
		file.playerActiveWeaponBeforeDeathPackage[ player ] = player.GetActiveWeapon()
	else // store a null for titans, means they'll never compare and drop weapon
		file.playerActiveWeaponBeforeDeathPackage[ player ] = null
	//print( "playerActiveWeaponBeforeDeathPackage: " + string( file.playerActiveWeaponBeforeDeathPackage[ player ] ) )
	
	HandleDeathPackage( player, damageInfo )

	// refering to CodeCallback_OnNPCKilled(): should fix doomed callbacks if titan player died without entering doom
	if ( player.IsTitan() )
	{
		if ( !GetDoomedState( player ) )
		{
			// Added via AddCallback_OnTitanDoomed
			foreach ( callbackFunc in svGlobal.onTitanDoomedCallbacks )
			{
				callbackFunc( player, damageInfo )
			}
		}
	}

	PlayerOrNPCKilled( player, damageInfo )
	//HandleDeathPackage( player, damageInfo ) // refering to CodeCallback_OnNPCKilled(): HandleDeathPackage() gets called earlier than PlayerOrNPCKilled()
	thread PostDeathThread_MP( player, damageInfo )
}

void function PostDeathThread_MP( entity player, var damageInfo ) // based on gametype_sp: postdeaththread_sp
{
	if ( player.s.inPostDeath )
		return

	float timeOfDeath = Time()
	player.p.postDeathThreadStartTime = Time()

	Assert( IsValid( player ), "Not a valid player" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnRespawned" )

	player.p.deathOrigin = player.GetOrigin()
	player.p.deathAngles = player.GetAngles()

	player.s.inPostDeath = true
	player.s.inGracePeriod = true // make sure player always in GracePeriod after respawn
	player.s.respawnSelectionDone = false

	player.cloakedForever = false
	player.stimmedForever = false

	// northstar behavior: clear notarget state
	// doesn't seem needed. better clean them up on player respawn but not on death
	/*
	player.SetNoTarget( false )
	player.SetNoTargetSmartAmmo( false )
	*/
	player.ClearExtraWeaponMods()

	// death package think
	// ragdoll or gib will make player drop weapon before their actual death
	// in this case we should remove all weapons for player
	// so that they won't have screen sway from their weapons
	bool shouldFixWeaponDrop = IsValid( file.playerActiveWeaponBeforeDeathPackage[ player ] ) // titan player will assign this as null, so drop weapon never happens
	bool playerDroppedWeaponFromDeathPackage = file.playerActiveWeaponBeforeDeathPackage[ player ] != player.GetActiveWeapon()
	//print( "shouldFixWeaponDrop: " + string( shouldFixWeaponDrop ) )
	//print( "playerDroppedWeaponFromDeathPackage: " + string( playerDroppedWeaponFromDeathPackage ) )
	if ( shouldFixWeaponDrop && playerDroppedWeaponFromDeathPackage )
		TakeAllWeapons( player )

	// we're not delayed yet, get damage table from damageInfo, so we can use it in ShouldForceRespawnPlayer_FromDamageTable()
	table damageTable = GetDamageTableFromInfo( damageInfo )
	
	// move to "OnPlayerKilled"
	// disable prediction to prevent it messing with ragdoll in some places, as well as killreplay and such
	//player.SetPredictionEnabled( false )
	
	if ( player.IsTitan() )
		SoulDies( player.GetTitanSoul(), damageInfo ) // cleanup some titan stuff, no idea where else to put this
	
	// re-exam for last death: hide respawn prompt during death cam
	ClearRespawnAvailable( player )
	// fix: get respawn avaibility before death cam delay
	// set earlier than "ServerCallback_YouDied" to change death sound
	bool respawnsEnableBeforeDeathCam = RespawnsEnabled()
	if ( !respawnsEnableBeforeDeathCam )
		SetPlayerEliminated( player ) // Change "Respawn" prompt to "Skip Replay", also changes death sound

	OnThreadEnd( function() : ( player )
	{
		if ( !IsValid( player ) )
			return
	
		player.s.inPostDeath = false
	})

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	int methodOfDeath = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	// northstar missing, fix for projectile kill replay
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	int inflictorEHandle = -1
	if ( IsValid( inflictor ) && ShouldTryUseProjectileReplay( player, attacker, damageInfo, false ) )
	{
		inflictorEHandle = inflictor.GetEncodedEHandle()
	}

	// northstar messed up. fix for replay attacker index
	// get replay required stuffs before we do death cam wait
	int attackerEHandle = player.GetEncodedEHandle() // by default we just use victim's EHandle
	int attackerIndex = -1
	if ( IsValid( attacker ) )
	{
		attackerEHandle = attacker.GetEncodedEHandle()
		attackerIndex = attacker.GetIndexForEntity()

		if( attacker.IsPlayer() )	
			Highlight_SetDeathRecapHighlight( attacker, "killer_outline" )

		// fix for replay
		if ( inflictorEHandle == -1 ) // invalid projectile ehandle!
			inflictorEHandle = attackerEHandle // just assign attacker as inflictor!
	}

	player.p.rematchOrigin = player.p.deathOrigin
	if ( IsValid( attacker ) && methodOfDeath == eDamageSourceId.titan_execution )
	{
		// execution can throw you out of the map
		player.p.rematchOrigin = attacker.GetOrigin()
	}

	// add deathHint on respawn
	bool showDeathHints = !IsRoundBased()
						  && file.deathHintsEnabled 
						  && ( Time() > file.playerDeathHintAllowedTime[ player ] )
	if ( showDeathHints )
	{
		ShowDeathHint( player, damageInfo )
		file.playerDeathHintAllowedTime[ player ] = Time() + file.deathHintsInterval // update interval
	}

	// clean up player's parents
	player.Signal( "RodeoOver" )
	player.ClearParent()
	
	/* // removed. replay can be handled properly by modified PlayerWatchesKillReplayWrapper()
	// do some pre-replay stuff if we're gonna do a replay
	float replayLength = CalculateLengthOfKillReplay( player, methodOfDeath )
	bool shouldDoReplay = Replay_IsEnabled() && KillcamsEnabled() && IsValid( attacker ) && ShouldDoReplay( player, attacker, replayLength, methodOfDeath )
	table replayTracker = { validTime = null }
	if ( shouldDoReplay )
		thread TrackDestroyTimeForReplay( attacker, replayTracker )
	*/

	// fix for replay duration
	float timeSinceAttackerSpawned = GetReplayTimeSinceAttackerSpawned( attacker )
	
	player.StartObserverMode( OBS_MODE_DEATHCAM )
	// modified here: only observers player or npc. projectile and mover stuffs can be attacker but we should never spec them
	//if ( ShouldSetObserverTarget( attacker ) )
	if ( ShouldSetObserverTarget( attacker ) && ( attacker.IsPlayer() || attacker.IsNPC() ) )
	{
		player.SetObserverTarget( attacker )
		// adding for modified death cam: enemy can respawn before player deathcam ends
		// if that ever happens, we need to clear player's observer target
		if ( attacker.IsPlayer() )
			thread TrackPlayerDeathCamTargetRespawn( player, attacker )
	}
	else
		player.SetObserverTarget( null ) // can't spec ourselves, spec nothing is good enough
	
	if ( ( GamePlayingOrSuddenDeath() || GetGameState() == eGameState.Epilogue|| GetGameState() == eGameState.WinnerDetermined ) && !file.playerDeathsHidden )
		player.AddToPlayerGameStat( PGS_DEATHS, 1 )

	// fuck respawn why leaving a annoying death sound
	if ( !file.playerDeathsHidden )
	{
		int diedRemoteCallEHandle = attackerEHandle
		float attackerHealthFrac = GetHealthFrac( attacker )
		if ( IsValid( attacker ) && !attacker.IsPlayer() ) // don't want to mess up a npc's highlight context. they won't be reset on player respawn
		{
			diedRemoteCallEHandle = player.GetEncodedEHandle() // use victim EHandle!
			attackerHealthFrac = 1.0 // reset health frac!
		}
		Remote_CallFunction_NonReplay( player, "ServerCallback_YouDied", diedRemoteCallEHandle, attackerHealthFrac, methodOfDeath )
	}

	// function GetDeathCamLength() has been modified to add forced deathcam length settings
	float deathcamLength = GetDeathCamLength( player )

	// modified over here, add support for modified death cam length
	float actualDeathCamLength = GetDeathCamLength( player, true ) // this gets the death cam length that ignores custom settings
	bool deathCamModified = actualDeathCamLength > deathcamLength
	float replayStartDelay = actualDeathCamLength - deathcamLength // in case we're not in good death cam length
	if ( deathCamModified && file.replayStartDelayOverride != -1 ) // replay start delay modified. only apply when deathCamModified!
		replayStartDelay = file.replayStartDelayOverride
	if ( replayStartDelay < 0 ) // defensive fix
		replayStartDelay = 0

	// try to start replay
	float replayLength = CalculateLengthOfKillReplay( player, methodOfDeath )

	bool shouldDoReplay = Replay_IsEnabled() 
						  && KillcamsEnabled() 
						  && ShouldDoReplay( player, attacker, replayLength, methodOfDeath )
						  && inflictorEHandle != -1 // a proper inflictor is always needed. by default they'll be attacker themselves
						  && attackerIndex != -1
	
	if ( shouldDoReplay )
	{
		table replayTracker = { validTime = null } // required to track replay victim destroy time
		// due we added modified death cam, for players we'll need to track respawn time and end replay by then
		// using modified function now
		//thread TrackDestroyTimeForReplay( attacker, replayTracker ) // shared from base_gametype.gnut
		thread TrackRespawnOrDestroyTimeForReplay( attacker, replayTracker )
		// try to do delayed replay	
		float actualReplayStartDelay = replayStartDelay + deathcamLength // always wait for death cam to end before we do any replay
		// debug
		//print( "replayStartDelay: " + string( replayStartDelay ) )
		//print( "actualReplayStartDelay: " + string( actualReplayStartDelay ) )
		float beforeTime = GetKillReplayBeforeTime( player, methodOfDeath )
		thread PlayerWatchesKillReplayWrapper( player, inflictorEHandle, attackerIndex, replayLength, timeSinceAttackerSpawned, timeOfDeath, beforeTime, replayTracker, actualReplayStartDelay )
	}

	//float deathcamLength = GetDeathCamLength( player )
	// all pre-setups done, wait for death cam to end
	wait deathcamLength

	/* // removed. replay can be handled properly by modified PlayerWatchesKillReplayWrapper()
	// hack: double check if killcams are enabled and valid here in case gamestate has changed this
	shouldDoReplay = shouldDoReplay && Replay_IsEnabled() && KillcamsEnabled() && IsValid( attacker )
	// quick note: in cases where player.Die() is called: e.g. for round ends, player == attacker
	if ( shouldDoReplay )
	{
		player.watchingKillreplayEndTime = Time() + replayLength		
		float beforeTime = GetKillReplayBeforeTime( player, methodOfDeath )
		
		replayTracker.validTime <- null // here goes wrong. shouldn't overwrite replayTracker's valid time from TrackDestroyTimeForReplay()
		
		float respawnTime = Time() - 2 // seems to get the killreplay to end around the actual kill
		if ( "respawnTime" in attacker.s )
			respawnTime = Time() - expect float ( attacker.s.respawnTime )

		thread PlayerWatchesKillReplayWrapper( player, attacker, respawnTime, timeOfDeath, beforeTime, replayTracker )
	}
	*/

	// BecomeRagdoll() seems weird with short deathCam
	// now setting these in DecideRespawnPlayer() to prevent crash
	//player.SetPlayerSettings( "spectator" ) // prevent a crash with going from titan => pilot on respawn
	//player.StopPhysics() // need to set this after SetPlayerSettings
	// vanilla seems never change player to spectator on death...
	//if ( !deathCamModified )
	//	PlayerClassChangeToSpectator( player )

	// because death cam can be modified, player may not have chance to drop weapon during death animation
	// if that ever happens, manually drop player's weapon
	if ( deathCamModified && ( shouldFixWeaponDrop && !playerDroppedWeaponFromDeathPackage ) )
	{
		entity activeWeapon = player.GetActiveWeapon()
		// activeWeapon will become invalid if player is dropping weapon from death animation
		if ( IsValid( activeWeapon ) )
		{
			//print( "Death cam length modified but player can't make it to drop weapon!" )
			//print( "Dropping " + string( activeWeapon ) + " manually" )
			player.DropWeapon( activeWeapon )
			activeWeapon.SetVelocity( player.GetVelocity() )
		}
	}

	// fix: get respawn avaibility before death cam delay
	//if ( RespawnsEnabled() )
	if ( respawnsEnableBeforeDeathCam )
	{
		// is it a good idea to do respawn code in postdeaththread? fuck if i know lol
		// add modified respawn delay think
		//float respawnDelay = max( 0, GetCurrentPlaylistVarFloat( "respawn_delay", 0.0 ) - deathcamLength )
		float respawnDelay = max( 0, GetPlayerRespawnDelay( player ) - deathcamLength )	

		print( "respawn delay " + respawnDelay )
		
		UpdateNextRespawnTime( player, Time() + respawnDelay )
		SetRespawnAvailable( player )
		
		wait respawnDelay

		// new intermission cam system
		if( ShouldForceRespawnPlayer_FromDamageTable( player, damageTable ) )
		{
			float forceRespawnDelay = GetCurrentPlaylistVarFloat( "player_force_respawn", 5 )
			float waitBeforeRespawn = 0.0
			//if( !shouldDoReplay || respawnDelay >= forceRespawnDelay ) // doing this so player can choose to respawn as titan, but vanilla don't feature this lol
			if( !shouldDoReplay )
			{
				waitBeforeRespawn = forceRespawnDelay - respawnDelay
				if( waitBeforeRespawn < 0 )
					waitBeforeRespawn = 0
				// modified over here, add support for modified death cam length
				float interMissionCamDelay = waitBeforeRespawn + 0.1
				if ( deathCamModified )
					interMissionCamDelay += replayStartDelay
				// if player not respawned after certain delay, we should set them back to intermission cam
				thread SetPlayerCameraToIntermissionCam( player, interMissionCamDelay )
			}
			thread ForcedRespawnThink( player, waitBeforeRespawn, replayStartDelay )// if not doing replay, set player's camera to intermissionCam
		}

		player.WaitSignal( "RespawnMe" ) // signaled in in base_gametype: ClientCommand_RespawnPlayer

		// defensive fix: in case we cleared certain player's respawn availability mid-way
		// but "RespawnMe" is sent at some place
		if ( !IsRespawnAvailable( player ) )
		{
			// change to spectator if player in valid gamestate
			if ( GamePlayingOrSuddenDeath() || GetGameState() == eGameState.Epilogue )
				thread PlayerBecomesSpectator( player )
			else if ( shouldDoReplay ) // if we did replay, should change player to intermission cam
				SetPlayerCameraToIntermissionCam( player )
			return
		}

		ClearRespawnAvailable( player ) // need so the respawn icon doesn't show for like a frame on next death

		if ( ( expect bool( player.GetPersistentVar( "spawnAsTitan" ) ) && IsTitanAvailable( player ) ) || ( Riff_SpawnAsTitan() > 0 && Riff_ShouldSpawnAsTitan( player ) ) )	// spawn as titan
			thread RespawnAsTitan( player )
		else // spawn as pilot
			RespawnAsPilot( player )
	}
	else if ( GamePlayingOrSuddenDeath() || GetGameState() == eGameState.Epilogue ) // respawn not valid, handling all situations
	{
		SetRespawnAvailable( player ) // needs to set respawn available to show "Skip Replay" button
		if ( shouldDoReplay )
			WaitSignal( player, "KillCamOver", "RespawnMe" )
		else // no replay enabled
		{
			// we wait an extra replayStartDelay for handling modified deathcam
			wait replayStartDelay

			// if it's epilogue, we need to wait longer because death cam length has been shortened
			if ( GetGameState() == eGameState.Epilogue )
				wait DEATHCAM_TIME - DEATHCAM_TIME_SHORT + RESPAWN_BUTTON_BUFFER
		}

		ClearRespawnAvailable( player )
		thread PlayerBecomesSpectator( player )
	}
}

// this can also handle npc killing another npc condition
void function HandleTitanDeathObit( entity victim, var damageInfo )
{
	if ( !IsValid( victim ) || !victim.IsTitan() )
		return

	// modified function in _titan_health.gnut, recovering ttf1 behavior: we do obit on doom but not on death for health loss titans
	if ( !TitanHealth_GetSoulInfiniteDoomedState( victim.GetTitanSoul() ) )
		return

	// modified function in _codecallbacks_common.gnut
	if ( EntityKilledEvent_IsDisabledForEntity( victim ) )
		return

	// obit
	NotifyClientsOfTitanDeath( victim, damageInfo )
}

// titan killed remotecall think
void function NotifyClientsOfTitanDeath( entity victim, var damageInfo )
{
	if ( !IsValid( victim ) || !victim.IsTitan() )
		return

	// below are mostly same as SendEntityKilledEvent(), removed headshot checks
	// titan is bit special, they mostly uses attacker who doomed them for handling damage
	// or they can eject using last attacker who damaged them, not always using current damage's attacker
	// (vanilla seems to behave like this, because I observed that in vanilla a titan killed by their own damage will display their last attacker or doomed shot attacker)
	//entity attacker = DamageInfo_GetAttacker( damageInfo )
	entity attacker = GetAttackerOrLastAttacker( victim, damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = victim.GetEncodedEHandle() // by default we just use victim's EHandle
	// ServerCallback_OnTitanKilled() is not using "GetHeavyWeightEntityFromEncodedEHandle()"
	// which means we can't pass a non-heavy weighted entity into it
	// non-heavy weighted entity including projectile stuffs
	// all movers, props, npcs and players are heavy weighted

	// crash happens after I made ball lightning use projectile as the inflictor of it's zap damage( in vanilla they uses movers )
	// after owner being destroyed, the projectile will be passed as attacker!
	// could also happen when electric smoke grenade change to use projectile as inflictor
	// EDIT: projectile is way too hardcoded, let's just only use player or npc as attacker
	//if ( IsValid( attacker ) && !attacker.IsProjectile() )
	if ( IsValid( attacker ) && ( attacker.IsPlayer() || attacker.IsNPC() ) )
		attackerEHandle = attacker.GetEncodedEHandle()

	int victimEHandle = victim.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	foreach ( player in GetPlayerArray() )
		Remote_CallFunction_NonReplay( player, "ServerCallback_OnTitanKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
}

// this is a modified case for doomed health loss titans: fake ttf1 behavior, do obit on doom instead of on death
void function HandleTitanDoomedObit( entity titan, var damageInfo )
{
	// obit
	// modified function in _titan_health.gnut, recovering ttf1 behavior: we do obit on doom but not on death for health loss titans
	if ( !TitanHealth_GetSoulInfiniteDoomedState( titan.GetTitanSoul() ) )
		NotifyClientsOfTitanDeath( titan, damageInfo )
}

// modified here!!!
void function SetPlayerCameraToIntermissionCam( entity player, float delay = 0 )
{
	if ( delay > 0 )
	{
		player.EndSignal( "OnDestroy" )
		player.EndSignal( "OnDeath" )
		player.EndSignal( "RespawnMe" )
		player.EndSignal( "OnRespawned" )
		player.EndSignal( "PlayerRespawnStarted" )
		//print( "Waiting " + string( delay ) + " s before setting camera" )
		wait delay
	}

	// modified function in _spectator.gnut
	if ( Spectator_IsPlayerSpectating( player ) ) // we never reset player to intermission cam if player is spectating
		return

	if ( file.intermissionCamera != null )
	{
		PlayerClassChangeToSpectator( player )
		//print( "Setting player camera to intermissionCam" )
		player.SetObserverModeStaticPosition( file.intermissionCamera.GetOrigin() )
		player.SetObserverModeStaticAngles( file.intermissionCamera.GetAngles() )
		player.ClearParent() // sometimes they're still parented, do a defensive fix
		if( !IsValid( player.GetParent() ) ) // setting to OBS_MODE_STATIC_LOCKED while parented will crash
			player.StartObserverMode( OBS_MODE_STATIC_LOCKED )
		player.SetObserverTarget( null )
	}
}

void function PlayerClassChangeToSpectator( entity player )
{
	TakeAllWeapons( player ) // before becoming ragdoll, should have their weapons out, otherwise a player can drop another weapon
	player.BecomeRagdoll( player.GetVelocity(), true ) // better become ragdoll before setting to spectator, so player won't have spectator class model out
	player.SetPlayerSettings( "spectator" ) 
	player.StopPhysics()
}

void function ForcedRespawnThink( entity player, float waitBeforeRespawn, float replayStartDelay = 0.0 )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "RespawnMe" )
	player.EndSignal( "PlayerRespawnStarted" ) // signaled by RespawnAsTitan()
	table result = {}
	result.repsawnIsForced <- false

	OnThreadEnd(
		function(): ( player, result )
		{
			// no forced respawn allowed during switching sides and postmatch
			if ( GetGameState() == eGameState.SwitchingSides || GetGameState() == eGameState.Postmatch )
				return
			if( IsValid( player ) )
			{
				if( expect bool( result.repsawnIsForced ) ) // reset player's persistent var if respawn is forced
					player.SetPersistentVar( "spawnAsTitan", false )
				player.Signal( "RespawnMe" )
			}
		}
	)
	
	// wait for next frame for player.WaitSignal( "RespawnMe" ) to set up
	// or maybe put the waitsignal inside this function? then rename it to PlayerWaitForRespawn()
	WaitFrame()
	//WaitEndFrame() // more accurate, but may seem weird if server modified script_server_fps
	// modified over here, add support for modified death cam length
	if ( replayStartDelay > 0 )
		wait replayStartDelay // this is actually replayStartDelay
	if( player.IsWatchingKillReplay() )
		player.WaitSignal( "KillCamOver" )

	if( waitBeforeRespawn > 0 )
		wait waitBeforeRespawn

	result.repsawnIsForced = true
}

// adding for modified death cam: enemy can respawn before player deathcam ends
// if that ever happens, we need to clear player's observer target
void function TrackPlayerDeathCamTargetRespawn( entity player, entity target )
{
	player.EndSignal( "OnDestroy" )
	target.EndSignal( "OnDestroy" ) // target gets destroyed will clear observer automatically

	// END on player's respawn
	player.EndSignal( "RespawnMe" )
	player.EndSignal( "OnRespawned" )
	player.EndSignal( "PlayerRespawnStarted" )

	// Clear Target on target's respawn
	WaitSignal( target, "RespawnMe", "OnRespawned", "PlayerRespawnStarted" )
	player.SetObserverTarget( null )
}

// due we added modified death cam, for players we'll need to track respawn time
// identically same as TrackDestroyTimeForReplay(), but adding player respawn signals
void function TrackRespawnOrDestroyTimeForReplay( entity attacker, table replayTracker )
{
	float startTime = Time()
	// tracks the time until the attacker respawn
	EndSignal( replayTracker, "OnDestroy" )

	OnThreadEnd(
		function () : ( replayTracker, startTime )
		{
			replayTracker.validTime = Time() - startTime
		}
	)

	if ( IsAlive( attacker ) )
		WaitSignal( attacker, "OnDestroy", "RespawnMe", "OnRespawned", "PlayerRespawnStarted" )
	else
		WaitSignalOnDeadEnt( attacker, "OnDestroy", "RespawnMe", "OnRespawned", "PlayerRespawnStarted" )
}
//

float function GetReplayTimeSinceAttackerSpawned( entity attacker )
{
	float timeSinceAttackerSpawned = Time() - 2 // seems to get the killreplay to end around the actual kill
	if ( IsValid( attacker ) )
	{
		if ( attacker.IsPlayer() ) // player
			timeSinceAttackerSpawned = Time() - GetPlayerLastRespawnTime( attacker )
		else if ( attacker.IsNPC() ) // npc
			timeSinceAttackerSpawned = Time() - attacker.ai.spawnTime
	}

	return timeSinceAttackerSpawned
}

//void function PlayerWatchesKillReplayWrapper( entity player, entity attacker, float timeSinceAttackerSpawned, float timeOfDeath, float beforeTime, table replayTracker )
void function PlayerWatchesKillReplayWrapper( entity player, int inflictorEHandle, int attackerIndex, float replayLength, float timeSinceAttackerSpawned, float timeOfDeath, float beforeTime, table replayTracker, float replayStartDelay = 0.0, bool clearViewOnReplayEnd = true )
{
	player.EndSignal( "RespawnMe" )
	player.EndSignal( "OnRespawned" )
	player.EndSignal( "PlayerRespawnStarted" ) // needs to handle delayed respawn!!
	
	player.EndSignal( "KillCamOver" ) // so other scripts can disable replay in progress
	player.EndSignal( "OnDestroy" )

	if ( replayStartDelay > 0 )
		wait replayStartDelay
	
	// wait is done, setup OnThreadEnd() cleanup stuffs
	OnThreadEnd
	( 
		function() : ( player, clearViewOnReplayEnd ) 
		{	
			// don't clear if we're in a roundwinningkillreplay, or winner determined kill
			//if ( IsValid( player ) && !( ( GetGameState() == eGameState.SwitchingSides || GetGameState() == eGameState.WinnerDetermined ) && IsRoundWinningKillReplayEnabled() ) )
			if ( IsValid( player ) )
			{
				StopKillReplayForPlayer( player )
				player.watchingKillreplayEndTime = Time()
				if ( clearViewOnReplayEnd )
				{
					//player.Signal( "KillCamOver" ) // wrapped into a named function
					player.ClearReplayDelay()
					player.ClearViewEntity()
					SetPlayerCameraToIntermissionCam( player )
					//player.SetPredictionEnabled( true ) doesn't seem needed, as native code seems to set this on respawn
				}
			}
		}
	)

	// setup replay max duration
	// actually affects nothing, but keep it?
	player.watchingKillreplayEndTime = Time() + replayLength

	// have to be spectator before watching kill replay
	PlayerClassChangeToSpectator( player )

	//player.SetPredictionEnabled( false )
	player.SetPredictionEnabled( true ) // should we enable prediction during killreplay? I think it might make replay smoother
	//PlayerWatchesKillReplay( player, attacker.GetEncodedEHandle(), attacker.GetIndexForEntity(), timeSinceAttackerSpawned, timeOfDeath, beforeTime, replayTracker )
	PlayerWatchesKillReplay( player, inflictorEHandle, attackerIndex, timeSinceAttackerSpawned, timeOfDeath, beforeTime, replayTracker )
}

void function StopKillReplayForPlayer( entity player )
{
	player.Signal( "KillCamOver" )
}

// modified to add manual spawnpoint
// default comes with no spawnpoint, other function should set player to correct place after calling this, or pass a spawnpoint entity inside
//void function DecideRespawnPlayer( entity player )
void function DecideRespawnPlayer( entity player, entity spawnpoint = null )
{
	// this isn't even used atm, could likely be removed if some vanilla code didn't rely on it
	// REWORK: this is a wrapped function, should be used to replace all player.RespawnPlayer() calls
	if ( !IsValid( player ) ) 
		return
	if ( IsAlive( player ) ) // player already alive! bad usage happened
		return

	// prevent a crash with going from titan => pilot on respawn
	// normally this is handled by killreplay or intermission cam
	// but we want to support modified death cam that allows player to completely skip kill replay
	// EDIT: compare to r5s3 code, this behavior is good be handled here, not always in replay or intermission cam
	if ( player.GetPlayerSettings() != "spectator" )
	{
		if ( !player.IsTitan() )
		{
			// non-titan case, changing to spectator
			// reverted: do nothing for non-titan respawn. this will mess up player's weapon flyout after replay
			/*
			string setFile = player.GetPlayerSettings()
			PlayerClassChangeToSpectator( player )
			player.SetPlayerSettings( setFile )
			*/
		}
		else // dying as titan, shouldn't reset player settings immedialely
			PlayerClassChangeToSpectator( player )
	}

	// if we don't clear spec delay before respawn, player will receive a bad visual effect in the rest of game
	Spectator_StopPlayerSpectating( player )
	
	// HACK for modified death cam: 
	// dissolving will delay 2s to hide player, but player may respawn earlier than 2s, making them being hide after respawn!
	// have to manully clear dissolving effect for player before player.RespawnPlayer() is called
	// this should be enough. also made a defensive fix in sh_death_package.gnut, EnsureDissolveEffectIsClearedForPlayer()
	player.DissolveStop()

	// modified callback: allowing change something before player actually respawns
	// Added via AddCallback_OnPlayerDecideRespawn
	foreach ( callbackFunc in file.playerDecideRespawnCallbacks )
		callbackFunc( player )
	
	// all pre-setups done, it's now safe to respawn player
	DoRespawnPlayer( player, spawnpoint )
}

// modified to add spawnpointOverride
void function RespawnAsPilot( entity player, entity spawnpointOverride = null )
{
	entity spawnpoint = FindSpawnPoint( player, false, ShouldStartSpawn( player ) )
	// modified to add spawnpointOverride
	if ( spawnpointOverride != null )
		spawnpoint = spawnpointOverride

	//print( "spawnpoint in RespawnAsPilot(): " + string( spawnpoint ) )
	DecideRespawnPlayer( player, spawnpoint )
}

// manualPosition is unused... just keep here to avoid conflict with other Northstar scripts
void function RespawnAsTitan( entity player, bool manualPosition = false, entity spawnpointOverride = null )
{
	if( IsAlive( player ) )
		return

	player.Signal( "PlayerRespawnStarted" )
	// modified
	//player.SetPlayerSettings( "spectator" ) // prevent a crash with going from titan => pilot on respawn
	//player.StopPhysics() // need to set this after SetPlayerSettings
	PlayerClassChangeToSpectator( player )
	
	player.isSpawning = true
	entity spawnpoint = FindSpawnPoint( player, true, ShouldStartSpawn( player ) )
	if ( spawnpointOverride != null ) // modified to add: spawnpoint override
		spawnpoint = spawnpointOverride
	else if ( file.recalculateRespawnAsTitanStartPointCallback != null ) // spawnpoint re-calculate callbacks
		spawnpoint = file.recalculateRespawnAsTitanStartPointCallback( player, spawnpoint )

 	TitanLoadoutDef titanLoadout = GetTitanLoadoutForPlayer( player )
	
	asset model = GetPlayerSettingsAssetForClassName( titanLoadout.setFile, "bodymodel" )
	Attachment warpAttach = GetAttachmentAtTimeFromModel( model, "at_hotdrop_01", "offset", spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 0 )
	PlayFX( TURBO_WARP_FX, warpAttach.position, warpAttach.angle )
		
	entity titan = CreateAutoTitanForPlayer_FromTitanLoadout( player, titanLoadout, spawnpoint.GetOrigin(), spawnpoint.GetAngles() )
	DispatchSpawn( titan )
	// removed. prompt won't show when player is dead
	//player.SetPetTitan( null ) // prevent embark prompt from showing up
	// titan setup
	player.SetPetTitan( titan ) // required for marking this player having a pet titan
	// I think vanilla DO set titan to invulnerable for RespawnAsTitan... 
	// at least I spec this behavior in TTDM, while titan respawning
	titan.SetInvulnerable()
	titan.SetNoTarget( true ) // shouldn't let npcs target an invulnerable entity
	titan.SetNoTargetSmartAmmo( true )

	ClearPlayerEliminated( player ) // mark as player not eliminated
	ClearRespawnAvailable( player ) // need so the respawn icon doesn't show

	// titan cleanup
	ClearTitanAvailable( player ) // clear titan availability once it's created, to avoid we failed transfering into titan and softlock our earnmeter
	PlayerEarnMeter_Reset( player ) // pet titan has spawned but player haven't, needs to reset earnmeter

	AddCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING ) // hide hud
	// do titanfall scoreevent
	if ( !level.firstTitanfall )
	{
		if ( Riff_SpawnAsTitan() == 0 )	// only add score if we're not always spawn as titan
		{
			AddPlayerScore( player, "FirstTitanfall", player )

			#if HAS_STATS
				UpdatePlayerStat( player, "misc_stats", "titanFallsFirst" )
			#endif
		}

		level.firstTitanfall = true
	}
	else
	{
		AddPlayerScore( player, "Titanfall", player )
	}
	
	entity camera = CreateTitanDropCamera( spawnpoint.GetAngles(), < 90, titan.GetAngles().y, 0 > )
	camera.SetParent( titan )
	
	// calc offset for spawnpoint angle
	// todo this seems bad but too lazy to figure it out rn
	//vector xyOffset = RotateAroundOrigin2D( < 44, 0, 0 >, < 0, 0, 0>, spawnpoint.GetAngles().y )
	//xyOffset.z = 520 // < 44, 0, 520 > at 0,0,0, seems to be the offset used in tf2
	//print( xyOffset )
	
	vector xyOffset = RotateAroundOrigin2D( < 44, 0, 520 >, < 0, 0, 0 >, spawnpoint.GetAngles().y )
	
	camera.SetLocalOrigin( xyOffset )
	camera.SetLocalAngles( < camera.GetAngles().x, spawnpoint.GetAngles().y, camera.GetAngles().z > ) // this straight up just does not work lol
	camera.Fire( "Enable", "!activator", 0, player )
	
	player.EndSignal( "OnDestroy" )
	//titan.EndSignal( "OnDeath" ) // titan already alive, they can sometimes die( reverted, invulnerability is all good with it )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd
	( 
		function() : ( player, titan, camera, spawnpoint )
		{
			if ( IsValid( player ) )
			{
				RemoveCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING ) // show hud
				player.isSpawning = false

				// clean up player stuffs
				// titan's gonna be destroyed soon, we don't have to clean up
				player.ClearInvulnerable()
				player.SetNoTarget( false )
				player.SetNoTargetSmartAmmo( false )
			}
		
			// should use IsAlive() because we've added "OnDeath" as endsignal
			// reverted, invulnerability is all good with that
			//if ( IsAlive( titan ) )
			if ( IsValid( titan ) )
				titan.Destroy() // pilotbecomestitan leaves an npc titan that we need to delete
			else if ( IsValid( player ) ) // titan died for some reason...
			{
				// if this ever happens, player earnmeter will stuck forever!
				// but due we added invulnerability for titan, should be less possible to happen
				// unless we drop the titan into trigger_hurt or manually killed them
				printt( "RespawnAsTitan() assembly failed. Did you drop the titan into trigger_hurt?" )

				RespawnAsPilot( player, spawnpoint ) // this is 100% an edgecase, just avoid softlocking if we ever hit it in playable gamestates
				// this edgecase can be triggered due to bad spawnpoints...
				// we'd better ragdoll kill player like dropships ragdolling npcs inside of it on death
				// using worldspawn is to keep identical with _gamestate_mp.nut's cleanup
				// damagedef_suicide will trigger death package, using DF_RAGDOLL as scriptType is enough
				// reverted, invulnerability is all good with that, needs re-exam
				//thread DelayedKillRespawnAsTitanFailedPlayer( player )
			}

			camera.Fire( "Disable", "!activator", 0, player )
			camera.Destroy()
		}
	)
	
	waitthread TitanHotDrop( titan, "at_hotdrop_01", spawnpoint.GetOrigin(), spawnpoint.GetAngles(), player, camera ) // do hotdrop anim
		
	// temp fix
	if( IsAlive( player ) )
		return

	DecideRespawnPlayer( player ) // spawn player as pilot so they get their pilot loadout on embark
	player.SetOrigin( titan.GetOrigin() )
	
	// don't make player titan when entity batteryContainer is not valid.
	// This will prevent a servercrash that sometimes occur when evac is disabled and somebody is calling a titan in the defeat screen.
	if( IsValid( titan.GetTitanSoul().soul.batteryContainer ) )
		PilotBecomesTitan( player, titan ) // make player titan
	else
		print( "batteryContainer is not a valid entity in RespawnAsTitan(). Skipping PilotBecomesTitan()." )
}

void function DelayedKillRespawnAsTitanFailedPlayer( entity player )
{
	WaitFrame() // wait for any other "OnDeath" signal triggered function go through
	if ( IsAlive( player ) )
		player.Die( svGlobal.worldspawn, svGlobal.worldspawn, { damageSourceId = damagedef_suicide, scriptType = DF_RAGDOLL } )
}

void function TryGameModeAnnouncement( entity player ) // only putting this here because it's here in gametype_sp lol
{
	if ( !file.enableGamemodeAnnouncement ) // modified
		return
	
	Remote_CallFunction_NonReplay( player, "ServerCallback_GameModeAnnouncement" )
	if ( GetRoundsPlayed() < 1 || IsFirstRoundAfterSwitchingSides() ) // only in first round will vanilla game play the dialogue
		PlayFactionDialogueToPlayer( GameMode_GetGameModeAnnouncement( GAMETYPE ), player )
}

void function SetKillcamsEnabled( bool enabled )
{
	file.killcamsEnabled = enabled
}

bool function KillcamsEnabled()
{
	return file.killcamsEnabled
}

void function SetPlayerDeathsHidden( bool hidden )
{
	file.playerDeathsHidden = hidden
}

void function TrackTitanDamageInPlayerGameStat( int playerGameStat )
{
	file.titanDamageGameStat = playerGameStat
}

void function AddToTitanDamageStat( entity victim, var damageInfo )
{
	if ( !victim.IsTitan() || file.titanDamageGameStat == -1 )
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( attacker == victim ) // self damage, no need to run following calculations
		return
	if ( !attacker.IsPlayer() ) // attacker is not a player
		return

	int damageAmount = CalculateTitanDamageTaken( victim, damageInfo )
	if ( damageAmount == 0 )
		return

	attacker.AddToPlayerGameStat( file.titanDamageGameStat, damageAmount )
}

int function CalculateTitanDamageTaken( entity victim, var damageInfo )
{
	if ( !victim.IsTitan() )
		return 0

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( attacker.IsTitan() && attacker.ContextAction_IsActive() ) // attacker as titan is performing an execution
		return 0 // execution may deal huge amount of damage, don't do calculations

	// should check victim's health!!
	int damageAmount = int( DamageInfo_GetDamage( damageInfo ) )
	int healthLeft = victim.GetHealth()
	entity titanSoul = victim.GetTitanSoul()
	float doomedTime = 0.0
	float currentTime = Time()
	if( IsValid( titanSoul ) )
		doomedTime = titanSoul.soul.doomedStartTime

	// since DoomTitan() is done in damaged callback instead of post damage, we can't get undoomed titan's killshot
	if ( GetDoomedState( victim ) )
	{
		// consider this is a undoomed killshot, in _titan_health.gnut HandleKillShot() we set damage to health - 1, should add 1 more to score
		// if ( healthLeft - 1 == damageAmount && doomedTime == currentTime ) 
		if ( doomedTime == currentTime ) 
			damageAmount += 1
		// consider this is a doomed killshot, cap to max health
		else if ( healthLeft <= damageAmount )
			damageAmount = healthLeft
	}
	// calculation done!
	return damageAmount
}

void function SetRecalculateRespawnAsTitanStartPointCallback( entity functionref( entity player, entity basePoint ) callbackFunc )
{
	file.recalculateRespawnAsTitanStartPointCallback = callbackFunc
}

// stuff to change later

bool function ShouldEntTakeDamage_SPMP( entity ent, var damageInfo )
{
	// dropships are immune to being crushed
	if ( ( IsDropship( ent ) || IsEvacDropship( ent ) ) && IsTitanCrushDamage( damageInfo ) )
		return false
	
	return true
}

float function GetTitanBuildTime(entity player)
{
	return 100.0
}

void function TitanPlayerHotDropsIntoLevel( entity player )
{

}

// modified!!!
bool function IsPlayerDeathsHidden() // new added
{
	return file.playerDeathsHidden
}

void function SetPlayerRespawnForced( bool forced )
{
	file.forcedRespawn = forced
}

void function AddCallback_ShouldPlayerDoForcedRespawn( bool functionref( entity, table ) callbackFunc )
{
	if ( !file.shouldDoForcedRespawnCallbacks.contains( callbackFunc ) )
		file.shouldDoForcedRespawnCallbacks.append( callbackFunc )
}

void function ForcedRespawn_SetDisabledForPlayer( entity player, bool disable )
{
	file.playerDisableForcedRespawn[ player ] = disable
}

bool function ShouldForceRespawnPlayer()
{
	// playlistvar overrides script!
	// lower than 0 means disabled, anything over is the time we wait in seconds
	if ( GetCurrentPlaylistVarFloat( "player_force_respawn", 5 ) < 0 )
		return false

	return file.forcedRespawn
}

bool function ShouldForceRespawnPlayer_FromDamageTable( entity victim, table damageTable )
{
	if ( !ShouldForceRespawnPlayer() ) // main check
		return false

	// extra checks
	foreach ( callbackFunc in file.shouldDoForcedRespawnCallbacks )
	{
		if ( !callbackFunc( victim, damageTable ) ) // if we ever failed a check, return false
			return false
	}

	if ( victim in file.playerDisableForcedRespawn )
		return !file.playerDisableForcedRespawn[ victim ]

	// default value
	return true
}


// force a player to follow certain respawn delay. can be used for spawnwaves
void function SetPlayerRespawnDelayForced( entity player, float respawnDelay )
{
	file.playerRespawnDelay[ player ] = respawnDelay
}

// reset respawn delay to default value: playlistvar "respawn_delay"
void function ResetPlayerRespawnDelay( entity player )
{
	file.playerRespawnDelay[ player ] = GetCurrentPlaylistVarFloat( "respawn_delay", 0.0 )
}

float function GetPlayerRespawnDelay( entity player )
{
	return file.playerRespawnDelay[ player ]
}

void function SetLateJoinRespawnEnabled( bool enabled )
{
	file.enableLateRespawn = enabled
}

bool function IsLateJoinRespawnEnabled()
{
	// playlistvar overrides script!
	if ( GetCurrentPlaylistVarInt( "ns_late_join_respawn", 1 ) == 0 )
		return false
	if ( file.enableLateRespawn )
		return true

	return false
}

void function SetGamemodeAnnouncementEnabled( bool enabled )
{
	file.enableGamemodeAnnouncement = enabled
}

void function SetDeathCamLengthForced( float camLength )
{
	file.forcedDeathCamLength = camLength
}

float function GetForcedDeathCamLength()
{
	return file.forcedDeathCamLength
}

void function SetReplayStartDelayOverride( float delay )
{
	file.replayStartDelayOverride = delay
}

void function SetDeathHintsEnabled( bool enabled )
{
	file.deathHintsEnabled = enabled
}

void function SetDeathHintsInterval( int interval )
{
	file.deathHintsInterval = interval
}

// CodeCallbacks that exists in _base_gametype_sp.gnut
void function CodeCallback_OnWeaponAttack( entity player, entity weapon, string weaponName, int ammoUsed )
{
	// NOTE: this callback isn't called at all!
	// debug
	/*
	print( "RUNNING CodeCallback_OnWeaponAttack()" )
	print( "player: " + string( player ) )
	print( "weapon: " + string( weapon ) )
	print( "weaponName: " + weaponName )
	print( "ammoUsed: " + string( ammoUsed ) )
	*/

	// Added via AddCallback_OnWeaponAttack()
	foreach ( callbackFunc in file.onWeaponAttackCallbacks )
	{
		callbackFunc( player, weapon, weaponName, ammoUsed )
	}
}

void function CodeCallback_OnPlayerMatchmakingChanged( entity player )
{
	// Added via AddCallback_OnPlayerMatchmakingChanged()
	foreach ( callbackFunc in file.onPlayerMatchmakingChangedCallbacks )
	{
		callbackFunc( player )
	}
}

void function CodeCallback_OnWeaponTouch( entity player, entity weapon, int ammoRecieved )
{
	// Added via AddCallback_OnWeaponTouch()
	foreach ( callbackFunc in file.onWeaponTouchCallbacks )
	{
		callbackFunc( player, weapon, ammoRecieved )
	}
}

void function CodeCallback_WeaponDropped( entity weapon )
{
	// Added via AddCallback_WeaponDropped()
	foreach ( callbackFunc in file.weaponDroppedCallbacks )
	{
		callbackFunc( weapon )
	}
}

void function CodeCallback_PlayerHasBeenConnectedForDuration( entity player, float durationInSeconds ) //Empty function declaration to stop load error.
{
	// Added via AddCallback_PlayerHasBeenConnectedForDuration()
	foreach ( callbackFunc in file.playerHasBeenConnectedForDurationCallbacks )
	{
		callbackFunc( player, durationInSeconds )
	}
}

// modified callbacks
void function AddCallback_OnPlayerDecideRespawn( void functionref( entity player ) callbackFunc )
{
	if ( !file.playerDecideRespawnCallbacks.contains( callbackFunc ) )
		file.playerDecideRespawnCallbacks.append( callbackFunc )
}

// vanilla missing AddCallbacks
void function AddCallback_OnWeaponAttack( void functionref( entity player, entity weapon, string weaponName, int ammoUsed ) callbackFunc )
{
	// NOTE: this callback isn't called at all!
	if ( !file.onWeaponAttackCallbacks.contains( callbackFunc ) )
		file.onWeaponAttackCallbacks.append( callbackFunc )
}

void function AddCallback_OnPlayerMatchmakingChanged( void functionref( entity player ) callbackFunc )
{
	if ( !file.onPlayerMatchmakingChangedCallbacks.contains( callbackFunc ) )
		file.onPlayerMatchmakingChangedCallbacks.append( callbackFunc )
}

void function AddCallback_OnWeaponTouch( void functionref( entity player, entity weapon, int ammoRecieved ) callbackFunc )
{
	if ( !file.onWeaponTouchCallbacks.contains( callbackFunc ) )
		file.onWeaponTouchCallbacks.append( callbackFunc )
}

void function AddCallback_WeaponDropped( void functionref( entity weapon ) callbackFunc )
{
	if ( !file.weaponDroppedCallbacks.contains( callbackFunc ) )
		file.weaponDroppedCallbacks.append( callbackFunc )
}

void function AddCallback_PlayerHasBeenConnectedForDuration( void functionref( entity player, float durationInSeconds ) callbackFunc )
{
	if ( !file.playerHasBeenConnectedForDurationCallbacks.contains( callbackFunc ) )
		file.playerHasBeenConnectedForDurationCallbacks.append( callbackFunc )
}