untyped
global const array<string> BATTERY_SPAWNERS = 
[
	"1007270968017", // VoyageDB
	"1007320009732", // Powa
] // for every nessie script

global function EverythingNessy_Init
global function Nessy_EnableAllFunny_Init

global function SpawnNessyOutfit
//global function Nessie_DecoyOutfitInit // this won't work since decoys don't spawn with DispatchSpawn()
global function AllFunctionsTogether
global function CreateNessyHat
global function CreateNessyBackpack
global function CreateNessyPistol
global function CreateNessyWeapon
global function CreateNessyFX
global function ClearNessy

global function Nessie_AlwaysSpawnRGBStuff
// nessie
global function Nessie_SetNessieSpawnEnabled
global function Nessie_SetWorldMaxNessieCount
// battery, not enabled by default
global function Nessie_SetBatterySpawnEnabled
// flag
global function Nessie_SetFunnyFlagEnabled
// decoy
global function Nessie_SetDecoyOutfit
// holospray, not enabled by default
global function Nessie_SetHoloSprayEnabled
// holding prop, not enabled by default
global function Nessie_SetHoldingPropsEnabled

struct NessyHat
{
	asset modelasset
	entity hat
	entity owner
}
struct NessyPack
{
	asset modelasset
	entity pack
	entity owner
}
struct NessyPistol
{
	asset modelasset
	entity pistol
	entity owner
}
struct NessyWeapon
{
	asset modelasset
	entity weapon
	entity owner
}
struct NessyFX
{
	entity fx
	entity owner
}
struct NessyMix
{
	array<asset> mixassets
	array<entity> fxhandles
	entity owner
}

const int MAX_NESSIE_COUNT = 64
const int MAX_FUNNY_FLAGS = 32

struct
{
	bool allSettingsEnabled = false
	bool alwaysRGBSpawn = false // funny

	// nessy
	bool nessieSpawnEnabled = false
	int worldMaxNessieCount = MAX_NESSIE_COUNT // default value
	// battery
	bool batterySpawnEnabled = false
	// flag
	bool flagSpawnEnabled = false
	// decoy
	bool decoyNessieOutfit = false
	// holospray
	bool holoSprayEnabled = false
	// holding prop
	bool holdingPropsEnabled = false

	// entities, no need to change default value
	array<entity> nessieDolls
	array<entity> funnyFlags

	array<NessyHat> nessyhats
	array<NessyPack> nessybackpacks
	array<NessyPistol> nessypistols
	array<NessyWeapon> nessyweapons
	array<NessyFX> nessyfxs
	array<NessyMix> nessymixs

	// cooldowns
	array<entity> holoSprayedPlayer
} file

// now only enabled nessies
const array<asset> placements = 
[
	$"models/domestic/nessy_doll.mdl", 
	$"models/robots/drone_frag/drone_frag.mdl",
	$"models/creatures/prowler/r2_prowler.mdl"
	$"models/robots/marvin/marvin.mdl", 
	$"models/weapons/sentry_frag/sentry_frag.mdl"
]
const array<asset> hatassets = 
[
	$"models/domestic/nessy_doll.mdl", 
	$"models/robots/drone_frag/drone_frag.mdl", 
	$"models/weapons/sentry_frag/sentry_frag.mdl",
	$"models/robots/marvin/marvin.mdl", 
	$"models/creatures/prowler/r2_prowler.mdl", 
	$"models/weapons/data_knife/v_data_knife.mdl",
]
const array<asset> backpackassets = 
[
	$"models/weapons/titan_sword/w_titan_sword_prime.mdl", 
	$"models/weapons/titan_sword/w_titan_sword.mdl", 
	$"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", 
	$"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl", 
	$"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", 
	$"models/weapons/titan_predator/w_titan_predator.mdl", 
	$"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", 
	$"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", 
	$"models/weapons/thr_40mm/w_thr_40mm.mdl", 
	$"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
]
const array<asset> pistolassets = 
[
	$"models/weapons/alternator_smg/w_alternator_smg.mdl", 
	$"models/weapons/p2011_auto/w_p2011_auto.mdl", 
	$"models/weapons/car101/w_car101.mdl", 
	$"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", 
	$"models/weapons/doubletake/w_doubletake.mdl", 
	$"models/weapons/epg/w_epg.mdl", 
	$"models/weapons/hemlock_br/w_hemlock_br.mdl", 
	$"models/weapons/g2/w_g2a4.mdl", 
	$"models/weapons/m1a1_hemlok/w_hemlok.mdl", 
	$"models/weapons/hemlok_smg/w_hemlok_smg.mdl", 
	$"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", 
	$"models/weapons/lstar/w_lstar.mdl", 
	$"models/weapons/mastiff_stgn/w_mastiff.mdl", 
	$"models/weapons/pulse_lmg/w_pulse_lmg.mdl", 
	$"models/weapons/rspn101/w_rspn101.mdl", 
	$"models/weapons/r101_sfp/w_r101_sfp.mdl", $"models/weapons/p2011/w_p2011.mdl", 
	$"models/weapons/w1128/w_w1128.mdl", 
	$"models/weapons/pstl_sa3/w_pstl_sa3.mdl", 
	$"models/weapons/p2011sp/w_p2011sp.mdl", 
	$"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", 
	$"models/weapons/at_rifle/w_at_rifle.mdl", 
	$"models/weapons/softball_at/w_softball_at.mdl", 
	$"models/weapons/vinson/w_vinson.mdl", 
	$"models/weapons/b3wing/w_b3wing.mdl", 
	$"models/weapons/wingman_elite/w_wingman_elite.mdl"
]

const array<asset> fxassets = 
[
	$"P_wpn_arcball_trail", 
	$"P_wpn_meteor_trail", 
	$"P_titan_sniper1"
]
const array<asset> fxmixbase = 
[
	$"titan_sniper_CH_refract", 
	$"titan_sniper_CH_refract", 
	$"titan_sniper_CH_rope_smoke"
]
const array<asset> fxmixMLT = 
[
	$"P_proj_predator_alt_pwr", 
	$"P_projectile_lstar"
]
const array<asset> fxmixIMC = 
[
	$"titan_sniper_CH_trail_arc", 
	$"wpn_grenade_frag_blue", 
	$"P_doubletake_proj", 
	$"P_wpn_mflash_dbltake_FP_burn"
]

int RAGDOLL_IMPACT_TABLE_IDX = -1

void function EverythingNessy_Init()
{
	PrecacheSelectedModels()
	PrecacheSelectedParticles()
	PrecacheParticleSystem( FLAG_FX_FRIENDLY )
	PrecacheParticleSystem( FLAG_FX_ENEMY )

	Nessie_DecoyOutfitInit()

	AddCallback_OnClientConnected( OnClientConnected )

	// following things needs a setting to enable
	if ( !file.allSettingsEnabled )
		return

	if ( Riff_TitanAvailability() == eTitanAvailability.Never )
	{
		Rodeo_SetBatterySkinRandom( true ) // from _rodeo_titan.gnut
		// disabled shield battery usage, since we added rodeo battery throw
		//SetPilotBatteryUsageAllowed( true ) // from pilot_shield_battery.gnut
		//SetShieldBatteryNoLimit( true ) // from pilot_shield_battery.gnut
	}

	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
	AddCallback_OnPlayerKilled( OnPlayerKilled )
	AddCallback_OnPilotBecomesTitan( OnPilotBecomesTitan )
	AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot )

	if( IsNonFlagGamemode() )
		AddCallback_OnTouchHealthKit( "item_flag", OnFlagCollected )

	RAGDOLL_IMPACT_TABLE_IDX = PrecacheImpactEffectTable( "ragdoll_human" )

	// using _rodeo_titan.gnut for more fix about batteries
	//AddClientCommandCallback( "spawnbatt", SpawnBattery )
	//AddClientCommandCallback( "givebatt", GiveEmergencyBattery )
	//AddClientCommandCallback( "clearbatt", ClearBattery )
	//AddClientCommandCallback( "rgbnessie", SpawnRGBNessie ) // use a funnier nessie combo keys

	// satchel funny, related with batteries
	AddCallback_OnSatchelPlanted( OnSatchelPlanted )
	// custom suicide commands
	NessieCommands_EnableKillCommands( true )
	// funny commands
	NessieCommands_EnableUtilCommands( true )
	NessieFunny_EnableClientCommands( true )
}

void function Nessy_EnableAllFunny_Init()
{
	file.allSettingsEnabled = true
}

void function Nessie_AlwaysSpawnRGBStuff( bool always )
{
	file.alwaysRGBSpawn = always
}

bool function IsNonFlagGamemode()
{
	if( GAMETYPE == "ctf" || GAMETYPE == "speedball" || GAMETYPE == "kr" )
		return false

	return true
}

bool function OnFlagCollected( entity player, entity flag )
{
	if ( !IsAlive( player ) || flag.GetParent() != null || player.IsTitan() || player.IsPhaseShifted() ) 
		return false

	//if ( player.GetTeam() != flag.GetTeam() && !expect bool( player.s.hasFlag ) ) 
	// no team check
	if ( !expect bool( player.s.hasFlag ) )
		thread CarryFlag( player, flag ) // pickup enemy flag

	return false // don't wanna delete the flag entity
}

void function CarryFlag( entity player, entity flag )
{
	print( player + " picked up the flag!" )

	flag.SetParent( player, "FLAG" )
	player.s.hasFlag = true
	player.EndSignal( "StartPhaseShift" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	// abandoned for now, keep showing the flag fx!
	//flag.SetOwner( player ) // stop fx for carrier
	//FunnyFlag_StopFX( flag )
	//entity curFlagFX = expect entity( flag.s.fxToHide )
	//if( IsValid( curFlagFX ) )
	//	curFlagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	//entity newFX = FunnyFlag_StartRandomFX( flag )
	//newFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	
	OnThreadEnd(
		function():( player, flag )
		{
			if( IsValid( flag ) )
			{
				flag.ClearParent()
				flag.SetOwner( null )
				flag.SetAngles( < 0, 0, 0 > )
				flag.SetVelocity( < 0, 0, 0 > )
				// abandoned for now, keep showing the flag fx!
				//FunnyFlag_StopFX( flag )
				//FunnyFlag_StartRandomFX( flag )
			}
			if( IsValid( player ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_FlagDrop" )
				player.s.hasFlag = false
			}
		}
	)

	// do notifications
	EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_GrabFlag" )
	AddPlayerScore( player, "FlagTaken" )

	WaitForever()
}

void function CallbackFuncSpawnFlag( entity player )
{
	if( !IsNonFlagGamemode() )
		return
	if( !file.flagSpawnEnabled )
		return
	if( !GamePlaying() )
		return
	if( IsValid( player.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) )
		return
	entity flag = CreateFunnyFlag( player )
	if( flag )
	{
		flag.SetVelocity( player.GetViewVector() * 1000 )
	}
}

void function Nessie_SetFunnyFlagEnabled( bool enabled )
{
	file.flagSpawnEnabled = enabled
}

entity function CreateFunnyFlag( entity player )
{
	// create flag
	entity flag = CreateEntity( "item_flag" )
	flag.SetValueForModelKey( CTF_FLAG_MODEL )
	flag.SetModel( CTF_FLAG_MODEL )
	SetTeam( flag, player.GetTeam() ) // don't set a team if want to make player himself can't see the fx
	flag.MarkAsNonMovingAttachment()
	//flag.Minimap_AlwaysShow( TEAM_IMC, null ) // show flag icon on minimap, for funny flags I say no need
	//flag.Minimap_AlwaysShow( TEAM_MILITIA, null )
	flag.Minimap_Hide( TEAM_IMC, null )
	flag.Minimap_Hide( TEAM_MILITIA, null )
	flag.Minimap_SetAlignUpright( true )
	FunnyFlag_StartRandomFX( flag )
	// abandoned for now, keep showing the flag fx!
	//entity randomFX
	//if( CoinFlip() )
	//	randomFX = PlayFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_FRIENDLY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//else
	//	randomFX = PlayFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_ENEMY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//flag.s.fxToHide <- randomFX
	DispatchSpawn( flag )
	flag.SetModel( CTF_FLAG_MODEL )
	flag.SetOrigin( player.EyePosition() ) // ensure flag doesn't spawn clipped into geometry
	int attachID = flag.LookupAttachment( "fx_end" )
	//flag.SetVelocity( < 0, 0, 1 > )
	
	file.funnyFlags.append( flag )
	CheckFunnyFlagsLimit()

	return flag
}

entity function FunnyFlag_StartRandomFX( entity flag )
{
	entity flagFX
	if( CoinFlip() )
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	else
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	flag.e.fxArray.append( flagFX )

	return flagFX
}

void function FunnyFlag_StopFX( entity flag )
{
	foreach( entity fx in flag.e.fxArray )
	{
		if( IsValid( fx ) )
			EffectStop( fx )
	}

	flag.e.fxArray.clear()
}

void function CheckFunnyFlagsLimit()
{
	if( file.funnyFlags.len() > MAX_FUNNY_FLAGS )
	{
		for( int i = 0; i < file.funnyFlags.len() - 1; i++ )
		{
			if( !IsValid( file.funnyFlags[i] ) )
			{
				file.funnyFlags.remove( i )
				continue
			}
			if( file.funnyFlags[i].GetParent() ) // assuming this is a flag carried by players
				continue
			file.funnyFlags[i].Destroy()
			break
		}
	}
}

void function CallbackFuncThrowHoloSpray( entity player )
{
	if ( !file.holoSprayEnabled )
		return

	if ( IsValid( player.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) ) // hardcode for offhand_antirodeo
		return

	if ( file.holoSprayedPlayer.contains( player ) ) // cooldown
		return
	ThrowHoloSprayForPlayer( player )
	AddHoloSprayCooldown( player ) // cooldown
}

void function AddHoloSprayCooldown( entity player )
{
	if ( file.holoSprayedPlayer.contains( player ) )
		return

	file.holoSprayedPlayer.append( player )
	thread CleanUpPlayerHoloSprayCooldown( player )
}

void function CleanUpPlayerHoloSprayCooldown( entity player )
{
	player.EndSignal( "OnDestroy" )
	wait 2 // at least wait for last spray dissolve
	file.holoSprayedPlayer.removebyvalue( player )
}

void function Nessie_SetHoloSprayEnabled( bool enabled )
{
	file.holoSprayEnabled = enabled
}

void function Nessie_SetHoldingPropsEnabled( bool enabled )
{
	file.holdingPropsEnabled = enabled
	HoldingProp_SetUseNotSolidHolding( enabled ) // bind together
}

void function OnClientConnected( entity player )
{
	// nessie
	AddButtonPressedPlayerInputCallback( player, IN_USE, CallbackFuncSpawnNessy )
	AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, CallbackFuncSpawnNessy )
	// battery
	AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnBattery )
	AddPlayerHeldButtonEventCallback( player, IN_MELEE, CallbackFuncThrowBattery, 0.5 ) // should only be use this if disabled primary melee?
	// flag
	player.s.hasFlag <- false
	AddButtonPressedPlayerInputCallback( player, IN_OFFHAND2, CallbackFuncSpawnFlag )
	// ragdoll... not using
	//AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnRagdoll )
	// holospray, was IN_OFFHAND0
	AddButtonPressedPlayerInputCallback( player, IN_OFFHAND2, CallbackFuncThrowHoloSpray )
}

void function OnPlayerRespawned( entity player )
{

}

void function OnPlayerChangeLoadout( entity player, PilotLoadoutDef p )
{
	SpawnNessyOutfit( player )
}

void function Nessie_DecoyOutfitInit()
{
	// modified callbacks in mp_ability_holopilot.nut
	AddCallback_OnDecoyCreated( SpawnDecoyOutfit )
	AddCallback_PlayerDecoyDie( DecoyOutfitCleanUp )
	AddCallback_PlayerDecoyDissolve( DecoyOutfitCleanUp )

	AddCallback_OnModdedDecoyCreated( SpawnDecoyOutfit ) // separented callbacl
}

void function SpawnDecoyOutfit( entity decoy )
{
	if ( file.decoyNessieOutfit || file.allSettingsEnabled )
		SpawnNessyOutfit( decoy )
}

void function DecoyOutfitCleanUp( entity decoy, int currentState )
{
	// decoy won't call "OnDeath", have to manually destroy outfit
	ClearNessy( decoy )
}

void function Nessie_SetDecoyOutfit( bool set )
{
	file.decoyNessieOutfit = set
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{

}

void function OnPilotBecomesTitan( entity player, entity titan )
{

}

void function OnTitanBecomesPilot( entity titan, entity player )
{
	SpawnNessyOutfit( player )
}

void function PrecacheSelectedModels()
{
	foreach( asset model in placements )
	{
		PrecacheModel( model )
	}
	foreach( asset model in hatassets )
	{
		PrecacheModel( model )
	}
	foreach( asset model in backpackassets )
	{
		PrecacheModel( model )
	}
}

void function PrecacheSelectedParticles()
{
	foreach( asset particle in fxassets )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixbase )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixMLT )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in fxmixIMC )
	{
		PrecacheParticleSystem( particle )
	}
}

void function SpawnNessyOutfit( entity ent )
{
	thread SpawnNessyOutfit_Threaded( ent )
}

void function SpawnNessyOutfit_Threaded( entity ent )
{
	ClearNessy( ent ) // defensive clear!
	WaitFrame() // better wait for model stuffs set up, we have "altpilot"
	if( !IsAlive( ent ) )
		return
	if( ent.IsTitan() )
		return

	//AllFunctionsTogether( player )
	CreateNessyHat( hatassets, ent )
	CreateNessyBackpack( backpackassets, ent )
	//CreateNessyFX( fxassets, player )
	//CreateNessyPistol( pistolassets, player )
	thread TrackNessyOutfitOwnerDeath( ent )
}

void function TrackNessyOutfitOwnerDeath( entity ent )
{
	ent.EndSignal( "OnDestroy" ) // destroyed ent gets their parent destroyed, no worries

	ent.WaitSignal( "OnDeath" )
	ClearNessy( ent )
}

bool function SpawnBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	//if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		//return false
	if( !file.batterySpawnEnabled )
		return false
	if( !GamePlaying() )
		return false

	if( !(args.len() == 0) )
	{
		bool isPickup = false
		bool isThrow = false
		if( args.contains( "pickup" ) )
			isPickup = true
		if( args.contains( "throw" ) )
			isThrow = true
		
		entity battery = Rodeo_CreateBatteryPack( player, isPickup, true )
		if( isThrow )
		{
			if( battery )
			{
				vector batteryVel = player.GetViewVector() * 1000
				battery.SetVelocity( batteryVel )
				//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
			}
		}
		print( "[NESSIE] " + player.GetPlayerName() + " modified spawning a battery!" )
	}
	else
	{
		Rodeo_CreateBatteryPack( player )
		print( "[NESSIE] " + player.GetPlayerName() + " spawned a battery!" )
	}

	return true
}

bool function GiveEmergencyBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	PlayerInventory_PushInventoryItemByBurnRef( player, "burnmeter_emergency_battery" )
	print( "[NESSIE] " + player.GetPlayerName() + " give themselves an emergency battery!" )
	return true
}

bool function ClearBattery( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	foreach ( entity battery in GetEntArrayByClass_Expensive( "item_titan_battery" ) )
		battery.Destroy() // there's some fix in _rodeo_titan.gnut
	foreach( entity player in GetPlayerArray() )
	{
		while( GetPlayerBatteryCount( player ) > 0 )
		{
			entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
			if( IsValid( battery ) )
				battery.Destroy()
		}
	}

	PilotBattery_SetMaxCount( 1 )
	print( "[NESSIE] " + player.GetPlayerName() + " cleared all batteries!" )
	
	return true
}

bool function SpawnRGBNessie( entity player, array<string> args )
{
	entity Prop = CreateEntity( "prop_dynamic" )
	Prop.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	Prop.kv.rendercolor = "81 130 151"   
	vector angles = player.EyeAngles()
	vector origin = GetPlayerCrosshairOrigin( player )
	angles.x = 0;
	angles.y += 90
	angles.z = 0;
	origin.z += -30
	Prop.SetOrigin( origin )
	Prop.SetAngles( angles )
	DispatchSpawn( Prop )
	SetTeam( Prop, player.GetTeam() )
	thread RGB_Highlight( Prop, true )
	file.nessieDolls.append( Prop )

	NessieLimitThink()
	return true
}

void function CallbackFuncSpawnNessy( entity player )
{
	// holding prop
	if ( file.holdingPropsEnabled )
	{
		bool playerCrouching = player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )
		if ( IsValid( HoldingProp_GetPlayerPickedProp( player ) ) ) // already holding someting!
		{
			HoldingProp_PlayerDropPickedEntity( player ) // cause it to drop
			return
		}
		else if ( playerCrouching ) // triggering pickup when crouched
		{
			if ( HoldingProp_PlayerTryPickUpEntity( player ) ) // player successfully picked up something!
				return // never do nessie spawn
		}
	}

	if ( !file.nessieSpawnEnabled && !file.allSettingsEnabled ) // bind together with allSettingsEnabled
		return

	// for rgb nessie check
	bool badCombo = ( (player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ) )
	bool goodCombo = ( ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_JUMP ) && player.IsInputCommandHeld( IN_BACK ) && player.IsInputCommandHeld( IN_MELEE ) )
	bool isMoving = ( player.IsSliding() || player.IsWallRunning() || !player.IsOnGround() ) && !player.IsZiplining()
	//print( badCombo )
	//print( goodCombo )

	// nessie spawning has no limit, and nessie only!
	asset spawnAsset = placements[ RandomInt(placements.len()) ]

	entity nessie = CreateEntity( "prop_dynamic" )
	nessie.SetValueForModelKey( spawnAsset )
	//nessie.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	//nessie.kv.rendercolor = "81 130 151"   

	// hardcoded here...
	float modelScale = 1.0
	switch ( spawnAsset )
	{
		case $"models/creatures/prowler/r2_prowler.mdl":
			modelScale = 0.2
			break
		case $"models/robots/drone_frag/drone_frag.mdl":
		case $"models/robots/marvin/marvin.mdl":
			modelScale = 0.3
			break
		case $"models/weapons/sentry_frag/sentry_frag.mdl":
			modelScale = 0.35
			break
	}
	nessie.kv.modelscale = modelScale

	// angles offset
	float yawOffset = -180 // default value
	float physicsYawOffset = 180
	switch ( spawnAsset )
	{
		case $"models/domestic/nessy_doll.mdl":
			yawOffset = 90
			physicsYawOffset = 90 // facing the thrower
			break
	}
	// vertical offset( static )
	float verticleOffset = -32
	// origin offset( with physics )
	vector parentedOffset = < 0, 0, -10 >
	switch ( spawnAsset )
	{
		case $"models/creatures/prowler/r2_prowler.mdl":
			parentedOffset = < 5, 0, -8 >
			break
		case $"models/domestic/nessy_doll.mdl":
			parentedOffset = < 0, 0, -3 >
			break
		case $"models/weapons/sentry_frag/sentry_frag.mdl":
			parentedOffset = < 0, 0, -8 >
			break
	}
	
	SetTeam( nessie, player.GetTeam() )
	if( isMoving )
	{
		// spawn a physics
		entity physics = CreateEntity( "prop_physics" )
		physics.SetValueForModelKey( $"models/dev/empty_physics.mdl" )
        physics.SetOrigin( player.EyePosition() + player.GetViewVector() * 100 + < 0,0,40 > ) // don't spawn so close, or it will interrupt zipline
		physics.SetAngles( < 0, player.EyeAngles().y, 0 > )
		physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
		physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS // cannot block weapons, not work why?
		//physics.NotSolid() // so they won't block bullets
		DispatchSpawn( physics )
		physics.SetModel( $"models/dev/empty_physics.mdl" )
		physics.SetVelocity( player.GetViewVector() * 1000 )

		// attach nessie
		nessie.SetParent( physics, "origin" )
		nessie.SetAngles( < 0, physicsYawOffset, 0 > ) // rotate
		nessie.SetOrigin( parentedOffset ) // offset
		thread NessiePhysicsLifeTimeCheck( physics, nessie )

		// test
		//entity test = CreateEntity( "prop_dynamic" )
		//test.SetValueForModelKey( $"models/weapons/bullets/mgl_grenade.mdl" )
		//test.SetParent( physics, "origin" )
		//DispatchSpawn( test )
		//test.SetModel( $"models/weapons/bullets/mgl_grenade.mdl" )
	}
	else
	{
		vector angles = player.EyeAngles()
		vector origin = GetPlayerCrosshairOrigin( player )
		//nessie.kv.modelscale = 50
		//Highlight_SetFriendlyHighlight( nessie, "health_pickup" )
		angles.x = 0
		// defensive fix!
		angles.y += yawOffset
		angles.y = ClampAngle( angles.y )
		
		//print( angles.y )
		angles.z = 0
		origin.z += verticleOffset
		nessie.SetOrigin( origin )
		nessie.SetAngles( angles )
	}

	DispatchSpawn( nessie )
	if ( spawnAsset == $"models/robots/marvin/marvin.mdl" ) // marvin's faces
		nessie.SetSkin( RandomIntRange( 1, 3 ) ) // happy and sad face, ttf2 only have these two faces

	if( badCombo || file.alwaysRGBSpawn )
		thread RGB_Highlight( nessie, true )
	if( goodCombo )
	{
		EmitSoundOnEntityOnlyToPlayer( player, player, "UI_Spawn_FriendlyPilot" )
		thread RainbowPlayerSkin( player )
		thread RainbowWeaponSkin( player )
	}

	file.nessieDolls.append( nessie )

	//thread DelayedDissolveNessie( nessie )
	NessieLimitThink()
}

void function Nessie_SetNessieSpawnEnabled( bool enabled )
{
	file.nessieSpawnEnabled = enabled
}

void function Nessie_SetWorldMaxNessieCount( int count )
{
	file.worldMaxNessieCount = count
}

void function CallbackFuncSpawnBattery( entity player )
{
	if( !file.batterySpawnEnabled )
		return
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return

	entity battery = Rodeo_CreateBatteryPack( player, false, true )
	bool badCombo = ((player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ))
	if ( !IsValid( battery ) ) // battery won't be returned it's picked up by player immediately
		battery = GetBatteryOnBack( player )
	if( IsValid( battery ) )
	{
		// never blocks bullet, but also unable to stack batteries. won't work!
		//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS
		//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
		if ( !IsValid( battery.GetParent() ) ) // don't reset velocity if it's bind with something(eg. player)
		{
			vector batteryVel = player.GetViewVector() * 1000
			battery.SetVelocity( batteryVel )
		}
		battery.SetBossPlayer( player ) // add a boss player for this battery! we can track satchel planting later
		if( badCombo || file.alwaysRGBSpawn )
			thread RGY_BatterySkin( battery )
		HoldingProp_SetEntityCanBePickedUpForced( battery, true ) // make battery pickupable
	}
}

void function CallbackFuncThrowBattery( entity player )
{
	// leave the same check as spawnbattery does
	if( !file.batterySpawnEnabled )
		return
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return

	Rodeo_PilotThrowsBattery( player )
}

void function Nessie_SetBatterySpawnEnabled( bool enabled )
{
	file.batterySpawnEnabled = enabled
}

// satchel funny related with batteries
function OnSatchelPlanted( player, collisionParams )
{
	expect entity( player )
	expect table( collisionParams )

	//print( "RUNNING OnSatchelPlanted()" )
	// satchel planted on battery!
	if ( file.batterySpawnEnabled )
	{
		entity hitEnt = expect entity( collisionParams.hitEnt )
		//print( "hitEnt: " + string( hitEnt ) )
		if ( IsValid( hitEnt ) && hitEnt.GetClassName() == "item_titan_battery" )
		{
			entity bossPlayer = hitEnt.GetBossPlayer()
			//print( "bossPlayer: " + string( bossPlayer ) )
			array<entity> traps = GetScriptManagedEntArray( player.s.activeTrapArrayId )
			entity satchel
			foreach ( entity trap in traps )
			{
				entity child = hitEnt.FirstMoveChild()
				//print( "trap: " + string( trap ) + ", child: " + string( child ) )
				if ( child == trap )
					satchel = child
			}
			if ( IsValid( satchel ) && IsValid( bossPlayer ) && bossPlayer == satchel.GetThrower() )
			{
				satchel.ClearParent()
				string attachment = "vent_center"
				vector offset = < 0, 0, 0 >
				vector angles = < 0, 0, -90 >
				if ( bossPlayer.LookupAttachment( "vent_center" ) < 0 ) // anti-crash
				{
					attachment = "CHESTFOCUS"
					offset = < -13, 0, -5 >
					angles = < 0, -180, 0 >
				}
				satchel.SetParent( bossPlayer, attachment )
				satchel.SetOrigin( offset )
				satchel.SetAngles( angles )

				// attach a bigger satchel!
				asset satchelModel = satchel.GetModelName()
				entity biggerSatchel = CreateEntity( "prop_dynamic" )
				biggerSatchel.SetModel( satchelModel )
				DispatchSpawn( biggerSatchel )
				
				attachment = "CHESTFOCUS"
				offset = < -13, 0, -5 >
				angles = < 0, -180, 0 >
				biggerSatchel.SetParent( bossPlayer, attachment )
				biggerSatchel.SetOrigin( offset )
				biggerSatchel.SetAngles( angles )
				biggerSatchel.Highlight_SetInheritHighlight( true )
				biggerSatchel.kv.modelscale = 3
				thread TrackSatchelLifeTime( satchel, biggerSatchel )
			}
		}
	}
}

void function TrackSatchelLifeTime( entity satchel, entity biggerSatchel )
{
	biggerSatchel.EndSignal( "OnDestroy" )
	satchel.WaitSignal( "OnDestroy" )
	//biggerSatchel.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
	biggerSatchel.Destroy()
}

void function CallbackFuncSpawnRagdoll( entity player )
{
	thread SpawnRagdoll_Threaded( player )
}

void function SpawnRagdoll_Threaded( entity player )
{
	entity copyModel = player.CreatePlayerDecoy( 1 )//CreateCopyOfPlayerModel( player )
	vector curVelocity = player.GetVelocity()
	copyModel.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ()
		{
			print( "Copy Model has been destroyed!" )
		}
	)
	copyModel.SetOrigin( player.GetOrigin() )
	copyModel.SetAngles( player.GetAngles() )
	wait 0.2
	copyModel.Anim_Play( "ACT_MP_MELEE_KNIFE_FIRST" )
	//copyModel.BecomeRagdoll( < 0,0,0 >, false )
	HideName( copyModel )
	WaitForever()
	//copyModel.SetActivityModifier( ACT_MODIFIER_STAGGER, true ) // not for a propDynamic
	//wait 2
	//copyModel.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
	//copyModel.SetContinueAnimatingAfterRagdoll( true )
	//
}

entity function CreateCopyOfPlayerModel( entity player )
{
	entity model = CreatePropDynamic( player.GetModelName() )

	SetTeam( model, player.GetTeam() )

	//model.SetSkin( player.GetSkin() )
	//model.SetCamo( player.GetCamo() )

	//RandomizeHead( model )

	return model
}

void function DelayedDissolveNessie( entity nessy )
{
	wait 10
	if( IsValid( nessy ) )
		nessy.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
}

void function NessieLimitThink()
{
	if( file.nessieDolls.len() > file.worldMaxNessieCount )
	{
		if( IsValid( file.nessieDolls[0] ) )
			file.nessieDolls[0].Destroy()
		file.nessieDolls.remove(0)
	}
}

void function NessiePhysicsLifeTimeCheck( entity physics, entity nessie )
{
	nessie.EndSignal( "OnDestroy" )
	physics.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( nessie, physics )
		{
			if( IsValid( nessie ) )
				nessie.Destroy()
			if( IsValid( physics ) )
				physics.Destroy()
		}
	)

	WaitForever()
}

void function AllFunctionsTogether( entity player )
{
	CreateNessyHat( hatassets, player )
	CreateNessyBackpack( backpackassets, player )
	CreateNessyPistol( pistolassets, player )
	CreateNessyWeapon( pistolassets, player )
	if( IsFFAGame() )
		CreateNessyFX( fxassets, player )
	else
		CreateMixedNessyFX( fxmixbase, fxmixMLT, fxmixIMC, player )
}

void function CreateNessyHat( array<asset> modelassets, entity player )
{
	NessyHat nessy
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.hat = CreateEntity( "prop_dynamic" )
	nessy.hat.SetModel( nessy.modelasset )
	nessy.owner = player
	nessy.hat.SetParent( nessy.owner, "HEADSHOT" )
	nessy.hat.Highlight_SetInheritHighlight( true )
	SetNessyHatStats( nessy )
	file.nessyhats.append(nessy)
}

void function SetNessyHatStats( NessyHat nessy )
{
	if ( CanRemoveHead( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 1 ) // remove head
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.SetAngles( < 0, -90, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 1 ) // remove head
			nessy.hat.SetOrigin( < 0, 0, -15 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/sentry_frag/sentry_frag.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 1 ) // remove head
			nessy.hat.SetOrigin( < 0, 0, -12 > )
			nessy.hat.kv.modelscale = 0.35
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 1 ) // remove head
			nessy.hat.SetOrigin( < -5, 0, -25 > )
			nessy.hat.kv.modelscale = 0.4
			thread TrackMarvinOwnerDamaged( nessy.owner, nessy.hat )
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 0 ) // give head back
			if ( HasFlatHead( nessy.owner ) ) // spectre
				nessy.hat.SetOrigin( < 0, 0, 1 > )
			else
				nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		/*
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -25 > )
			nessy.hat.SetAngles( < -90, 0, 0 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		*/
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.owner.SetBodygroup( GetRemovableHeadBodyGroupId( nessy.owner ), 0 ) // give head back
			if ( HasFlatHead( nessy.owner ) ) // spectre
				nessy.hat.SetOrigin( < 2, 0, 5 > )
			else
				nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else if( CannotRemoveHelmet( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -3 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/sentry_frag/sentry_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -1 > )
			nessy.hat.kv.modelscale = 0.35
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.kv.modelscale = 0.3
			thread TrackMarvinOwnerDamaged( nessy.owner, nessy.hat )
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else if( HasFlatHead( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -5 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/sentry_frag/sentry_frag.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -3 > )
			nessy.hat.kv.modelscale = 0.35
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, -12 > )
			nessy.hat.kv.modelscale = 0.3
			thread TrackMarvinOwnerDamaged( nessy.owner, nessy.hat )
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.hat.SetOrigin( < 0, 0, 1 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.hat.SetOrigin( < 2, 0, 5 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
	else
	{
		if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 0 ) // give helmet back
			nessy.hat.SetOrigin( < 0, 0, 0 > )
			return
		}
		if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 ) // remove helmet
			nessy.hat.SetOrigin( < 0, 0, -3 > )
			nessy.hat.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/sentry_frag/sentry_frag.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 ) // remove helmet
			nessy.hat.SetOrigin( < 0, 0, -1 > )
			nessy.hat.kv.modelscale = 0.35
			return
		}
		if( nessy.modelasset == $"models/robots/marvin/marvin.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 0 ) // give helmet back
			nessy.hat.SetOrigin( < 0, 0, -10 > )
			nessy.hat.kv.modelscale = 0.3
			thread TrackMarvinOwnerDamaged( nessy.owner, nessy.hat )
			return
		}
		if( nessy.modelasset == $"models/creatures/prowler/r2_prowler.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 0 ) // give helmet back
			nessy.hat.SetOrigin( < 0, 0, 3 > )
			nessy.hat.kv.modelscale = 0.15
			return
		}
		if( nessy.modelasset == $"models/weapons/data_knife/v_data_knife.mdl" )
		{
			nessy.owner.SetBodygroup( nessy.owner.FindBodyGroup( "head" ), 1 ) // remove helmet
			nessy.hat.SetOrigin( < 2, 0, 7 > )
			nessy.hat.SetAngles( < 0, 0, 0 > )
			return
		}
	}
}

// switch marvin's face when owner damaged
void function TrackMarvinOwnerDamaged( entity owner, entity marvin )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDestroy" )

	while ( true )
	{
		waitthread MarvinUndamagedFace( owner, marvin )
		waitthread MarvinWounded( owner, marvin )
	}
}

void function MarvinUndamagedFace( entity owner, entity marvin )
{
	//print( "marvin is happy!" )
	owner.EndSignal( "OnDamaged" )
	marvin.SetSkin( 1 ) // happy face
	WaitForever()
}

void function MarvinWounded( entity owner, entity marvin )
{
	//print( "marvin is unhappy!" )
	marvin.SetSkin( 2 ) // sad face
	wait 2.3 // max duration
}

void function CreateNessyBackpack( array<asset> modelassets, entity player )
{
	NessyPack nessy
	nessy.owner = player
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.pack = CreateEntity( "prop_dynamic" )
	nessy.pack.SetModel( nessy.modelasset )
	nessy.pack.SetParent( nessy.owner, "CHESTFOCUS" )
	nessy.pack.Highlight_SetInheritHighlight( true )
	SetNessyBackpackStats( nessy )
	file.nessybackpacks.append(nessy)
}

void function SetNessyBackpackStats( NessyPack nessy )
{
	if( HasBigBackpack( nessy.owner ) )
	{
		if( nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword_prime.mdl" || nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -14, 10, 10 > )
					nessy.pack.SetAngles( < -135, 90, 0 > )
					break
				case 1:
					nessy.pack.SetOrigin( < -7, 8, 3 > )
					nessy.pack.SetAngles( < 180, 0, 0 > )
					break
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -13, 8, 8 > )
					nessy.pack.SetAngles( < 135, 90, 0 > )
					break
				case 1:
					nessy.pack.SetOrigin( < -8, 8, 6 > )
					nessy.pack.SetAngles( < 90, 0, 180 > )
					break
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl" )
		{
			nessy.pack.SetOrigin( < -13, 8, 8 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
		else
		{
			nessy.pack.SetOrigin( < -15, 10, 10 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
	}
	else
	{
		if( nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword_prime.mdl" || nessy.modelasset == $"models/weapons/titan_sword/w_titan_sword.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					if( IsHeavyPilot( nessy.owner ) || HasSmallBackpack( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -10, 10, 10 > )
						nessy.pack.SetAngles( < -135, 90, 0 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -8, 10, 10 > )
						nessy.pack.SetAngles( < -135, 90, 0 > )
						break
					}
				case 1:
					if( IsHeavyPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -5, 10, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
					if( IsLightPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -4, 8, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -7, 8, 3 > )
						nessy.pack.SetAngles( < 180, 0, 0 > )
						break
					}
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl" )
		{
			switch( RandomInt(2) )
			{
				case 0:
					nessy.pack.SetOrigin( < -8, 8, 8 > )
					nessy.pack.SetAngles( < 135, 90, 0 > )
					break
				case 1:
					if( IsHeavyPilot( nessy.owner ) )
					{
						nessy.pack.SetOrigin( < -8, 10, 6 > )
						nessy.pack.SetAngles( < 90, 0, 180 > )
						break
					}
					else
					{
						nessy.pack.SetOrigin( < -8, 7, 6 > )
						nessy.pack.SetAngles( < 90, 0, 180 > )
						break
					}
			}
			nessy.pack.kv.modelscale = 0.3
			return
		}
		if( nessy.modelasset == $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl" )
		{
			nessy.pack.SetOrigin( < -8, 8, 8 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
		else
		{
			nessy.pack.SetOrigin( < -10, 10, 10 > )
			nessy.pack.SetAngles( < 135, 90, 0 > )
			nessy.pack.kv.modelscale = 0.3
			return
		}
	}
}

void function CreateNessyPistol( array<asset> modelassets, entity player )
{
	NessyPistol nessy
	nessy.owner = player
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.pistol = CreateEntity( "prop_dynamic" )
	nessy.pistol.SetModel( nessy.modelasset )
	nessy.pistol.SetParent( nessy.owner, "SIDEARM_HOLSTER" )
	nessy.pistol.Highlight_SetInheritHighlight( true )
	SetNessyPistolStats( nessy )
	file.nessypistols.append(nessy)
}

void function SetNessyPistolStats( NessyPistol nessy )
{
	nessy.pistol.SetOrigin( < 0, 0, 0 > )
	nessy.pistol.SetAngles( < 0, 0, 0 > )
	if( IsPilotPistol( nessy.modelasset ) )
	{
		nessy.pistol.kv.modelscale = 1.2
		return
	}
	else
	{
		nessy.pistol.kv.modelscale = 0.7
		return
	}
}

void function CreateNessyWeapon( array<asset> modelassets, entity player )
{
	NessyWeapon nessy
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.weapon = CreateEntity( "prop_dynamic" )
	nessy.weapon.SetModel( nessy.modelasset )
	nessy.owner = player
	nessy.weapon.SetParent( nessy.owner, "PROPGUN" )
	nessy.weapon.Highlight_SetInheritHighlight( true )
	SetNessyWeaponStats( nessy )
	file.nessyweapons.append(nessy)
}

void function SetNessyWeaponStats( NessyWeapon nessy )
{
	if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, 0> )
		return
	}
	if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, -5> )
		nessy.weapon.kv.modelscale = 0.3
		return
	}
}

void function CreateNessyFX( array<asset> fxassets, entity player )
{
	NessyFX nessy
	asset fxasset = fxassets[ RandomInt(fxassets.len()) ]
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	nessy.fx = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( fxasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	nessy.fx.SetOwner( nessy.owner )
	nessy.fx.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only

	file.nessyfxs.append(nessy)
}

void function CreateMixedNessyFX( array<asset> mixbase, array<asset> mixmlt, array<asset> miximc, entity player )
{
	NessyMix nessy
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	foreach( asset baseasset in mixbase )
	{
		entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( baseasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		handle.SetOwner( nessy.owner )
		handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
		nessy.fxhandles.append( handle )
	}
	if( player.GetTeam() == TEAM_MILITIA )
	{
		foreach( asset mltasset in mixmlt )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( mltasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	if( player.GetTeam() == TEAM_IMC )
	{
		foreach( asset imcasset in miximc )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( imcasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	file.nessymixs.append(nessy)
}

void function ClearNessy( entity player )
{
	foreach( NessyHat nessy in file.nessyhats )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.hat ) )
			{
				nessy.hat.Destroy()
				//nessy.hat.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				file.nessyhats.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyPack nessy in file.nessybackpacks )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.pack ) )
			{
				nessy.pack.Destroy()
				//nessy.pack.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				file.nessybackpacks.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyPistol nessy in file.nessypistols )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.pistol ) )
			{
				nessy.pistol.Destroy()
				//nessy.pistol.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				file.nessypistols.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyWeapon nessy in file.nessyweapons )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.weapon ) )
			{
				nessy.weapon.Destroy()
				//nessy.weapon.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
				file.nessyweapons.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyFX nessy in file.nessyfxs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fx ) )
			{
				EffectStop( nessy.fx )
				file.nessyfxs.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyMix nessy in file.nessymixs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fxhandles ) )
			{
				foreach( entity handle in nessy.fxhandles )
				{
					if( IsValid(handle) )
						EffectStop( handle )
				}
				file.nessymixs.removebyvalue( nessy )
			}
		}
	}
}

bool function IsHeavyPilot( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_heavy_drex_m.mdl" ||
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_drex_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_roog_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_heavy_roog_m.mdl" || 
		player.GetModelName() == $"models/humans/grunts/imc_grunt_shield_captain.mdl" )
		return true

	return false
}

bool function IsLightPilot( entity player )
{
	if( player.GetModelName() == $"models/Humans/heroes/imc_hero_blisk.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_ash.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_medium_reaper_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/sp_medium_geist_f.mdl" || 
		player.GetModelName() == $"models/humans/heroes/mlt_hero_sarah.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true

	return false
}

bool function HasBigBackpack( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_light_jester_m.mdl" || 
		player.GetModelName() == $"models/humans/grunts/mlt_grunt_lmg.mdl" ||
		player.GetModelName() == $"models/robots/spectre/imc_spectre.mdl" )
		return true

	return false
}

bool function HasSmallBackpack( entity player )
{
	if( player.GetModelName() == $"models/humans/heroes/mlt_hero_jack.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true

	return false
}

bool function CanRemoveHead( entity player )
{
	if( player.GetModelName() == $"models/humans/pilots/pilot_light_ged_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_ged_f.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_m.mdl" || 
		player.GetModelName() == $"models/humans/pilots/pilot_light_jester_f.mdl" )
		return true
	
	// spectre uses this...
	int bodyGroupId = player.FindBodyGroup( "removableHead" )
	if ( bodyGroupId > 0 )
		return true

	return false
}

int function GetRemovableHeadBodyGroupId( entity player )
{
	int bodyGroupId = player.FindBodyGroup( "removableHead" )
	if ( bodyGroupId > 0 )
		return bodyGroupId
	bodyGroupId = player.FindBodyGroup( "head" )
	if ( bodyGroupId > 0 )
		return bodyGroupId
	
	return 0
}

bool function CannotRemoveHelmet( entity player )
{
	if( player.GetModelName() == $"models/humans/heroes/mlt_hero_sarah.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_blisk.mdl" || 
		player.GetModelName() == $"models/Humans/heroes/imc_hero_ash.mdl" )
		return true

	return false
}

bool function HasFlatHead( entity player )
{
	// spectre mostly handling in canRemoveHead
	if( player.GetModelName() == $"models/robots/spectre/imc_spectre.mdl" )
		return true

	return false
}

bool function IsPilotWeapon( asset model )
{
	if( [$"models/weapons/alternator_smg/w_alternator_smg.mdl", $"models/weapons/p2011_auto/w_p2011_auto.mdl", $"models/weapons/car101/w_car101.mdl", $"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", $"models/weapons/doubletake/w_doubletake.mdl", $"models/weapons/epg/w_epg.mdl", $"models/weapons/hemlock_br/w_hemlock_br.mdl", $"models/weapons/g2/w_g2a4.mdl", $"models/weapons/m1a1_hemlok/w_hemlok.mdl", $"models/weapons/hemlok_smg/w_hemlok_smg.mdl", $"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", $"models/weapons/lstar/w_lstar.mdl", $"models/weapons/mastiff_stgn/w_mastiff.mdl", $"models/weapons/pulse_lmg/w_pulse_lmg.mdl", $"models/weapons/rspn101/w_rspn101.mdl", $"models/weapons/r101_sfp/w_r101_sfp.mdl", $"models/weapons/p2011/w_p2011.mdl", $"models/weapons/w1128/w_w1128.mdl", $"models/weapons/pstl_sa3/w_pstl_sa3.mdl", $"models/weapons/p2011sp/w_p2011sp.mdl", $"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", $"models/weapons/at_rifle/w_at_rifle.mdl", $"models/weapons/softball_at/w_softball_at.mdl", $"models/weapons/vinson/w_vinson.mdl", $"models/weapons/b3wing/w_b3wing.mdl", $"models/weapons/wingman_elite/w_wingman_elite.mdl"].contains( model ) )
		return true

	return false
}

bool function IsPilotPistol( asset model )
{
	if( [$"models/weapons/b3wing/w_b3wing.mdl", $"models/weapons/wingman_elite/w_wingman_elite.mdl", $"models/weapons/p2011/w_p2011.mdl", $"models/weapons/p2011_auto/w_p2011_auto.mdl", $"models/weapons/pstl_sa3/w_pstl_sa3.mdl"].contains( model ) )
		return true

	return false
}

bool function IsTitanWeapon( asset model )
{
	if( [$"models/weapons/titan_sword/w_titan_sword_prime.mdl", $"models/weapons/titan_sword/w_titan_sword.mdl", $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl", $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", $"models/weapons/titan_predator/w_titan_predator.mdl", $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", $"models/weapons/thr_40mm/w_thr_40mm.mdl", $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"].contains( model ) )
		return true

	return false
}