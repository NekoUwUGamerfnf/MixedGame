untyped

global function ClassicRodeo_InitPlaylistVars

#if SERVER
global function ClassicRodeo_SetRodeoAttackDamageScale

global function CreateClassicRodeoWeakpoint

// callbacks
global struct RodeoWeakPointDamage
{
	int rodeoDamage = 0
	float damageScale = 1.0
	int damageSourceID = eDamageSourceId.rodeo
	int damageTypes = DF_BYPASS_SHIELD | DF_CRITICAL

	bool shouldMultiplyDamage = true
}

global function AddCallback_ClassicRodeo_WeakPointDamaged

// debug
const bool CLASSIC_RODEO_DEBUG = false

// handling hardcoded nerf!
const array<int> NO_ADDITIONAL_DAMAGE_DAMAGESOURCES = 
[ 
	eDamageSourceId.mp_weapon_defender
]
const array<int> ELECTRIC_SMOKE_DAMAGESOURCES = 
[
	eDamageSourceId.mp_titanability_smoke, 
	//eDamageSourceId.mp_titanability_electric_smoke,
	eDamageSourceId.mp_weapon_grenade_electric_smoke 
]
												
struct
{
	float classicRodeoAdditionalDamage = 1.5 // default additional damage value, should make it changable through playlistVars
	// callbacks
	array<void functionref( entity, var, RodeoWeakPointDamage )> weakPointDamagedCallbacks

	// in-file variable
	bool isWeakPointDamage // for OnWeakPointAttachedTitanDamaged() handle damage
} file
#endif


const asset RODEO_WEAKPOINT_HITBOX_MODEL = $"models/weapons/bullets/triple_threat_projectile.mdl" // $"models/Weapons/ammoboxes/backpack_single.mdl" // this one's too big, will block many damages

void function ClassicRodeo_InitPlaylistVars()
{
	AddPrivateMatchModeSettingEnum( "#MODE_SETTING_CATEGORY_TITAN", "classic_rodeo", [ "#SETTING_DISABLED", "#SETTING_ENABLED" ], "0" )
#if SERVER
	PrecacheModel( RODEO_WEAKPOINT_HITBOX_MODEL )
#endif
}

#if SERVER
void function ClassicRodeo_SetRodeoAttackDamageScale( float scale )
{
	file.classicRodeoAdditionalDamage = scale
}

// UTILITY
entity function CreateClassicRodeoWeakpoint( entity player, entity titan )
{
	entity weakPoint = CreatePropScript( RODEO_WEAKPOINT_HITBOX_MODEL )// 
	weakPoint.SetParent( titan, "RODEO_BATTERY" )
	weakPoint.SetLocalOrigin( < 0, -4, 0 > ) // < 0, 0, 0 > for ammobox
	weakPoint.SetLocalAngles( < 90, -90, 0 > )
	weakPoint.SetTakeDamageType( DAMAGE_YES )

	// setup
	SetTeam( weakPoint, TEAM_UNASSIGNED )
	SetVisibleEntitiesInConeQueriableEnabled( weakPoint, true ) // allow shotgun pellets to find it
	SetObjectCanBeMeleed( weakPoint, false )
	weakPoint.SetPassThroughThickness( 1024 ) // almost prevent every weapon from passing through
	
	weakPoint.kv.solid = SOLID_HITBOXES
	weakPoint.Hide()

	// setup health, avoid it sometimes disappear once and make player unable to land shots
	thread WeakPointHealthThink( weakPoint, titan )

	// debug	
	#if CLASSIC_RODEO_DEBUG
		weakPoint.Show()
	#endif // CLASSIC_RODEO_DEBUG

	entity titanSoul = titan.GetTitanSoul()
	// tweak on weakpoint position
	switch ( GetSoulTitanSubClass( titanSoul ) )
	{
		case "stryder":
			weakPoint.SetLocalOrigin( < 0, -4, -2 > ) // < 0, 4, -4 > for ammobox
			break
		case "ogre":
			weakPoint.SetLocalOrigin( < 0, -7, 0 > )
			break
	}
	
	weakPoint.s.pilot <- player
	weakPoint.s.titanSoul <- titanSoul
	
	AddEntityCallback_OnFinalDamaged( weakPoint, OnRodeoWeakpointDamaged )
	thread HandleWeakPointAttachedTitanDamage( weakPoint, titan )

	return weakPoint
}

void function WeakPointHealthThink( entity weakPoint, entity titan )
{
	titan.EndSignal( "OnDestroy" )
	weakpoint.EndSignal( "OnDestroy" )

	// weak point's health should always be higher than current shot's damage
	// otherwise it will disappear even with DamageInfo_SetDamage() to reduce damage
	while ( true )
	{
		weakPoint.SetMaxHealth( titan.GetMaxHealth() )
		weakPoint.SetHealth( titan.GetHealth() )

		WaitFrame()
	}
}

void function OnRodeoWeakpointDamaged( entity weakPoint, var damageInfo )
{
	DamageInfo_SetDamage( damageInfo, 0 ) // make sure weakPoint ent doesn't die ever

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( attacker != weakPoint.s.pilot ) // avoid things like reapers trigger following things
		return

	entity titanSoul = attacker.GetTitanSoulBeingRodeoed()
	if( !IsValid( titanSoul ) )
		return
	if ( titanSoul != weakPoint.s.titanSoul )
		return

	entity titan = titanSoul.GetTitan() // real titan
	if( !IsValid( titan ) )
		return

	// debug	
	#if CLASSIC_RODEO_DEBUG
		print( "Rodeo Weakpoint damaged!" )
	#endif // CLASSIC_RODEO_DEBUG

	// build struct
	RodeoWeakPointDamage damageStruct
	damageStruct.rodeoDamage = 0
	damageStruct.damageScale = 1.0
	damageStruct.damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	damageStruct.damageTypes = DamageInfo_GetCustomDamageType( damageInfo ) | DF_BYPASS_SHIELD | DF_CRITICAL
	damageStruct.shouldMultiplyDamage = true

	// figure out damage to deal to titan
	// most weapons in ttf2 don't have damage_rodeo, let's use it's damage_near_value_titanarmor
	entity attackerWeapon = DamageInfo_GetWeapon( damageInfo )
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( IsValid( inflictor ) && inflictor.IsProjectile() )
	{
		damageStruct.rodeoDamage = inflictor.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
		damageStruct.damageScale = inflictor.GetProjectileWeaponSettingFloat( eWeaponVar.critical_hit_damage_scale )
	
		// debug
		#if CLASSIC_RODEO_DEBUG
			print( "Weakpoint damaged by projectile!" )
		#endif // CLASSIC_RODEO_DEBUG
	}
	else if ( !IsValid( attackerWeapon ) && IsValid( inflictor ) && inflictor.IsPlayer() ) // damaged by hitscan radius damage
		attackerWeapon = inflictor.GetActiveWeapon()

	// if weapon invalid it must be inflictor damage
	if ( IsValid( attackerWeapon ) )
	{
		damageStruct.rodeoDamage = attackerWeapon.GetWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
		damageStruct.damageScale = attackerWeapon.GetWeaponSettingFloat( eWeaponVar.critical_hit_damage_scale )
	
		// debug
		#if CLASSIC_RODEO_DEBUG
			print( "Weakpoint damaged by hitscan!" )
		#endif // CLASSIC_RODEO_DEBUG
	}

	// debug
	#if CLASSIC_RODEO_DEBUG
		print( "Attack weapon:" + string( attackerWeapon ) )
		print( "Attack inflictor:" + string( inflictor ) )
	#endif // CLASSIC_RODEO_DEBUG

	// not using these check now, since we have done hitbox changes, grenadiers can cause really high damage to player themselves
	//bool canNormallyDamage = attackerWeapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
	//if( canNormallyDamage )
	//	damageStruct.shouldMultiplyDamage = false
	
	// can't get right condition. seems ttf2 doesn't implemented GetWeaponType()
	//if( attackerWeapon.GetWeaponType() == WT_ANTITITAN ) // antiTitan weapons such as defender, can deal so much damage, so don't multiply it
	//	damageStruct.shouldMultiplyDamage = false

	// DEFAULT DAMAGE MODIFIERS
	if( IsValid( inflictor ) )
	{
		if( inflictor.IsProjectile() )
		{
			//print( "inflictor is projectile!" )
			if( inflictor.GetClassName() == "grenade" )
			{
				//print( "damaged by grenade!" )
				damageStruct.shouldMultiplyDamage = false
				if( ( "rodeoDamagedOnce" in inflictor.s ) && inflictor.s.rodeoDamagedOnce ) // prevent grenadiers like MGL from dealing damage twice as normal( explosion will have less damage )
					damageStruct.rodeoDamage = inflictor.GetProjectileWeaponSettingInt( eWeaponVar.explosion_damage_heavy_armor )
				else
					inflictor.s.rodeoDamagedOnce <- true
			}
			// _ball_lightning.gnut has been modified, assuming this is ballLightning 
			if( "ballLightning" in inflictor.s )
			{
				entity ballLightning = expect entity( inflictor.s.ballLightning )
				if ( IsValid( ballLightning ) )
				{
					//print( "damaged by arcball!" )
					damageStruct.rodeoDamage = int( ballLightning.e.ballLightningData.damage * 0.2 ) // titan will still take damage from arcball. rodeo damage should be lower
					damageStruct.shouldMultiplyDamage = false
				}
			}
		}
	}
	// hardcoded modifiers
	if ( NO_ADDITIONAL_DAMAGE_DAMAGESOURCES.contains( damageStruct.damageSourceID ) )
		damageStruct.shouldMultiplyDamage = false
	if ( ELECTRIC_SMOKE_DAMAGESOURCES.contains( damageStruct.damageSourceID ) )
	{
		damageStruct.rodeoDamage = 0 // don't do additional damage for smoke damage
		//rodeoDamage = 300 // electric smoke grenade's damage per tick
		//damageStruct.shouldMultiplyDamage = false
	}

	// run modified callbacks
	foreach ( void functionref( entity, var, RodeoWeakPointDamage ) callbackFunc in file.weakPointDamagedCallbacks )
		callbackFunc( weakPoint, damageInfo, damageStruct )
	//

	// calculate damage
	if( damageStruct.shouldMultiplyDamage )
		damageStruct.rodeoDamage = int( damageStruct.rodeoDamage * damageStruct.damageScale )
	damageStruct.rodeoDamage = int( damageStruct.rodeoDamage * file.classicRodeoAdditionalDamage )

	// debug
	#if CLASSIC_RODEO_DEBUG
		print( "rodeoDamage:" + string( damageStruct.rodeoDamage ) )
	#endif // CLASSIC_RODEO_DEBUG

	if ( damageStruct.rodeoDamage <= 0 ) // no valid damage
		return

	int rodeoDamage = damageStruct.rodeoDamage
	int damageTypes = damageStruct.damageTypes
	int damageSourceID = damageStruct.damageSourceID
	//print( file.classicRodeoAdditionalDamage )
	//print( rodeoDamage )
	// make sure DF_BYPASS_SHIELD is a thing for proper behaviour. DF_RODEO is added in CheckRodeoRiderHitsTitan() so no need to add again.
	// always use attacker as inflictor, projectile as inflictor will be handled by HeavyArmorCriticalHitRequired()
	file.isWeakPointDamage = true // mark as this will be weak point damage
	titan.TakeDamage( rodeoDamage, attacker, attacker, { damageSourceId = eDamageSourceId.rodeo, scriptType = damageTypes } )
	file.isWeakPointDamage = false // clean up

	// hitmarker, automatically triggered by "target.TakeDamage()"
	//attacker.NotifyDidDamage( weakPoint, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ) | DF_CRITICAL, rodeoDamage, DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
}

void function AddCallback_ClassicRodeo_WeakPointDamaged( void functionref( entity, var, RodeoWeakPointDamage ) callbackFunc )
{
	if ( !file.weakPointDamagedCallbacks.contains( callbackFunc ) )
		file.weakPointDamagedCallbacks.append( callbackFunc )
}

// handle attached titan damage
void function HandleWeakPointAttachedTitanDamage( entity weakPoint, entity titan )
{
	titan.EndSignal( "OnDestroy" )
	AddEntityCallback_OnDamaged( titan, OnWeakPointAttachedTitanDamaged )

	weakPoint.WaitSignal( "OnDestroy" )
	RemoveEntityCallback_OnDamaged( titan, OnWeakPointAttachedTitanDamaged )
}

void function OnWeakPointAttachedTitanDamaged( entity titan, var damageInfo )
{
	// weakpoint damage mark!
	if ( !file.isWeakPointDamage ) // this isn't weakpoint damage
	{
		// debug
		#if CLASSIC_RODEO_DEBUG
			print( "Titan taking non-weakpoint damage!" )
		#endif
		return
	}

	// debug
	#if CLASSIC_RODEO_DEBUG
		print( "Titan weakpoint damaged!" )
	#endif
}
#endif